diff --git a/src/libraries/qmfclient/qmailserviceaction.cpp b/src/libraries/qmfclient/qmailserviceaction.cpp
index b502add..1ae7800 100644
--- a/src/libraries/qmfclient/qmailserviceaction.cpp
+++ b/src/libraries/qmfclient/qmailserviceaction.cpp
@@ -829,6 +829,8 @@ void QMailRetrievalActionPrivate::retrievalCompleted(quint64 action)
     \value Flags        Changes to the state of the message should be retrieved.
     \value MetaData     Only the meta data of the message should be retrieved.
     \value Content      The entire content of the message should be retrieved.
+    \value Auto         Protocol specific settings are taken into account during download.
+                        For example, this may mean skipping the attachments.
 */
 
 /*!
diff --git a/src/libraries/qmfclient/qmailserviceaction.h b/src/libraries/qmfclient/qmailserviceaction.h
index 463e71a..2828c25 100644
--- a/src/libraries/qmfclient/qmailserviceaction.h
+++ b/src/libraries/qmfclient/qmailserviceaction.h
@@ -166,7 +166,8 @@ public:
     enum RetrievalSpecification {
         Flags,
         MetaData,
-        Content
+        Content,
+        Auto
     };
 
     QMailRetrievalAction(QObject *parent = 0);
diff --git a/src/plugins/messageservices/imap/imapconfiguration.cpp b/src/plugins/messageservices/imap/imapconfiguration.cpp
index 8ec5500..7a46a13 100644
--- a/src/plugins/messageservices/imap/imapconfiguration.cpp
+++ b/src/plugins/messageservices/imap/imapconfiguration.cpp
@@ -88,6 +88,11 @@ bool ImapConfiguration::canDeleteMail() const
     return (value("canDelete", "1").toInt() != 0);
 }
 
+bool ImapConfiguration::downloadAttachments() const
+{
+    return (value("downloadAttachments", "1").toInt() != 0);
+}
+
 bool ImapConfiguration::isAutoDownload() const
 {
     return (value("autoDownload", "0").toInt() != 0);
diff --git a/src/plugins/messageservices/imap/imapconfiguration.h b/src/plugins/messageservices/imap/imapconfiguration.h
index 4790c74..88586c7 100644
--- a/src/plugins/messageservices/imap/imapconfiguration.h
+++ b/src/plugins/messageservices/imap/imapconfiguration.h
@@ -69,6 +69,7 @@ public:
     int mailAuthentication() const;
 
     bool canDeleteMail() const;
+    bool downloadAttachments() const;
     bool isAutoDownload() const;
     int maxMailSize() const;
 
diff --git a/src/plugins/messageservices/imap/imapservice.cpp b/src/plugins/messageservices/imap/imapservice.cpp
index 14711d3..9c88c53 100644
--- a/src/plugins/messageservices/imap/imapservice.cpp
+++ b/src/plugins/messageservices/imap/imapservice.cpp
@@ -217,6 +217,8 @@ bool ImapService::Source::retrieveMessageList(const QMailAccountId &accountId, c
         _service->_client.strategyContext()->retrieveMessageListStrategy.setAccountCheck(true);
     }
 
+    _service->_client.strategyContext()->retrieveMessageListStrategy.setOperation(
+            _service->_client.strategyContext(), QMailRetrievalAction::Auto);
     _service->_client.strategyContext()->retrieveMessageListStrategy.selectedFoldersAppend(folderIds);
     appendStrategy(&_service->_client.strategyContext()->retrieveMessageListStrategy);
     if(!_unavailable)
@@ -241,8 +243,24 @@ bool ImapService::Source::retrieveMessages(const QMailMessageIdList &messageIds,
     }
 
     _service->_client.strategyContext()->selectedStrategy.clearSelection();
-    _service->_client.strategyContext()->selectedStrategy.setOperation(spec);
-    _service->_client.strategyContext()->selectedStrategy.selectedMailsAppend(messageIds);
+
+    // Select the parts to be downloaded according to "spec".
+    _service->_client.strategyContext()->selectedStrategy.setOperation(
+            _service->_client.strategyContext(), spec);
+    QMailMessageIdList completionList;
+    QList<QPair<QMailMessagePart::Location, uint> > completionSectionList;
+    foreach (const QMailMessageId &id, messageIds) {
+        QMailMessage message(id);
+        _service->_client.strategyContext()->selectedStrategy.prepareCompletionList(
+                _service->_client.strategyContext(), message,
+                completionList, completionSectionList);
+    }
+    _service->_client.strategyContext()->selectedStrategy.selectedMailsAppend(completionList);
+    typedef QPair<QMailMessagePart::Location, uint > SectionDescription;
+    foreach (const SectionDescription &section, completionSectionList) {
+        _service->_client.strategyContext()->selectedStrategy.selectedSectionsAppend(section.first, section.second);
+    }
+
     appendStrategy(&_service->_client.strategyContext()->selectedStrategy);
 
     if(!_unavailable)
@@ -274,7 +292,8 @@ bool ImapService::Source::retrieveMessagePart(const QMailMessagePart::Location &
     }
     
     _service->_client.strategyContext()->selectedStrategy.clearSelection();
-    _service->_client.strategyContext()->selectedStrategy.setOperation(QMailRetrievalAction::Content);
+    _service->_client.strategyContext()->selectedStrategy.setOperation(
+            _service->_client.strategyContext(), QMailRetrievalAction::Content);
     _service->_client.strategyContext()->selectedStrategy.selectedSectionsAppend(partLocation);
     appendStrategy(&_service->_client.strategyContext()->selectedStrategy);
     if(!_unavailable)
@@ -310,7 +329,8 @@ bool ImapService::Source::retrieveMessageRange(const QMailMessageId &messageId,
     location.setContainingMessageId(messageId);
 
     _service->_client.strategyContext()->selectedStrategy.clearSelection();
-    _service->_client.strategyContext()->selectedStrategy.setOperation(QMailRetrievalAction::Content);
+    _service->_client.strategyContext()->selectedStrategy.setOperation(
+            _service->_client.strategyContext(), QMailRetrievalAction::Content);
     _service->_client.strategyContext()->selectedStrategy.selectedSectionsAppend(location, minimum);
     appendStrategy(&_service->_client.strategyContext()->selectedStrategy);
     if(!_unavailable)
@@ -346,7 +366,8 @@ bool ImapService::Source::retrieveMessagePartRange(const QMailMessagePart::Locat
     }
     
     _service->_client.strategyContext()->selectedStrategy.clearSelection();
-    _service->_client.strategyContext()->selectedStrategy.setOperation(QMailRetrievalAction::Content);
+    _service->_client.strategyContext()->selectedStrategy.setOperation(
+            _service->_client.strategyContext(), QMailRetrievalAction::Content);
     _service->_client.strategyContext()->selectedStrategy.selectedSectionsAppend(partLocation, minimum);
     appendStrategy(&_service->_client.strategyContext()->selectedStrategy);
 
@@ -366,7 +387,8 @@ bool ImapService::Source::retrieveAll(const QMailAccountId &accountId)
     _service->_client.strategyContext()->retrieveAllStrategy.setBase(QMailFolderId());
     _service->_client.strategyContext()->retrieveAllStrategy.setQuickList(false);
     _service->_client.strategyContext()->retrieveAllStrategy.setDescending(true);
-    _service->_client.strategyContext()->retrieveAllStrategy.setOperation(QMailRetrievalAction::MetaData);
+    _service->_client.strategyContext()->retrieveAllStrategy.setOperation(
+            _service->_client.strategyContext(), QMailRetrievalAction::MetaData);
     appendStrategy(&_service->_client.strategyContext()->retrieveAllStrategy);
     if(!_unavailable)
         return initiateStrategy();
@@ -430,7 +452,8 @@ bool ImapService::Source::synchronize(const QMailAccountId &accountId)
     _service->_client.strategyContext()->synchronizeAccountStrategy.setBase(QMailFolderId());
     _service->_client.strategyContext()->synchronizeAccountStrategy.setQuickList(false);
     _service->_client.strategyContext()->synchronizeAccountStrategy.setDescending(true);
-    _service->_client.strategyContext()->synchronizeAccountStrategy.setOperation(QMailRetrievalAction::MetaData);
+    _service->_client.strategyContext()->synchronizeAccountStrategy.setOperation(
+            _service->_client.strategyContext(), QMailRetrievalAction::Auto);
     appendStrategy(&_service->_client.strategyContext()->synchronizeAccountStrategy);
     if(!_unavailable)
         return initiateStrategy();
diff --git a/src/plugins/messageservices/imap/imapstrategy.cpp b/src/plugins/messageservices/imap/imapstrategy.cpp
index 34340d6..1fe843b 100644
--- a/src/plugins/messageservices/imap/imapstrategy.cpp
+++ b/src/plugins/messageservices/imap/imapstrategy.cpp
@@ -1342,13 +1342,166 @@ void ImapFetchSelectedMessagesStrategy::clearSelection()
     _retrievalSize.clear();
 }
 
-void ImapFetchSelectedMessagesStrategy::setOperation(QMailRetrievalAction::RetrievalSpecification spec)
+static bool operator==(const QMailMessagePartContainer::Location &a,
+                       const QMailMessagePartContainer::Location &b)
 {
-    if (spec == QMailRetrievalAction::MetaData) {
-        _headerLimit = UINT_MAX;
+    return a.toString(true) == b.toString(true);
+}
+
+void ImapFetchSelectedMessagesStrategy::metaDataAnalysis(ImapStrategyContextBase *context,
+                                                   const QMailMessagePartContainer &partContainer,
+                                                   const QList<QMailMessagePartContainer::Location> &attachmentLocations,
+                                                   QList<QPair<QMailMessagePart::Location, uint> > &sectionList,
+                                                   QList<QPair<QMailMessagePart::Location, uint> > &completionSectionList,
+                                                   uint &bytesLeft,
+                                                   bool &foundBody)
+{
+    if (bytesLeft == 0)
+        return;
+
+    ImapConfiguration imapCfg(context->config());
+    QString preferred(imapCfg.preferredTextSubtype().toLower());
+
+    // Otherwise, consider the subparts individually
+    for (uint i = 0; i < partContainer.partCount(); ++i) {
+        const QMailMessagePart part(partContainer.partAt(i));
+        const QMailMessageContentDisposition disposition(part.contentDisposition());
+        const QMailMessageContentType contentType(part.contentType());
+
+        qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << part.location().toString(true);
+        if (part.partCount() > 0) {
+            qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << part.location().toString(true);
+            metaDataAnalysis(context, part, attachmentLocations,
+                             sectionList, completionSectionList,
+                             bytesLeft, foundBody);
+        } else if (part.partialContentAvailable()) {
+            qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << part.location().toString(true);
+            continue;
+        } else if (disposition.size() <= 0) {
+            qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << part.location().toString(true);
+            continue;
+        } else if (_retrievalSpec == QMailRetrievalAction::Auto
+                   && !imapCfg.downloadAttachments()
+                   && attachmentLocations.contains(part.location())) {
+            qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << part.location().toString(true);
+            continue;
+        } else if (!preferred.isEmpty()
+                   && (contentType.type().toLower() == "text")
+                   && (contentType.subType().toLower() == preferred)
+                   && !foundBody) {
+            qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << part.location().toString(true);
+            // There is a preferred text sub-part to retrieve.
+            // The preferred text part has priority over other parts so,
+            // we put it directly into the main completion list.
+            // Text parts may be downloaded partially.
+            if (bytesLeft >= (uint)disposition.size()) {
+                completionSectionList.append(qMakePair(part.location(), 0u));
+                bytesLeft -= disposition.size();
+            } else {
+                completionSectionList.append(qMakePair(part.location(), static_cast<unsigned>(bytesLeft)));
+                bytesLeft = 0;
+            }
+            foundBody = true;
+        } else {
+            // This is a regular part. Try to download it completely.
+            qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << part.location().toString(true);
+            sectionList.append(qMakePair(part.location(), (uint)disposition.size()));
+        }
+    }
+}
+
+static bool qMailMessageImapStrategyLessThan(const QPair<QMailMessagePart::Location, uint> &l,
+                                             const QPair<QMailMessagePart::Location, uint> &r)
+{
+    return l.second < r.second;
+}
+
+void ImapFetchSelectedMessagesStrategy::prepareCompletionList(
+        ImapStrategyContextBase *context,
+        const QMailMessage &message,
+        QMailMessageIdList &completionList,
+        QList<QPair<QMailMessagePart::Location, uint> > &completionSectionList)
+{
+    ImapConfiguration imapCfg(context->config());
+    const QList<QMailMessagePartContainer::Location> &attachmentLocations = message.findAttachmentLocations();
+
+    if (message.size() < _headerLimit
+        && (_retrievalSpec != QMailRetrievalAction::Auto
+            || (attachmentLocations.isEmpty() || imapCfg.downloadAttachments()))
+       ) {
+        completionList.append(message.id());
+        qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << _headerLimit << completionList.count() << completionSectionList.count();
     } else {
+        const QMailMessageContentType contentType(message.contentType());
+        if (contentType.type().toLower() == "text") {
+            // It is a text part. So, we can retrieve the first
+            // portion of it.
+            QMailMessagePart::Location location;
+            location.setContainingMessageId(message.id());
+            completionSectionList.append(qMakePair(location,
+                                                   static_cast<unsigned>(_headerLimit)));
+            qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << _headerLimit << completionList.count() << completionSectionList.count();
+        } else {
+            uint bytesLeft = _headerLimit;
+            int partsToRetrieve = 0;
+            const int maxParts = 100;
+            bool foundBody = false;
+            QList<QPair<QMailMessagePart::Location, uint> > sectionList;
+            metaDataAnalysis(context, message, attachmentLocations,
+                             sectionList, completionSectionList,
+                             bytesLeft, foundBody);
+
+            qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << bytesLeft << completionList.count() << completionSectionList.count();
+            qSort(sectionList.begin(), sectionList.end(), qMailMessageImapStrategyLessThan);
+            QList<QPair<QMailMessagePart::Location, uint> >::iterator it = sectionList.begin();
+            while (it != sectionList.end() && (bytesLeft > 0) && (partsToRetrieve < maxParts)) {
+                const QMailMessagePart &part = message.partAt(it->first);
+                if (it->second <= (uint)bytesLeft) {
+                    completionSectionList.append(qMakePair(it->first, (uint)0));
+                    qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << bytesLeft << completionList.count() << completionSectionList.count();
+                    bytesLeft -= it->second;
+                    ++partsToRetrieve;
+                } else if (part.contentType().type().toLower() == "text") {
+                    // Text parts can be downloaded partially.
+                    completionSectionList.append(qMakePair(it->first, (uint)bytesLeft));
+                    bytesLeft = 0;
+                    ++partsToRetrieve;
+                }
+                ++it;
+            }
+            qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << _headerLimit << completionList.count() << completionSectionList.count();
+        }
+    }
+}
+
+void ImapFetchSelectedMessagesStrategy::setOperation(
+        ImapStrategyContextBase *context,
+        QMailRetrievalAction::RetrievalSpecification spec)
+{
+    switch (spec) {
+    case QMailRetrievalAction::Auto:
+        {
+            ImapConfiguration imapCfg(context->config());
+            if (imapCfg.isAutoDownload()) {
+                // Just download everything
+                _headerLimit = UINT_MAX;
+            } else {
+                _headerLimit = imapCfg.maxMailSize() * 1024;
+            }
+        }
+        break;
+    case QMailRetrievalAction::Content:
+        _headerLimit = UINT_MAX;
+        break;
+    case QMailRetrievalAction::MetaData:
+    case QMailRetrievalAction::Flags:
+    default:
         _headerLimit = 0;
+        break;
     }
+
+    _retrievalSpec = spec;
+    qMailLog(IMAP) << __LINE__ << Q_FUNC_INFO << _headerLimit;
 }
 
 void ImapFetchSelectedMessagesStrategy::selectedMailsAppend(const QMailMessageIdList& ids) 
@@ -1424,13 +1577,6 @@ void ImapFetchSelectedMessagesStrategy::newConnection(ImapStrategyContextBase *c
     _messageCount = 0;
     _outstandingFetches = 0;
 
-    ImapConfiguration imapCfg(context->config());
-    if (!imapCfg.isAutoDownload()) {
-        _headerLimit = imapCfg.maxMailSize() * 1024;
-    } else {
-        _headerLimit = INT_MAX;
-    }
-
     ImapMessageListStrategy::newConnection(context);
 }
 
@@ -2083,82 +2229,6 @@ void ImapSynchronizeBaseStrategy::folderPreviewCompleted(ImapStrategyContextBase
 {
 }
 
-void ImapSynchronizeBaseStrategy::metaDataAnalysis(ImapStrategyContextBase *context,
-                                                   const QMailMessagePartContainer &partContainer,
-                                                   QList<QPair<QMailMessagePart::Location, uint> > &sectionList,
-                                                   int &bytesLeft,
-                                                   bool &foundBody)
-{
-    if (bytesLeft <= 0)
-        return;
-    
-    ImapConfiguration imapCfg(context->config());
-    QString preferred(imapCfg.preferredTextSubtype().toLower());
-    
-    if (partContainer.multipartType() == QMailMessage::MultipartAlternative) {
-        // See if there is a preferred text sub-part to retrieve
-        for (uint i = 0; i < partContainer.partCount(); ++i) {
-            const QMailMessagePart part(partContainer.partAt(i));
-            const QMailMessageContentDisposition disposition(part.contentDisposition());
-            const QMailMessageContentType contentType(part.contentType());
-
-            if (!preferred.isEmpty()
-                && (contentType.type().toLower() == "text")
-                && (contentType.subType().toLower() == preferred)
-                && !foundBody) {
-
-                if (bytesLeft >= disposition.size()) {
-                    _completionSectionList.append(qMakePair(part.location(), 0u));
-                    bytesLeft -= disposition.size();
-                } else {
-                    // We can retrieve the first portion of this part
-                    _completionSectionList.append(qMakePair(part.location(), static_cast<unsigned>(bytesLeft)));
-                    bytesLeft = 0;
-                }
-                foundBody = true;
-            } else {
-                sectionList.append(qMakePair(part.location(), (uint)disposition.size()));
-            }
-        }
-        return;
-    }
-
-    // Otherwise, consider the subparts individually
-    for (uint i = 0; i < partContainer.partCount(); ++i) {
-        const QMailMessagePart part(partContainer.partAt(i));
-        const QMailMessageContentDisposition disposition(part.contentDisposition());
-        const QMailMessageContentType contentType(part.contentType());
-
-        if (part.partCount() > 0) {
-            metaDataAnalysis(context, part, sectionList, bytesLeft, foundBody);
-        } else if (part.partialContentAvailable()) {
-            continue;
-        } else if (disposition.size() <= 0) {
-            continue;
-        } else if (!preferred.isEmpty()
-                   && (contentType.type().toLower() == "text")
-                   && (contentType.subType().toLower() == preferred)
-                   && !foundBody) {
-            // There is a preferred text sub-part to retrieve
-            if (bytesLeft >= disposition.size()) {
-                _completionSectionList.append(qMakePair(part.location(), 0u));
-                bytesLeft -= disposition.size();
-            } else {
-                _completionSectionList.append(qMakePair(part.location(), static_cast<unsigned>(bytesLeft)));
-                bytesLeft = 0;
-            }
-            foundBody = true;
-        } else {
-            sectionList.append(qMakePair(part.location(), (uint)disposition.size()));
-        }
-    }
-}
-
-bool qMailMessageImapStrategyLessThan(const QPair<QMailMessagePart::Location, uint> &l, const QPair<QMailMessagePart::Location, uint> &r)
-{
-    return l.second < r.second;
-}
-
 void ImapSynchronizeBaseStrategy::messageFetched(ImapStrategyContextBase *context, QMailMessage &message)
 { 
     ImapFolderListStrategy::messageFetched(context, message);
@@ -2169,41 +2239,12 @@ void ImapSynchronizeBaseStrategy::messageFetched(ImapStrategyContextBase *contex
 void ImapSynchronizeBaseStrategy::messageFlushed(ImapStrategyContextBase *context, QMailMessage &message)
 {
     ImapFolderListStrategy::messageFlushed(context, message);
-    if (_error) return;
+    if (_error) {
+        return;
+    }
 
     if ((_transferState == Preview) && (_headerLimit > 0)) {
-        if (message.size() < _headerLimit) {
-            _completionList.append(message.id());
-        } else {
-            const QMailMessageContentType contentType(message.contentType());
-            ImapConfiguration imapCfg(context->config());
-            QString preferred(imapCfg.preferredTextSubtype().toLower());
-            if (!preferred.isEmpty()
-                && (contentType.type().toLower() == "text")
-                && (contentType.subType().toLower() == preferred)) {
-                // We can retrieve the first portion of this message
-                QMailMessagePart::Location location;
-                location.setContainingMessageId(message.id());
-                _completionSectionList.append(qMakePair(location, static_cast<unsigned>(_headerLimit)));
-            } else {
-                int bytesLeft = _headerLimit;
-                int partsToRetrieve = 0;
-                const int maxParts = 100;
-                bool foundBody = false;
-                QList<QPair<QMailMessagePart::Location, uint> > sectionList;
-                metaDataAnalysis(context, message, sectionList, bytesLeft, foundBody);
-                qSort(sectionList.begin(), sectionList.end(), qMailMessageImapStrategyLessThan);
-                QList<QPair<QMailMessagePart::Location, uint> >::iterator it = sectionList.begin();
-                while (it != sectionList.end() && (bytesLeft > 0) && (partsToRetrieve < maxParts)) {
-                    if (it->second <= (uint)bytesLeft) {
-                        _completionSectionList.append(qMakePair(it->first, (uint)0));
-                    }
-                    bytesLeft -= it->second;
-                    ++it;
-                    ++partsToRetrieve;
-                }
-            }
-        }
+        prepareCompletionList(context, message, _completionList, _completionSectionList);
     }
 }
 
diff --git a/src/plugins/messageservices/imap/imapstrategy.h b/src/plugins/messageservices/imap/imapstrategy.h
index e7038c8..48a4948 100644
--- a/src/plugins/messageservices/imap/imapstrategy.h
+++ b/src/plugins/messageservices/imap/imapstrategy.h
@@ -299,10 +299,16 @@ public:
     ImapFetchSelectedMessagesStrategy() {}
     virtual ~ImapFetchSelectedMessagesStrategy() {}
     
-    virtual void setOperation(QMailRetrievalAction::RetrievalSpecification spec);
+    virtual void setOperation(ImapStrategyContextBase *context,
+                              QMailRetrievalAction::RetrievalSpecification spec);
     virtual void clearSelection();
     virtual void selectedMailsAppend(const QMailMessageIdList &ids);
     virtual void selectedSectionsAppend(const QMailMessagePart::Location &, int = -1);
+    virtual void prepareCompletionList(
+                                  ImapStrategyContextBase *context,
+                                  const QMailMessage &message,
+                                  QMailMessageIdList &completionList,
+                                  QList<QPair<QMailMessagePart::Location, uint> > &completionSectionList);
 
     virtual void newConnection(ImapStrategyContextBase *context);
     virtual void transition(ImapStrategyContextBase*, const ImapCommand, const OperationStatus);
@@ -321,6 +327,16 @@ protected:
 
     virtual void itemFetched(ImapStrategyContextBase *context, const QString &uid);
 
+    virtual void metaDataAnalysis(ImapStrategyContextBase *context,
+                                  const QMailMessagePartContainer &partContainer,
+                                  const QList<QMailMessagePartContainer::Location> &attachmentLocations,
+                                  QList<QPair<QMailMessagePart::Location, uint> > &sectionList,
+                                  QList<QPair<QMailMessagePart::Location, uint> > &completionSectionList,
+                                  uint &bytesLeft,
+                                  bool &foundBody);
+
+    QMailRetrievalAction::RetrievalSpecification _retrievalSpec;
+
     uint _headerLimit;
     int _listSize;
     int _messageCount;
@@ -441,12 +457,6 @@ protected:
 
     virtual void processUidSearchResults(ImapStrategyContextBase *context);
 
-    virtual void metaDataAnalysis(ImapStrategyContextBase *context,
-                                  const QMailMessagePartContainer &partContainer,
-                                  QList<QPair<QMailMessagePart::Location, uint> > &sectionList,
-                                  int &bytesLeft,
-                                  bool &foundBody);
-
 protected:
     QStringList _newUids;
     QList<QPair<QMailFolderId, QStringList> > _retrieveUids;
diff --git a/src/plugins/messageservices/pop/popclient.cpp b/src/plugins/messageservices/pop/popclient.cpp
index 8f2df3f..38df526 100644
--- a/src/plugins/messageservices/pop/popclient.cpp
+++ b/src/plugins/messageservices/pop/popclient.cpp
@@ -183,20 +183,30 @@ void PopClient::setOperation(QMailRetrievalAction::RetrievalSpecification spec)
     selected = false;
     deleting = false;
     additional = 0;
-    QMailAccount account(config.id());
 
-    if (spec == QMailRetrievalAction::MetaData) {
-        PopConfiguration popCfg(config);
+    switch (spec) {
+    case QMailRetrievalAction::Auto:
+        {
+            PopConfiguration popCfg(config);
 
-        if (popCfg.isAutoDownload()) {
-            // Just download everything
-            headerLimit = INT_MAX;
-        } else {
-            headerLimit = popCfg.maxMailSize() * 1024;
+            if (popCfg.isAutoDownload()) {
+                // Just download everything
+                headerLimit = UINT_MAX;
+            } else {
+                headerLimit = popCfg.maxMailSize() * 1024;
+            }
         }
-    } else {
+        break;
+    case QMailRetrievalAction::Content:
+        headerLimit = UINT_MAX;
+        break;
+    case QMailRetrievalAction::MetaData:
+    case QMailRetrievalAction::Flags:
+    default:
         headerLimit = 0;
+        break;
     }
+
     findInbox();
 }
 
@@ -239,7 +249,7 @@ void PopClient::setSelectedMails(const SelectionMap& data)
     // We shouldn't have anything left in our retrieval list...
     if (!retrievalSize.isEmpty()) {
         foreach (const QString& uid, retrievalSize.keys())
-            qMailLog(IMAP) << "Message" << uid << "still in retrieve map...";
+            qMailLog(POP) << "Message" << uid << "still in retrieve map...";
 
         retrievalSize.clear();
     }
@@ -697,7 +707,7 @@ void PopClient::nextAction()
             }
 
             QString temp = QString::number(msgNum);
-            if (selected || ((headerLimit > 0) && (mailSize <= headerLimit))) {
+            if ((headerLimit > 0) && (mailSize <= headerLimit)) {
                 // Retrieve the whole message
                 nextCommand = ("RETR " + temp);
                 nextStatus = Retr;
@@ -879,9 +889,9 @@ int PopClient::nextMsgServerPos()
         // if requested mail is not on server, try to get a new mail from the list
         while ( (thisMsg == -1) && !serverId.isEmpty() ) {
             int pos = msgPosFromUidl(serverId);
+            QMailMessage message(selectionMap[serverId]);
             if (pos == -1) {
                 // Mark this message as deleted
-                QMailMessage message(selectionMap[serverId]);
                 if (message.id().isValid()) {
                     message.setStatus(QMailMessage::Removed, true);
                     QMailStore::instance()->updateMessage(&message);
@@ -899,6 +909,9 @@ int PopClient::nextMsgServerPos()
                 thisMsg = pos;
                 messageUid = serverId;
                 mailSize = getSize(thisMsg);
+                if (mailSize == uint(-1) && message.id().isValid()) {
+                    mailSize = message.size();
+                }
             }
         }
 
@@ -1037,7 +1050,7 @@ void PopClient::createMail()
 
     mail->setParentFolderId(folderId);
 
-    bool isComplete = (selected || ((headerLimit > 0) && (mailSize <= headerLimit)));
+    bool isComplete = ((headerLimit > 0) && (mailSize <= headerLimit));
     mail->setStatus(QMailMessage::ContentAvailable, isComplete);
     mail->setStatus(QMailMessage::PartialContentAvailable, isComplete);
     if (!isComplete) {
diff --git a/src/plugins/messageservices/pop/popservice.cpp b/src/plugins/messageservices/pop/popservice.cpp
index 0997052..85823cf 100644
--- a/src/plugins/messageservices/pop/popservice.cpp
+++ b/src/plugins/messageservices/pop/popservice.cpp
@@ -136,7 +136,7 @@ bool PopService::Source::retrieveMessageList(const QMailAccountId &accountId, co
     uint existing = QMailStore::instance()->countMessages(countKey);
     existing = qMin(existing, minimum);
     
-    _service->_client.setOperation(QMailRetrievalAction::MetaData);
+    _service->_client.setOperation(QMailRetrievalAction::Auto);
     _service->_client.setAdditional(minimum - existing);
 
     if (!_service->_client.synchronizationEnabled(folderId)) {
