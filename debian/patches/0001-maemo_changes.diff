diff --git a/qmf.pro b/qmf.pro
index cd9a51e..3415d8e 100644
--- a/qmf.pro
+++ b/qmf.pro
@@ -1,5 +1,6 @@
 TEMPLATE = subdirs
-SUBDIRS = src/libraries/qtopiamail \
+SUBDIRS = src/libraries/sparql \
+          src/libraries/qtopiamail \
           src/libraries/messageserver \
           src/libraries/qmfutil \
           src/plugins/messageservices/imap \
diff --git a/src/libraries/messageserver/include/QMailAuthenticator b/src/libraries/messageserver/include/QMailAuthenticator
new file mode 100644
index 0000000..a1c5ba5
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailAuthenticator
@@ -0,0 +1 @@
+#include "qmailauthenticator.h"
diff --git a/src/libraries/messageserver/include/QMailMessageClassifier b/src/libraries/messageserver/include/QMailMessageClassifier
new file mode 100644
index 0000000..285ed1a
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageClassifier
@@ -0,0 +1 @@
+#include "qmailmessageclassifier.h"
diff --git a/src/libraries/messageserver/include/QMailMessageService b/src/libraries/messageserver/include/QMailMessageService
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageService
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageServiceConfigurator b/src/libraries/messageserver/include/QMailMessageServiceConfigurator
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageServiceConfigurator
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageServiceEditor b/src/libraries/messageserver/include/QMailMessageServiceEditor
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageServiceEditor
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageServiceFactory b/src/libraries/messageserver/include/QMailMessageServiceFactory
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageServiceFactory
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageServicePlugin b/src/libraries/messageserver/include/QMailMessageServicePlugin
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageServicePlugin
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageSink b/src/libraries/messageserver/include/QMailMessageSink
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageSink
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageSource b/src/libraries/messageserver/include/QMailMessageSource
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageSource
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailServiceConfiguration b/src/libraries/messageserver/include/QMailServiceConfiguration
new file mode 100644
index 0000000..c6f8a6c
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailServiceConfiguration
@@ -0,0 +1 @@
+#include "qmailserviceconfiguration.h"
diff --git a/src/libraries/messageserver/include/QMailTransport b/src/libraries/messageserver/include/QMailTransport
new file mode 100644
index 0000000..1b390c9
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailTransport
@@ -0,0 +1 @@
+#include "qmailtransport.h"
diff --git a/src/libraries/messageserver/messageserver.pro b/src/libraries/messageserver/messageserver.pro
index 2b02a7b..1677d4d 100644
--- a/src/libraries/messageserver/messageserver.pro
+++ b/src/libraries/messageserver/messageserver.pro
@@ -1,12 +1,10 @@
 TEMPLATE = lib 
 
 TARGET = messageserver
-target.path += $$QMF_INSTALL_ROOT/lib
-INSTALLS += target
 
 QT *= network
 
-CONFIG += warn_on
+CONFIG += warn_on create_pc create_prl
 
 DEPENDPATH += .
 
@@ -27,3 +25,18 @@ SOURCES += qmailauthenticator.cpp \
            qmailserviceconfiguration.cpp \
            qmailstoreaccountfilter.cpp \
            qmailtransport.cpp
+
+target.path += $$QMF_INSTALL_ROOT/lib
+INSTALLS += target
+
+# Install headers
+headers.files = $$HEADERS include/*
+headers.path  = $$QMF_INSTALL_ROOT/include/qmf
+
+INSTALLS += headers 
+
+# Install pkgconfig file
+QMAKE_PKGCONFIG_LIBDIR  = $$target.path
+QMAKE_PKGCONFIG_INCDIR  = $$headers.path
+QMAKE_PKGCONFIG_DESTDIR = pkgconfig
+
diff --git a/src/libraries/qmfutil/include/QMailComposerFactory b/src/libraries/qmfutil/include/QMailComposerFactory
new file mode 100644
index 0000000..23b68f1
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailComposerFactory
@@ -0,0 +1 @@
+#include "qmailcomposer.h"
\ No newline at end of file
diff --git a/src/libraries/qmfutil/include/QMailComposerInterface b/src/libraries/qmfutil/include/QMailComposerInterface
new file mode 100644
index 0000000..23b68f1
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailComposerInterface
@@ -0,0 +1 @@
+#include "qmailcomposer.h"
\ No newline at end of file
diff --git a/src/libraries/qmfutil/include/QMailMessageDelegate b/src/libraries/qmfutil/include/QMailMessageDelegate
new file mode 100644
index 0000000..6d19eb2
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailMessageDelegate
@@ -0,0 +1 @@
+#include "qmailmessagedelegate.h"
\ No newline at end of file
diff --git a/src/libraries/qmfutil/include/QMailViewerFactory b/src/libraries/qmfutil/include/QMailViewerFactory
new file mode 100644
index 0000000..81a8bde
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailViewerFactory
@@ -0,0 +1 @@
+#include "qmailviewer.h"
diff --git a/src/libraries/qmfutil/include/QMailViewerInterface b/src/libraries/qmfutil/include/QMailViewerInterface
new file mode 100644
index 0000000..dc9d052
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailViewerInterface
@@ -0,0 +1 @@
+#include "qmailviewer.h"
\ No newline at end of file
diff --git a/src/libraries/qmfutil/include/QtopiaHomeMailMessageDelegate b/src/libraries/qmfutil/include/QtopiaHomeMailMessageDelegate
new file mode 100644
index 0000000..6d19eb2
--- /dev/null
+++ b/src/libraries/qmfutil/include/QtopiaHomeMailMessageDelegate
@@ -0,0 +1 @@
+#include "qmailmessagedelegate.h"
\ No newline at end of file
diff --git a/src/libraries/qmfutil/qmfutil.pro b/src/libraries/qmfutil/qmfutil.pro
index c58af12..c01a180 100644
--- a/src/libraries/qmfutil/qmfutil.pro
+++ b/src/libraries/qmfutil/qmfutil.pro
@@ -1,10 +1,8 @@
 TEMPLATE = lib 
 
 TARGET = qmfutil 
-target.path += $$QMF_INSTALL_ROOT/lib
-INSTALLS += target
 
-CONFIG += warn_on
+CONFIG += warn_on create_pc create_prl
 
 DEPENDPATH += .
 
@@ -31,3 +29,18 @@ TRANSLATIONS += libqmfutil-ar.ts \
                 libqmfutil-pt_BR.ts \
                 libqmfutil-zh_CN.ts \
                 libqmfutil-zh_TW.ts
+
+target.path += $$QMF_INSTALL_ROOT/lib
+INSTALLS += target
+
+# Install headers
+headers.files = $$HEADERS include/*
+headers.path  = $$QMF_INSTALL_ROOT/include/qmf
+
+INSTALLS += headers 
+
+# Install pkgconfig file
+QMAKE_PKGCONFIG_LIBDIR  = $$target.path
+QMAKE_PKGCONFIG_INCDIR  = $$headers.path
+QMAKE_PKGCONFIG_DESTDIR = pkgconfig
+
diff --git a/src/libraries/qtopiamail/include/MailId b/src/libraries/qtopiamail/include/MailId
new file mode 100644
index 0000000..e2db656
--- /dev/null
+++ b/src/libraries/qtopiamail/include/MailId
@@ -0,0 +1 @@
+#include "qmailid.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccount b/src/libraries/qtopiamail/include/QMailAccount
new file mode 100644
index 0000000..e403614
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccount
@@ -0,0 +1 @@
+#include "qmailaccount.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountConfiguration b/src/libraries/qtopiamail/include/QMailAccountConfiguration
new file mode 100644
index 0000000..0631517
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountConfiguration
@@ -0,0 +1 @@
+#include "qmailaccountconfiguration.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountId b/src/libraries/qtopiamail/include/QMailAccountId
new file mode 100644
index 0000000..e2db656
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountId
@@ -0,0 +1 @@
+#include "qmailid.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountKey b/src/libraries/qtopiamail/include/QMailAccountKey
new file mode 100644
index 0000000..1c39992
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountKey
@@ -0,0 +1 @@
+#include "qmailaccountkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountListModel b/src/libraries/qtopiamail/include/QMailAccountListModel
new file mode 100644
index 0000000..a9d6feb
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountListModel
@@ -0,0 +1 @@
+#include "qmailaccountlistmodel.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountMessageSet b/src/libraries/qtopiamail/include/QMailAccountMessageSet
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountMessageSet
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountSortKey b/src/libraries/qtopiamail/include/QMailAccountSortKey
new file mode 100644
index 0000000..87a88f6
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountSortKey
@@ -0,0 +1 @@
+#include "qmailaccountsortkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailAddress b/src/libraries/qtopiamail/include/QMailAddress
new file mode 100644
index 0000000..80d6726
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAddress
@@ -0,0 +1 @@
+#include "qmailaddress.h"
diff --git a/src/libraries/qtopiamail/include/QMailBase64Codec b/src/libraries/qtopiamail/include/QMailBase64Codec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailBase64Codec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailCodec b/src/libraries/qtopiamail/include/QMailCodec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailCodec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailContentManager b/src/libraries/qtopiamail/include/QMailContentManager
new file mode 100644
index 0000000..7c05cb5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailContentManager
@@ -0,0 +1 @@
+#include "qmailcontentmanager.h"
diff --git a/src/libraries/qtopiamail/include/QMailContentManagerFactory b/src/libraries/qtopiamail/include/QMailContentManagerFactory
new file mode 100644
index 0000000..7c05cb5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailContentManagerFactory
@@ -0,0 +1 @@
+#include "qmailcontentmanager.h"
diff --git a/src/libraries/qtopiamail/include/QMailContentManagerPlugin b/src/libraries/qtopiamail/include/QMailContentManagerPlugin
new file mode 100644
index 0000000..7c05cb5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailContentManagerPlugin
@@ -0,0 +1 @@
+#include "qmailcontentmanager.h"
diff --git a/src/libraries/qtopiamail/include/QMailFilterMessageSet b/src/libraries/qtopiamail/include/QMailFilterMessageSet
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFilterMessageSet
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolder b/src/libraries/qtopiamail/include/QMailFolder
new file mode 100644
index 0000000..cae2455
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolder
@@ -0,0 +1 @@
+#include "qmailfolder.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolderId b/src/libraries/qtopiamail/include/QMailFolderId
new file mode 100644
index 0000000..e2db656
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolderId
@@ -0,0 +1 @@
+#include "qmailid.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolderKey b/src/libraries/qtopiamail/include/QMailFolderKey
new file mode 100644
index 0000000..5effe63
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolderKey
@@ -0,0 +1 @@
+#include "qmailfolderkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolderMessageSet b/src/libraries/qtopiamail/include/QMailFolderMessageSet
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolderMessageSet
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolderSortKey b/src/libraries/qtopiamail/include/QMailFolderSortKey
new file mode 100644
index 0000000..231dba5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolderSortKey
@@ -0,0 +1 @@
+#include "qmailfoldersortkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailLineEndingCodec b/src/libraries/qtopiamail/include/QMailLineEndingCodec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailLineEndingCodec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessage b/src/libraries/qtopiamail/include/QMailMessage
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessage
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageBody b/src/libraries/qtopiamail/include/QMailMessageBody
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageBody
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageContentDisposition b/src/libraries/qtopiamail/include/QMailMessageContentDisposition
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageContentDisposition
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageContentType b/src/libraries/qtopiamail/include/QMailMessageContentType
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageContentType
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageHeaderField b/src/libraries/qtopiamail/include/QMailMessageHeaderField
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageHeaderField
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageId b/src/libraries/qtopiamail/include/QMailMessageId
new file mode 100644
index 0000000..e2db656
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageId
@@ -0,0 +1 @@
+#include "qmailid.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageKey b/src/libraries/qtopiamail/include/QMailMessageKey
new file mode 100644
index 0000000..06211f5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageKey
@@ -0,0 +1 @@
+#include "qmailmessagekey.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageListModel b/src/libraries/qtopiamail/include/QMailMessageListModel
new file mode 100644
index 0000000..5eb664a
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageListModel
@@ -0,0 +1 @@
+#include "qmailmessagelistmodel.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageMetaData b/src/libraries/qtopiamail/include/QMailMessageMetaData
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageMetaData
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessagePart b/src/libraries/qtopiamail/include/QMailMessagePart
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessagePart
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessagePartContainer b/src/libraries/qtopiamail/include/QMailMessagePartContainer
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessagePartContainer
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageRemovalRecord b/src/libraries/qtopiamail/include/QMailMessageRemovalRecord
new file mode 100644
index 0000000..737bd83
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageRemovalRecord
@@ -0,0 +1 @@
+#include "qmailmessageremovalrecord.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageServer b/src/libraries/qtopiamail/include/QMailMessageServer
new file mode 100644
index 0000000..5398cdc
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageServer
@@ -0,0 +1 @@
+#include "qmailmessageserver.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageSet b/src/libraries/qtopiamail/include/QMailMessageSet
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageSet
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageSetContainer b/src/libraries/qtopiamail/include/QMailMessageSetContainer
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageSetContainer
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageSetModel b/src/libraries/qtopiamail/include/QMailMessageSetModel
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageSetModel
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageSortKey b/src/libraries/qtopiamail/include/QMailMessageSortKey
new file mode 100644
index 0000000..b6f0399
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageSortKey
@@ -0,0 +1 @@
+#include "qmailmessagesortkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailNewEmailHandler b/src/libraries/qtopiamail/include/QMailNewEmailHandler
new file mode 100644
index 0000000..61db895
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailNewEmailHandler
@@ -0,0 +1 @@
+#include "qmailnewmessagehandler.h"
diff --git a/src/libraries/qtopiamail/include/QMailNewMessageHandler b/src/libraries/qtopiamail/include/QMailNewMessageHandler
new file mode 100644
index 0000000..61db895
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailNewMessageHandler
@@ -0,0 +1 @@
+#include "qmailnewmessagehandler.h"
diff --git a/src/libraries/qtopiamail/include/QMailPassThroughCodec b/src/libraries/qtopiamail/include/QMailPassThroughCodec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailPassThroughCodec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailQuotedPrintableCodec b/src/libraries/qtopiamail/include/QMailQuotedPrintableCodec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailQuotedPrintableCodec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailRetrievalAction b/src/libraries/qtopiamail/include/QMailRetrievalAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailRetrievalAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QMailSearchAction b/src/libraries/qtopiamail/include/QMailSearchAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailSearchAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QMailServiceAction b/src/libraries/qtopiamail/include/QMailServiceAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailServiceAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QMailStorageAction b/src/libraries/qtopiamail/include/QMailStorageAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailStorageAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QMailStore b/src/libraries/qtopiamail/include/QMailStore
new file mode 100644
index 0000000..217a7a7
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailStore
@@ -0,0 +1 @@
+#include "qmailstore.h"
diff --git a/src/libraries/qtopiamail/include/QMailTimeStamp b/src/libraries/qtopiamail/include/QMailTimeStamp
new file mode 100644
index 0000000..07bfe99
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailTimeStamp
@@ -0,0 +1 @@
+#include "qmailtimestamp.h"
diff --git a/src/libraries/qtopiamail/include/QMailTransmitAction b/src/libraries/qtopiamail/include/QMailTransmitAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailTransmitAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QPrivatelyImplemented b/src/libraries/qtopiamail/include/QPrivatelyImplemented
new file mode 100644
index 0000000..0b73b3b
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QPrivatelyImplemented
@@ -0,0 +1 @@
+#include "qprivateimplementation.h"
diff --git a/src/libraries/qtopiamail/include/QPrivatelyNoncopyable b/src/libraries/qtopiamail/include/QPrivatelyNoncopyable
new file mode 100644
index 0000000..0b73b3b
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QPrivatelyNoncopyable
@@ -0,0 +1 @@
+#include "qprivateimplementation.h"
diff --git a/src/libraries/qtopiamail/include/ServiceConfiguration b/src/libraries/qtopiamail/include/ServiceConfiguration
new file mode 100644
index 0000000..0631517
--- /dev/null
+++ b/src/libraries/qtopiamail/include/ServiceConfiguration
@@ -0,0 +1 @@
+#include "qmailaccountconfiguration.h"
diff --git a/src/libraries/qtopiamail/include/Status b/src/libraries/qtopiamail/include/Status
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/Status
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/qmailstore.cpp b/src/libraries/qtopiamail/qmailstore.cpp
index 814a2dd..504303b 100644
--- a/src/libraries/qtopiamail/qmailstore.cpp
+++ b/src/libraries/qtopiamail/qmailstore.cpp
@@ -11,7 +11,12 @@
 // Needed to give friend access to the function defined by Q_GLOBAL_STATIC
 #define QMAILSTOREINSTANCE_DEFINED_HERE
 #include "qmailstore.h"
+
+#ifndef SPARQL_STORE
 #include "qmailstore_p.h"
+#else
+#include "qmailstore_sparql.h"
+#endif
 
 /*!
     \class QMailStore
diff --git a/src/libraries/qtopiamail/qmailstore_sparql.cpp b/src/libraries/qtopiamail/qmailstore_sparql.cpp
new file mode 100644
index 0000000..029ca4e
--- /dev/null
+++ b/src/libraries/qtopiamail/qmailstore_sparql.cpp
@@ -0,0 +1,6610 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "qmailstore_sparql.h"
+#include "qmailcontentmanager.h"
+#include "qmailmessageremovalrecord.h"
+#include "qmailtimestamp.h"
+#include "semaphore_p.h"
+#include "qmailnamespace.h"
+#include "qmaillog.h"
+#include <QSqlQuery>
+#include <QSqlError>
+#include <QSqlRecord>
+#include <QTextCodec>
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <unistd.h>
+#include <time.h>
+#include <QFile>
+#include <QCoreApplication>
+#include <QDir>
+
+#include "sparqlquery.h"
+#include "sparqlresult.h"
+#include "sparqluri.h"
+
+
+#define Q_USE_SQLITE
+
+// When using GCC 4.1.1 on ARM, TR1 functional cannot be included when RTTI
+// is disabled, since it automatically instantiates some code using typeid().
+//#include <tr1/functional>
+//using std::tr1::bind;
+//using std::tr1::cref;
+#include "bind_p.h"
+
+using nonstd::tr1::bind;
+using nonstd::tr1::cref;
+
+
+class QMailStorePrivate::Key
+{
+    enum Type {
+        Account = 0,
+        AccountSort,
+        Folder,
+        FolderSort,
+        Message,
+        MessageSort,
+        Text
+    };
+
+    Type m_type;
+    const void* m_key;
+    const QString* m_alias;
+
+    template<typename NonKeyType>
+    bool isType(NonKeyType) const { return false; }
+
+    bool isType(QMailAccountKey*) const { return (m_type == Account); }
+    bool isType(QMailAccountSortKey*) const { return (m_type == AccountSort); }
+    bool isType(QMailFolderKey*) const { return (m_type == Folder); }
+    bool isType(QMailFolderSortKey*) const { return (m_type == FolderSort); }
+    bool isType(QMailMessageKey*) const { return (m_type == Message); }
+    bool isType(QMailMessageSortKey*) const { return (m_type == MessageSort); }
+    bool isType(QString*) const { return (m_type == Text); }
+
+    const QMailAccountKey &key(QMailAccountKey*) const { return *reinterpret_cast<const QMailAccountKey*>(m_key); }
+    const QMailAccountSortKey &key(QMailAccountSortKey*) const { return *reinterpret_cast<const QMailAccountSortKey*>(m_key); }
+    const QMailFolderKey &key(QMailFolderKey*) const { return *reinterpret_cast<const QMailFolderKey*>(m_key); }
+    const QMailFolderSortKey &key(QMailFolderSortKey*) const { return *reinterpret_cast<const QMailFolderSortKey*>(m_key); }
+    const QMailMessageKey &key(QMailMessageKey*) const { return *reinterpret_cast<const QMailMessageKey*>(m_key); }
+    const QMailMessageSortKey &key(QMailMessageSortKey*) const { return *reinterpret_cast<const QMailMessageSortKey*>(m_key); }
+    const QString &key(QString*) const { return *m_alias; }
+
+public:
+    explicit Key(const QMailAccountKey &key, const QString &alias = QString()) : m_type(Account), m_key(&key), m_alias(&alias) {}
+    explicit Key(const QMailAccountSortKey &key, const QString &alias = QString()) : m_type(AccountSort), m_key(&key), m_alias(&alias) {}
+
+    explicit Key(const QMailFolderKey &key, const QString &alias = QString()) : m_type(Folder), m_key(&key), m_alias(&alias) {}
+    explicit Key(const QMailFolderSortKey &key, const QString &alias = QString()) : m_type(FolderSort), m_key(&key), m_alias(&alias) {}
+
+    explicit Key(const QMailMessageKey &key, const QString &alias = QString()) : m_type(Message), m_key(&key), m_alias(&alias) {}
+    explicit Key(const QMailMessageSortKey &key, const QString &alias = QString()) : m_type(MessageSort), m_key(&key), m_alias(&alias) {}
+
+    explicit Key(const QString &text) : m_type(Text), m_key(0), m_alias(&text) {}
+
+    template<typename KeyType>
+    bool isType() const { return isType(reinterpret_cast<KeyType*>(0)); }
+
+    template<typename KeyType>
+    const KeyType &key() const { return key(reinterpret_cast<KeyType*>(0)); }
+
+    const QString &alias() const { return *m_alias; }
+};
+
+
+namespace { // none of this code is externally visible:
+
+//using namespace QMailDataComparator;
+using namespace QMailKey;
+
+// We allow queries to be specified by supplying a list of message IDs against
+// which candidates will be matched; this list can become too large to be
+// expressed directly in SQL.  Instead, we will build a temporary table to
+// match against when required...
+// The most IDs we can include in a query is currently 999; set an upper limit
+// below this to allow for other variables in the same query, bearing in mind
+// that there may be more than one clause containing this number of IDs in the
+// same query...
+const int IdLookupThreshold = 256;
+
+// Note on retry logic - it appears that SQLite3 will return a SQLITE_BUSY error (5)
+// whenever there is contention on file locks or mutexes, and that these occurrences
+// are not handled by the handler installed by either sqlite3_busy_timeout or
+// sqlite3_busy_handler.  Furthermore, the comments for sqlite3_step state that if
+// the SQLITE_BUSY error is returned whilst in a transaction, the transaction should
+// be rolled back.  Therefore, it appears that we must handle this error by retrying
+// at the QMailStore level, since this is the level where we perform transactions.
+const int Sqlite3BusyErrorNumber = 5;
+
+const int Sqlite3ConstraintErrorNumber = 19;
+
+
+// Helper class for automatic unlocking
+template<typename Mutex>
+class Guard
+{
+    Mutex &mutex;
+    bool locked;
+
+public:
+    enum { DefaultTimeout = 1000 };
+
+    Guard(Mutex& m)
+        : mutex(m),
+          locked(false) 
+    {
+    }
+
+    ~Guard()
+    {
+        unlock();
+    }
+
+    bool lock(int timeout = DefaultTimeout)
+    {
+        return (locked = mutex.lock(timeout));
+    }
+
+    void unlock()
+    {
+        if (locked) {
+            mutex.unlock();
+            locked = false; 
+        }
+    }
+};
+
+typedef Guard<ProcessMutex> MutexGuard;
+
+
+template <typename IdType>
+QVariantList idValueList(const QList<IdType>& ids)
+{
+    QVariantList values;
+
+    foreach (const IdType& id, ids)
+        values.append(QVariant(id.toULongLong()));
+
+    return values;
+}
+
+
+QString escape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(escapee, QString(escaper) + escapee);
+}
+
+QString unescape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(QString(escaper) + escapee, escapee);
+}
+
+QString contentUri(const QString &scheme, const QString &identifier)
+{
+    if (scheme.isEmpty())
+        return QString();
+
+    // Formulate a URI from the content scheme and identifier
+    return escape(scheme, ':') + ':' + escape(identifier, ':');
+}
+
+QString contentUri(const QMailMessageMetaData &message)
+{
+    return contentUri(message.contentScheme(), message.contentIdentifier());
+}
+
+QPair<QString, QString> uriElements(const QString &uri)
+{
+    int index = uri.indexOf(':');
+    while ((index != -1) && (uri.at(index - 1) == '\\'))
+        index = uri.indexOf(':', index + 1);
+
+    return qMakePair(unescape(uri.mid(0, index), ':'), unescape(uri.mid(index + 1), ':'));
+}
+
+
+template<typename ValueContainer>
+class MessageValueExtractor;
+
+// Class to extract QMailMessageMetaData properties to QVariant form
+template<>
+class MessageValueExtractor<QMailMessageMetaData>
+{
+    const QMailMessageMetaData &_data;
+    
+public:
+    MessageValueExtractor(const QMailMessageMetaData &d) : _data(d) {}
+
+    QVariant id() const { return _data.id().toULongLong(); }
+
+    QVariant messageType() const { return static_cast<int>(_data.messageType()); }
+
+    QVariant parentFolderId() const { return _data.parentFolderId().toULongLong(); }
+
+    QVariant from() const { return _data.from().toString(); }
+
+    QVariant to() const { return QMailAddress::toStringList(_data.to()).join(","); }
+
+    QVariant subject() const { return _data.subject(); }
+
+    QVariant date() const { return _data.date().toLocalTime(); }
+
+    QVariant receivedDate() const { return _data.receivedDate().toLocalTime(); }
+
+    // Don't record the value of the UnloadedData flag:
+    QVariant status() const { return (_data.status() & ~QMailMessage::UnloadedData); }
+
+    QVariant parentAccountId() const { return _data.parentAccountId().toULongLong(); }
+
+    QVariant serverUid() const { return _data.serverUid(); }
+
+    QVariant size() const { return _data.size(); }
+
+    QVariant content() const { return static_cast<int>(_data.content()); }
+
+    QVariant previousParentFolderId() const { return _data.previousParentFolderId().toULongLong(); }
+
+    QVariant contentScheme() const { return _data.contentScheme(); }
+
+    QVariant contentIdentifier() const { return _data.contentIdentifier(); }
+
+    QVariant inResponseTo() const { return _data.inResponseTo().toULongLong(); }
+
+    QVariant responseType() const { return static_cast<int>(_data.responseType()); }
+};
+
+// Class to extract QMailMessageMetaData properties from QVariant object
+template<>
+class MessageValueExtractor<QVariant>
+{
+    const QVariant &_value;
+    
+public:
+    MessageValueExtractor(const QVariant &v) : _value(v) {}
+
+    QMailMessageId id() const { return QMailMessageId(QMailStorePrivate::extractValue<quint64>(_value)); }
+
+    QMailMessage::MessageType messageType() const { return QMailMessage::MessageType(QMailStorePrivate::extractValue<int>(_value)); }
+
+    QMailFolderId parentFolderId() const { return QMailFolderId(QMailStorePrivate::extractValue<quint64>(_value)); }
+
+    QMailAddress from() const { return QMailAddress(QMailStorePrivate::extractValue<QString>(_value)); }
+
+    QList<QMailAddress> to() const { return QMailAddress::fromStringList(QMailStorePrivate::extractValue<QString>(_value)); }
+
+    QString subject() const { return QMailStorePrivate::extractValue<QString>(_value); }
+
+    QMailTimeStamp date() const { return QMailTimeStamp(QMailStorePrivate::extractValue<QDateTime>(_value)); }
+
+    QMailTimeStamp receivedDate() const { return QMailTimeStamp(QMailStorePrivate::extractValue<QDateTime>(_value)); }
+
+    quint64 status() const { return QMailStorePrivate::extractValue<quint64>(_value); }
+
+    QMailAccountId parentAccountId() const { return QMailAccountId(QMailStorePrivate::extractValue<quint64>(_value)); }
+
+    QString serverUid() const { return QMailStorePrivate::extractValue<QString>(_value); }
+
+    int size() const { return QMailStorePrivate::extractValue<int>(_value); }
+
+    QMailMessage::ContentType content() const { return QMailMessage::ContentType(QMailStorePrivate::extractValue<int>(_value)); }
+
+    QMailFolderId previousParentFolderId() const { return QMailFolderId(QMailStorePrivate::extractValue<quint64>(_value)); }
+
+    QString contentUri() const { return QMailStorePrivate::extractValue<QString>(_value); }
+
+    QMailMessageId inResponseTo() const { return QMailMessageId(QMailStorePrivate::extractValue<quint64>(_value)); }
+
+    QMailMessage::ResponseType responseType() const { return QMailMessage::ResponseType(QMailStorePrivate::extractValue<int>(_value)); }
+};
+
+
+// Properties of the mailmessages table
+static QMailStorePrivate::MessagePropertyMap messagePropertyMap() 
+{
+    QMailStorePrivate::MessagePropertyMap map; 
+
+    map.insert(QMailMessageKey::Id,"id");
+    map.insert(QMailMessageKey::Type,"type");
+    map.insert(QMailMessageKey::ParentFolderId,"parentfolderid");
+    map.insert(QMailMessageKey::Sender,"sender");
+    map.insert(QMailMessageKey::Recipients,"recipients");
+    map.insert(QMailMessageKey::Subject,"subject");
+    map.insert(QMailMessageKey::TimeStamp,"stamp");
+    map.insert(QMailMessageKey::ReceptionTimeStamp,"receivedstamp");
+    map.insert(QMailMessageKey::Status,"status");
+    map.insert(QMailMessageKey::ParentAccountId,"parentaccountid");
+    map.insert(QMailMessageKey::ServerUid,"serveruid");
+    map.insert(QMailMessageKey::Size,"size");
+    map.insert(QMailMessageKey::ContentType,"contenttype");
+    map.insert(QMailMessageKey::PreviousParentFolderId,"previousparentfolderid");
+    map.insert(QMailMessageKey::ContentScheme,"mailfile");
+    map.insert(QMailMessageKey::ContentIdentifier,"mailfile");
+    map.insert(QMailMessageKey::InResponseTo,"responseid");
+    map.insert(QMailMessageKey::ResponseType,"responsetype");
+
+    return map;
+}
+
+static QString messagePropertyName(QMailMessageKey::Property property)
+{
+    static const QMailStorePrivate::MessagePropertyMap map(messagePropertyMap());
+
+    QMailStorePrivate::MessagePropertyMap::const_iterator it = map.find(property);
+    if (it != map.end())
+        return it.value();
+
+    if ((property != QMailMessageKey::AncestorFolderIds) &&
+        (property != QMailMessageKey::Conversation) &&
+        (property != QMailMessageKey::Custom))
+        qWarning() << "Unknown message property:" << property;
+    
+    return QString();
+}
+
+typedef QMap<QMailAccountKey::Property, QString> AccountPropertyMap;
+
+// Properties of the mailaccounts table
+static AccountPropertyMap accountPropertyMap() 
+{
+    AccountPropertyMap map; 
+
+    map.insert(QMailAccountKey::Id,"id");
+    map.insert(QMailAccountKey::Name,"name");
+    map.insert(QMailAccountKey::MessageType,"type");
+    map.insert(QMailAccountKey::FromAddress,"emailaddress");
+    map.insert(QMailAccountKey::Status,"status");
+
+    return map;
+}
+
+static QString accountPropertyName(QMailAccountKey::Property property)
+{
+    static const AccountPropertyMap map(accountPropertyMap());
+
+    AccountPropertyMap::const_iterator it = map.find(property);
+    if (it != map.end())
+        return it.value();
+
+    if (property != QMailAccountKey::Custom)
+        qWarning() << "Unknown account property:" << property;
+
+    return QString();
+}
+
+typedef QMap<QMailFolderKey::Property, QString> FolderPropertyMap;
+
+// Properties of the mailfolders table
+static FolderPropertyMap folderPropertyMap() 
+{
+    FolderPropertyMap map; 
+
+    map.insert(QMailFolderKey::Id,"id");
+    map.insert(QMailFolderKey::Path,"name");
+    map.insert(QMailFolderKey::ParentFolderId,"parentid");
+    map.insert(QMailFolderKey::ParentAccountId,"parentaccountid");
+    map.insert(QMailFolderKey::DisplayName,"displayname");
+    map.insert(QMailFolderKey::Status,"status");
+    map.insert(QMailFolderKey::ServerCount,"servercount");
+    map.insert(QMailFolderKey::ServerUnreadCount,"serverunreadcount");
+
+    return map;
+}
+
+static QString folderPropertyName(QMailFolderKey::Property property)
+{
+    static const FolderPropertyMap map(folderPropertyMap());
+
+    FolderPropertyMap::const_iterator it = map.find(property);
+    if (it != map.end())
+        return it.value();
+
+    if ((property != QMailFolderKey::AncestorFolderIds) &&
+        (property != QMailFolderKey::Custom))
+        qWarning() << "Unknown folder property:" << property;
+
+    return QString();
+}
+
+// Build lists of column names from property values
+
+static QString qualifiedName(const QString &name, const QString &alias)
+{
+    if (alias.isEmpty())
+        return name;
+
+    return (alias + '.' + name);
+}
+
+template<typename PropertyType>
+QString fieldName(PropertyType property, const QString &alias);
+
+template<>
+QString fieldName<QMailMessageKey::Property>(QMailMessageKey::Property property, const QString& alias)
+{
+    return qualifiedName(messagePropertyName(property), alias);
+}
+
+template<>
+QString fieldName<QMailFolderKey::Property>(QMailFolderKey::Property property, const QString& alias)
+{
+    return qualifiedName(folderPropertyName(property), alias);
+}
+
+template<>
+QString fieldName<QMailAccountKey::Property>(QMailAccountKey::Property property, const QString& alias)
+{
+    return qualifiedName(accountPropertyName(property), alias);
+}
+
+template<typename SourceType, typename TargetType>
+TargetType matchingProperty(SourceType source);
+
+static QMap<QMailMessageSortKey::Property, QMailMessageKey::Property> messageSortMapInit()
+{
+    QMap<QMailMessageSortKey::Property, QMailMessageKey::Property> map;
+
+    // Provide a mapping of sort key properties to the corresponding filter key
+    map.insert(QMailMessageSortKey::Id, QMailMessageKey::Id);
+    map.insert(QMailMessageSortKey::Type, QMailMessageKey::Type);
+    map.insert(QMailMessageSortKey::ParentFolderId, QMailMessageKey::ParentFolderId);
+    map.insert(QMailMessageSortKey::Sender, QMailMessageKey::Sender);
+    map.insert(QMailMessageSortKey::Recipients, QMailMessageKey::Recipients);
+    map.insert(QMailMessageSortKey::Subject, QMailMessageKey::Subject);
+    map.insert(QMailMessageSortKey::TimeStamp, QMailMessageKey::TimeStamp);
+    map.insert(QMailMessageSortKey::ReceptionTimeStamp, QMailMessageKey::ReceptionTimeStamp);
+    map.insert(QMailMessageSortKey::Status, QMailMessageKey::Status);
+    map.insert(QMailMessageSortKey::ParentAccountId, QMailMessageKey::ParentAccountId);
+    map.insert(QMailMessageSortKey::ServerUid, QMailMessageKey::ServerUid);
+    map.insert(QMailMessageSortKey::Size, QMailMessageKey::Size);
+    map.insert(QMailMessageSortKey::ContentType, QMailMessageKey::ContentType);
+    map.insert(QMailMessageSortKey::PreviousParentFolderId, QMailMessageKey::PreviousParentFolderId);
+
+    return map;
+}
+
+template<>
+QMailMessageKey::Property matchingProperty<QMailMessageSortKey::Property, QMailMessageKey::Property>(QMailMessageSortKey::Property source)
+{
+    static QMap<QMailMessageSortKey::Property, QMailMessageKey::Property> map(messageSortMapInit());
+    return map.value(source);
+}
+
+static QMap<QMailFolderSortKey::Property, QMailFolderKey::Property> folderSortMapInit()
+{
+    QMap<QMailFolderSortKey::Property, QMailFolderKey::Property> map;
+
+    // Provide a mapping of sort key properties to the corresponding filter key
+    map.insert(QMailFolderSortKey::Id, QMailFolderKey::Id);
+    map.insert(QMailFolderSortKey::Path, QMailFolderKey::Path);
+    map.insert(QMailFolderSortKey::ParentFolderId, QMailFolderKey::ParentFolderId);
+    map.insert(QMailFolderSortKey::ParentAccountId, QMailFolderKey::ParentAccountId);
+    map.insert(QMailFolderSortKey::DisplayName, QMailFolderKey::DisplayName);
+    map.insert(QMailFolderSortKey::Status, QMailFolderKey::Status);
+    map.insert(QMailFolderSortKey::ServerCount, QMailFolderKey::ServerCount);
+    map.insert(QMailFolderSortKey::ServerUnreadCount, QMailFolderKey::ServerUnreadCount);
+
+    return map;
+}
+
+template<>
+QMailFolderKey::Property matchingProperty<QMailFolderSortKey::Property, QMailFolderKey::Property>(QMailFolderSortKey::Property source)
+{
+    static QMap<QMailFolderSortKey::Property, QMailFolderKey::Property> map(folderSortMapInit());
+    return map.value(source);
+}
+
+static QMap<QMailAccountSortKey::Property, QMailAccountKey::Property> accountSortMapInit()
+{
+    QMap<QMailAccountSortKey::Property, QMailAccountKey::Property> map;
+
+    // Provide a mapping of sort key properties to the corresponding filter key
+    map.insert(QMailAccountSortKey::Id, QMailAccountKey::Id);
+    map.insert(QMailAccountSortKey::Name, QMailAccountKey::Name);
+    map.insert(QMailAccountSortKey::MessageType, QMailAccountKey::MessageType);
+    map.insert(QMailAccountSortKey::Status, QMailAccountKey::Status);
+
+    return map;
+}
+
+template<>
+QMailAccountKey::Property matchingProperty<QMailAccountSortKey::Property, QMailAccountKey::Property>(QMailAccountSortKey::Property source)
+{
+    static QMap<QMailAccountSortKey::Property, QMailAccountKey::Property> map(accountSortMapInit());
+    return map.value(source);
+}
+
+template<>
+QString fieldName<QMailMessageSortKey::Property>(QMailMessageSortKey::Property property, const QString &alias)
+{
+    return qualifiedName(messagePropertyName(matchingProperty<QMailMessageSortKey::Property, QMailMessageKey::Property>(property)), alias);
+}
+
+template<>
+QString fieldName<QMailFolderSortKey::Property>(QMailFolderSortKey::Property property, const QString &alias)
+{
+    return qualifiedName(folderPropertyName(matchingProperty<QMailFolderSortKey::Property, QMailFolderKey::Property>(property)), alias);
+}
+
+template<>
+QString fieldName<QMailAccountSortKey::Property>(QMailAccountSortKey::Property property, const QString &alias)
+{
+    return qualifiedName(accountPropertyName(matchingProperty<QMailAccountSortKey::Property, QMailAccountKey::Property>(property)), alias);
+}
+
+template<typename PropertyType>
+QString fieldNames(const QList<PropertyType> &properties, const QString &separator, const QString &alias)
+{
+    QStringList fields;
+    foreach (const PropertyType &property, properties)
+        fields.append(fieldName(property, alias));
+
+    return fields.join(separator);
+}
+
+template<typename ArgumentType>
+void appendWhereValues(const ArgumentType &a, QVariantList &values);
+
+template<typename KeyType>
+QVariantList whereClauseValues(const KeyType& key)
+{
+    QVariantList values;
+
+    foreach (const typename KeyType::ArgumentType& a, key.arguments())
+        ::appendWhereValues(a, values);
+
+    foreach (const KeyType& subkey, key.subKeys())
+        values += ::whereClauseValues<KeyType>(subkey);
+
+    return values;
+}
+
+template <typename Key, typename Argument = typename Key::ArgumentType>
+class ArgumentExtractorBase
+{
+protected:
+    const Argument &arg;
+    
+    ArgumentExtractorBase(const Argument &a) : arg(a) {}
+
+    QString minimalString(const QString &s) const
+    {
+        // If the argument is a phone number, ensure it is in minimal form
+        QMailAddress address(s);
+        if (address.isPhoneNumber()) {
+            QString minimal(address.minimalPhoneNumber());
+
+            // Rather than compare exact numbers, we will only use the trailing
+            // digits to compare phone numbers - otherwise, slightly different 
+            // forms of the same number will not be matched
+            static const int significantDigits = 8;
+
+            int extraneous = minimal.length() - significantDigits;
+            if (extraneous > 0)
+                minimal.remove(0, extraneous);
+
+            return minimal;
+        }
+
+        return s;
+    }
+
+    QString submatchString(const QString &s, bool valueMinimalised) const
+    {
+        if (!s.isEmpty()) {
+            // Delimit data for sql "LIKE" operator
+            if (((arg.op == Includes) || (arg.op == Excludes)) || (((arg.op == Equal) || (arg.op == NotEqual)) && valueMinimalised))
+                return QString("\%" + s + "\%");
+        } else if ((arg.op == Includes) || (arg.op == Excludes)) {
+            return QString("\%");
+        }
+
+        return s;
+    }
+
+    QString addressStringValue() const
+    {
+        return submatchString(minimalString(QMailStorePrivate::extractValue<QString>(arg.valueList.first())), true);
+    }
+
+    QString stringValue() const
+    {
+        return submatchString(QMailStorePrivate::extractValue<QString>(arg.valueList.first()), false);
+    }
+
+    QVariantList stringValues() const
+    {
+        QVariantList values;
+
+        if (arg.valueList.count() == 1) {
+            values.append(stringValue());
+        } else {
+            // Includes/Excludes is not a pattern match with multiple values
+            foreach (const QVariant &item, arg.valueList)
+                values.append(QMailStorePrivate::extractValue<QString>(item));
+        }
+
+        return values;
+    }
+
+    template<typename ID>
+    quint64 idValue() const
+    {
+        return QMailStorePrivate::extractValue<ID>(arg.valueList.first()).toULongLong(); 
+    }
+
+    template<typename ClauseKey>
+    QVariantList idValues() const
+    {
+        const QVariant& var = arg.valueList.first();
+
+        if (qVariantCanConvert<ClauseKey>(var)) {
+            return ::whereClauseValues(qVariantValue<ClauseKey>(var));
+        } else {
+            QVariantList values;
+
+            foreach (const QVariant &item, arg.valueList)
+                values.append(QMailStorePrivate::extractValue<typename ClauseKey::IdType>(item).toULongLong());
+
+            return values;
+        }
+    }
+
+    int intValue() const
+    {
+        return QMailStorePrivate::extractValue<int>(arg.valueList.first());
+    }
+
+    QVariantList intValues() const
+    {
+        QVariantList values;
+
+        foreach (const QVariant &item, arg.valueList)
+            values.append(QMailStorePrivate::extractValue<int>(item));
+
+        return values;
+    }
+
+    int quint64Value() const
+    {
+        return QMailStorePrivate::extractValue<quint64>(arg.valueList.first());
+    }
+
+    QVariantList customValues() const
+    {
+        QVariantList values;
+
+        QStringList constraints = QMailStorePrivate::extractValue<QStringList>(arg.valueList.first());
+        // Field name required for existence or value test
+        values.append(constraints.takeFirst());
+
+        if (!constraints.isEmpty()) {
+            // For a value test, we need the comparison value also
+            values.append(submatchString(constraints.takeFirst(), false));
+        }
+
+        return values;
+    }
+};
+
+
+template<typename PropertyType, typename BitmapType = int>
+class RecordExtractorBase
+{
+protected:
+    const QSqlRecord &record;
+    const BitmapType bitmap;
+
+    RecordExtractorBase(const QSqlRecord &r, BitmapType b = 0) : record(r), bitmap(b) {}
+    virtual ~RecordExtractorBase() {}
+    
+    template<typename ValueType>
+    ValueType value(const QString &field, const ValueType &defaultValue = ValueType()) const 
+    { 
+        int index(fieldIndex(field, bitmap));
+
+        if (record.isNull(index))
+            return defaultValue;
+        else
+            return QMailStorePrivate::extractValue<ValueType>(record.value(index), defaultValue);
+    }
+    
+    template<typename ValueType>
+    ValueType value(PropertyType p, const ValueType &defaultValue = ValueType()) const 
+    { 
+        return value(fieldName(p, QString()), defaultValue);
+    }
+
+    virtual int fieldIndex(const QString &field, BitmapType b) const = 0;
+
+    int mappedFieldIndex(const QString &field, BitmapType bitmap, QMap<BitmapType, QMap<QString, int> > &fieldIndex) const
+    {
+        typename QMap<BitmapType, QMap<QString, int> >::iterator it = fieldIndex.find(bitmap);
+        if (it == fieldIndex.end()) {
+            it = fieldIndex.insert(bitmap, QMap<QString, int>());
+        }
+
+        QMap<QString, int> &fields(it.value());
+
+        QMap<QString, int>::iterator fit = fields.find(field);
+        if (fit != fields.end())
+            return fit.value();
+
+        int index = record.indexOf(field);
+        fields.insert(field, index);
+        return index;
+    }
+};
+
+
+// Class to extract data from records of the mailmessages table
+class MessageRecord : public RecordExtractorBase<QMailMessageKey::Property, QMailMessageKey::Properties>
+{
+public:
+    MessageRecord(const QSqlRecord &r, QMailMessageKey::Properties props) 
+        : RecordExtractorBase<QMailMessageKey::Property, QMailMessageKey::Properties>(r, props) {}
+
+    QMailMessageId id() const { return QMailMessageId(value<quint64>(QMailMessageKey::Id)); }
+
+    QMailMessage::MessageType messageType() const { return QMailMessage::MessageType(value<int>(QMailMessageKey::Type, QMailMessage::None)); }
+
+    QMailFolderId parentFolderId() const { return QMailFolderId(value<quint64>(QMailMessageKey::ParentFolderId)); }
+
+    QMailAddress from() const { return QMailAddress(value<QString>(QMailMessageKey::Sender)); }
+
+    QList<QMailAddress> to() const { return QMailAddress::fromStringList(value<QString>(QMailMessageKey::Recipients)); }
+
+    QString subject() const { return value<QString>(QMailMessageKey::Subject); }
+
+    QMailTimeStamp date() const { return QMailTimeStamp(value<QDateTime>(QMailMessageKey::TimeStamp)); }
+
+    QMailTimeStamp receivedDate() const { return QMailTimeStamp(value<QDateTime>(QMailMessageKey::TimeStamp)); }
+
+    quint64 status() const { return value<quint64>(QMailMessageKey::Status, 0); }
+
+    QMailAccountId parentAccountId() const { return QMailAccountId(value<quint64>(QMailMessageKey::ParentAccountId)); }
+
+    QString serverUid() const { return value<QString>(QMailMessageKey::ServerUid); }
+
+    int size() const { return value<int>(QMailMessageKey::Size); }
+
+    QMailMessage::ContentType content() const { return QMailMessage::ContentType(value<int>(QMailMessageKey::ContentType, QMailMessage::UnknownContent)); }
+
+    QMailFolderId previousParentFolderId() const { return QMailFolderId(value<quint64>(QMailMessageKey::PreviousParentFolderId)); }
+
+    QString contentScheme() const 
+    { 
+        if (_uriElements.first.isNull()) 
+            _uriElements = ::uriElements(value<QString>(QMailMessageKey::ContentScheme)); 
+
+        return _uriElements.first;
+    }
+
+    QString contentIdentifier() const 
+    { 
+        if (_uriElements.first.isNull()) 
+            _uriElements = ::uriElements(value<QString>(QMailMessageKey::ContentIdentifier)); 
+
+        return _uriElements.second;
+    }
+
+    QMailMessageId inResponseTo() const { return QMailMessageId(value<quint64>(QMailMessageKey::InResponseTo)); }
+
+    QMailMessage::ResponseType responseType() const { return QMailMessage::ResponseType(value<int>(QMailMessageKey::ResponseType, QMailMessage::NoResponse)); }
+
+private:
+    int fieldIndex(const QString &field, QMailMessageKey::Properties props) const
+    {
+        return mappedFieldIndex(field, props, _fieldIndex);
+    }
+
+    mutable QPair<QString, QString> _uriElements;
+
+    static QMap<QMailMessageKey::Properties, QMap<QString, int> > _fieldIndex;
+};
+
+QMap<QMailMessageKey::Properties, QMap<QString, int> > MessageRecord::_fieldIndex;
+
+
+// Class to convert QMailMessageKey argument values to SQL bind values
+class MessageKeyArgumentExtractor : public ArgumentExtractorBase<QMailMessageKey>
+{
+public:
+    MessageKeyArgumentExtractor(const QMailMessageKey::ArgumentType &a) 
+        : ArgumentExtractorBase<QMailMessageKey>(a) {}
+
+    QVariantList id() const { return idValues<QMailMessageKey>(); }
+
+    QVariant messageType() const { return intValue(); }
+
+    QVariantList parentFolderId() const { return idValues<QMailFolderKey>(); }
+
+    QVariantList ancestorFolderIds() const {  return idValues<QMailFolderKey>(); }
+
+    QVariantList sender() const { return stringValues(); }
+
+    QVariant recipients() const { return addressStringValue(); }
+
+    QVariantList subject() const { return stringValues(); }
+
+    QVariant date() const { return QMailStorePrivate::extractValue<QDateTime>(arg.valueList.first()); }
+
+    QVariant receivedDate() const { return QMailStorePrivate::extractValue<QDateTime>(arg.valueList.first()); }
+
+    QVariant status() const
+    {
+        // The UnloadedData flag has no meaningful persistent value
+        return (QMailStorePrivate::extractValue<quint64>(arg.valueList.first()) & ~QMailMessage::UnloadedData);
+    }
+
+    QVariantList parentAccountId() const { return idValues<QMailAccountKey>(); }
+
+    QVariantList serverUid() const { return stringValues(); }
+
+    QVariant size() const { return intValue(); }
+
+    QVariantList content() const { return intValues(); }
+
+    QVariantList previousParentFolderId() const { return idValues<QMailFolderKey>(); }
+
+    QVariant contentScheme() const 
+    { 
+        // Any colons in the field will be stored in escaped format
+        QString value(::escape(QMailStorePrivate::extractValue<QString>(arg.valueList.first()), ':')); 
+
+        if ((arg.op == Includes) || (arg.op == Excludes)) {
+            value.prepend('%').append('%');
+        } else if ((arg.op == Equal) || (arg.op == NotEqual)) {
+            value.append(":%");
+        }
+        return value;
+    }
+
+    QVariant contentIdentifier() const 
+    { 
+        // Any colons in the field will be stored in escaped format
+        QString value(::escape(QMailStorePrivate::extractValue<QString>(arg.valueList.first()), ':')); 
+
+        if ((arg.op == Includes) || (arg.op == Excludes)) {
+            value.prepend('%').append('%');
+        } else if ((arg.op == Equal) || (arg.op == NotEqual)) {
+            value.prepend("%:");
+        }
+        return value;
+    }
+
+    QVariantList inResponseTo() const { return idValues<QMailMessageKey>(); }
+
+    QVariantList responseType() const { return intValues(); }
+
+    QVariant conversation() const
+    {
+        // TODO: Not yet implemented
+        return QVariant();
+    }
+
+    QVariantList custom() const { return customValues(); }
+};
+
+template<>
+void appendWhereValues<QMailMessageKey::ArgumentType>(const QMailMessageKey::ArgumentType &a, QVariantList &values)
+{
+    const MessageKeyArgumentExtractor extractor(a);
+
+    switch (a.property)
+    { 
+    case QMailMessageKey::Id:
+        if (a.valueList.count() < IdLookupThreshold) {
+            values += extractor.id();
+        } else {
+            // This value match has been replaced by a table lookup
+        }
+        break;
+
+    case QMailMessageKey::Type:
+        values += extractor.messageType();
+        break;
+
+    case QMailMessageKey::ParentFolderId:
+        values += extractor.parentFolderId();
+        break;
+
+    case QMailMessageKey::AncestorFolderIds:
+        values += extractor.ancestorFolderIds();
+        break;
+
+    case QMailMessageKey::Sender:
+        values += extractor.sender();
+        break;
+
+    case QMailMessageKey::Recipients:
+        values += extractor.recipients();
+        break;
+
+    case QMailMessageKey::Subject:
+        values += extractor.subject();
+        break;
+
+    case QMailMessageKey::TimeStamp:
+        values += extractor.date();
+        break;
+
+    case QMailMessageKey::ReceptionTimeStamp:
+        values += extractor.receivedDate();
+        break;
+
+    case QMailMessageKey::Status:
+        values += extractor.status();
+        break;
+
+    case QMailMessageKey::ParentAccountId:
+        values += extractor.parentAccountId();
+        break;
+
+    case QMailMessageKey::ServerUid:
+        values += extractor.serverUid();
+        break;
+
+    case QMailMessageKey::Size:
+        values += extractor.size();
+        break;
+
+    case QMailMessageKey::ContentType:
+        values += extractor.content();
+        break;
+
+    case QMailMessageKey::PreviousParentFolderId:
+        values += extractor.previousParentFolderId();
+        break;
+
+    case QMailMessageKey::ContentScheme:
+        values += extractor.contentScheme();
+        break;
+
+    case QMailMessageKey::ContentIdentifier:
+        values += extractor.contentIdentifier();
+        break;
+
+    case QMailMessageKey::InResponseTo:
+        values += extractor.inResponseTo();
+        break;
+
+    case QMailMessageKey::ResponseType:
+        values += extractor.responseType();
+        break;
+
+    case QMailMessageKey::Conversation:
+        values += extractor.conversation();
+        break;
+
+    case QMailMessageKey::Custom:
+        values += extractor.custom();
+        break;
+    }
+}
+
+
+// Class to extract data from records of the mailaccounts table
+class AccountRecord : public RecordExtractorBase<QMailAccountKey::Property>
+{
+public:
+    AccountRecord(const QSqlRecord &r) 
+        : RecordExtractorBase<QMailAccountKey::Property>(r) {}
+
+    QMailAccountId id() const { return QMailAccountId(value<quint64>(QMailAccountKey::Id)); }
+
+    QString name() const { return value<QString>(QMailAccountKey::Name); }
+
+    QMailMessage::MessageType messageType() const { return QMailMessage::MessageType(value<int>(QMailAccountKey::MessageType, -1)); }
+
+    QString fromAddress() const { return value<QString>(QMailAccountKey::FromAddress); }
+
+    quint64 status() const { return value<quint64>(QMailAccountKey::Status); }
+
+    QString signature() const { return value<QString>("signature"); }
+
+private:
+    int fieldIndex(const QString &field, int props) const
+    {
+        return mappedFieldIndex(field, props, _fieldIndex);
+    }
+
+    static QMap<int, QMap<QString, int> > _fieldIndex;
+};
+
+QMap<int, QMap<QString, int> > AccountRecord::_fieldIndex;
+
+
+// Class to convert QMailAccountKey argument values to SQL bind values
+class AccountKeyArgumentExtractor : public ArgumentExtractorBase<QMailAccountKey>
+{
+public:
+    AccountKeyArgumentExtractor(const QMailAccountKey::ArgumentType &a)
+        : ArgumentExtractorBase<QMailAccountKey>(a) {}
+
+    QVariantList id() const { return idValues<QMailAccountKey>(); }
+
+    QVariantList name() const { return stringValues(); }
+
+    QVariant messageType() const { return intValue(); }
+
+    QVariant fromAddress() const 
+    { 
+        QString value(QMailStorePrivate::extractValue<QString>(arg.valueList.first()));
+
+        // This test will be converted to a LIKE test, for all comparators
+        if (arg.op == Equal || arg.op == NotEqual) {
+            // Ensure exact match by testing for address delimiters
+            value.prepend('<').append('>');
+        }
+
+        return value.prepend('%').append('%');
+    }
+
+    QVariant status() const { return quint64Value(); }
+
+    QVariantList custom() const { return customValues(); }
+};
+
+template<>
+void appendWhereValues<QMailAccountKey::ArgumentType>(const QMailAccountKey::ArgumentType &a, QVariantList &values)
+{
+    const AccountKeyArgumentExtractor extractor(a);
+
+    switch (a.property)
+    {
+    case QMailAccountKey::Id:
+        values += extractor.id();
+        break;
+
+    case QMailAccountKey::Name:
+        values += extractor.name();
+        break;
+
+    case QMailAccountKey::MessageType:
+        values += extractor.messageType();
+        break;
+
+    case QMailAccountKey::FromAddress:
+        values += extractor.fromAddress();
+        break;
+
+    case QMailAccountKey::Status:
+        values += extractor.status();
+        break;
+
+    case QMailAccountKey::Custom:
+        values += extractor.custom();
+        break;
+    }
+}
+
+
+// Class to extract data from records of the mailfolders table
+class FolderRecord : public RecordExtractorBase<QMailFolderKey::Property>
+{
+public:
+    FolderRecord(const QSqlRecord &r)
+        : RecordExtractorBase<QMailFolderKey::Property>(r) {}
+
+    QMailFolderId id() const { return QMailFolderId(value<quint64>(QMailFolderKey::Id)); }
+
+    QString path() const { return value<QString>(QMailFolderKey::Path); }
+
+    QMailFolderId parentFolderId() const { return QMailFolderId(value<quint64>(QMailFolderKey::ParentFolderId)); }
+
+    QMailAccountId parentAccountId() const { return QMailAccountId(value<quint64>(QMailFolderKey::ParentAccountId)); }
+
+    QString displayName() const { return value<QString>(QMailFolderKey::DisplayName); }
+
+    quint64 status() const { return value<quint64>(QMailFolderKey::Status); }
+
+    uint serverCount() const { return value<uint>(QMailFolderKey::ServerCount); }
+
+    uint serverUnreadCount() const { return value<uint>(QMailFolderKey::ServerUnreadCount); }
+
+private:
+    int fieldIndex(const QString &field, int props) const
+    {
+        return mappedFieldIndex(field, props, _fieldIndex);
+    }
+
+    static QMap<int, QMap<QString, int> > _fieldIndex;
+};
+
+QMap<int, QMap<QString, int> > FolderRecord::_fieldIndex;
+
+
+// Class to convert QMailFolderKey argument values to SQL bind values
+class FolderKeyArgumentExtractor : public ArgumentExtractorBase<QMailFolderKey>
+{
+public:
+    FolderKeyArgumentExtractor(const QMailFolderKey::ArgumentType &a)
+        : ArgumentExtractorBase<QMailFolderKey>(a) {}
+
+    QVariantList id() const { return idValues<QMailFolderKey>(); }
+
+    QVariantList path() const { return stringValues(); }
+
+    QVariantList parentFolderId() const { return idValues<QMailFolderKey>(); }
+
+    QVariantList ancestorFolderIds() const {  return idValues<QMailFolderKey>(); }
+
+    QVariantList parentAccountId() const { return idValues<QMailAccountKey>(); }
+
+    QVariantList displayName() const { return stringValues(); }
+
+    QVariant status() const { return quint64Value(); }
+
+    QVariant serverCount() const { return intValue(); }
+
+    QVariant serverUnreadCount() const { return intValue(); }
+
+    QVariantList custom() const { return customValues(); }
+};
+
+template<>
+void appendWhereValues<QMailFolderKey::ArgumentType>(const QMailFolderKey::ArgumentType &a, QVariantList &values)
+{
+    const FolderKeyArgumentExtractor extractor(a);
+
+    switch (a.property)
+    {
+    case QMailFolderKey::Id:
+        values += extractor.id();
+        break;
+
+    case QMailFolderKey::Path:
+        values += extractor.path();
+        break;
+
+    case QMailFolderKey::ParentFolderId:
+        values += extractor.parentFolderId();
+        break;
+
+    case QMailFolderKey::AncestorFolderIds:
+        values += extractor.ancestorFolderIds();
+        break;
+
+    case QMailFolderKey::ParentAccountId:
+        values += extractor.parentAccountId();
+        break;
+
+    case QMailFolderKey::DisplayName:
+        values += extractor.displayName();
+        break;
+
+    case QMailFolderKey::Status:
+        values += extractor.status();
+        break;
+
+    case QMailFolderKey::ServerCount:
+        values += extractor.serverCount();
+        break;
+
+    case QMailFolderKey::ServerUnreadCount:
+        values += extractor.serverUnreadCount();
+        break;
+
+    case QMailFolderKey::Custom:
+        values += extractor.custom();
+        break;
+    }
+}
+
+
+// Class to extract data from records of the deletedmessages table
+class MessageRemovalRecord : public RecordExtractorBase<int>
+{
+public:
+    MessageRemovalRecord(const QSqlRecord &r)
+        : RecordExtractorBase<int>(r) {}
+
+    quint64 id() const { return value<quint64>("id"); }
+
+    QMailAccountId parentAccountId() const { return QMailAccountId(value<quint64>("parentaccountid")); }
+
+    QString serverUid() const { return value<QString>("serveruid"); }
+
+    QMailFolderId parentFolderId() const { return QMailFolderId(value<quint64>("parentfolderid")); }
+
+private:
+    int fieldIndex(const QString &field, int props) const
+    {
+        return mappedFieldIndex(field, props, _fieldIndex);
+    }
+
+    static QMap<int, QMap<QString, int> > _fieldIndex;
+};
+
+QMap<int, QMap<QString, int> > MessageRemovalRecord::_fieldIndex;
+
+
+static QString incrementAlias(const QString &alias)
+{
+    QRegExp aliasPattern("([a-z]+)([0-9]+)");
+    if (aliasPattern.exactMatch(alias)) {
+        return aliasPattern.cap(1) + QString::number(aliasPattern.cap(2).toInt() + 1);
+    }
+
+    return QString();
+}
+
+template<typename ArgumentListType>
+QString buildOrderClause(const ArgumentListType &list, const QString &alias)
+{
+    if (list.isEmpty())
+        return QString();
+
+    QStringList sortColumns;
+    foreach (typename ArgumentListType::const_reference arg, list)
+        sortColumns.append(fieldName(arg.first, alias) + ' ' + (arg.second == Qt::AscendingOrder ? "ASC" : "DESC"));
+
+    return QString(" ORDER BY ") + sortColumns.join(",");
+}
+
+
+QString operatorString(QMailKey::Comparator op, bool multipleArgs = false, bool patternMatch = false, bool bitwiseMultiples = false)
+{
+    switch (op) 
+    {
+    case Equal:
+        return (multipleArgs ? " IN " : (patternMatch ? " LIKE " : " = "));
+        break;
+
+    case NotEqual:
+        return (multipleArgs ? " NOT IN " : (patternMatch ? " NOT LIKE " : " <> "));
+        break;
+
+    case LessThan:
+        return " < ";
+        break;
+
+    case LessThanEqual:
+        return " <= ";
+        break;
+
+    case GreaterThan:
+        return " > ";
+        break;
+
+    case GreaterThanEqual:
+        return " >= ";
+        break;
+
+    case Includes:
+    case Present:
+        return (multipleArgs ? " IN " : (bitwiseMultiples ? " & " : " LIKE "));
+        break;
+
+    case Excludes:
+    case Absent:
+        // Note: the result is not correct in the bitwiseMultiples case!
+        return (multipleArgs ? " NOT IN " : (bitwiseMultiples ? " & " : " NOT LIKE "));
+        break;
+    }
+
+    return QString();
+}
+
+QString combineOperatorString(QMailKey::Combiner op)
+{
+    switch (op) 
+    {
+    case And:
+        return " AND ";
+        break;
+
+    case Or:
+        return " OR ";
+        break;
+
+    case None:
+        break;
+    }
+
+    return QString();
+}
+
+QString columnExpression(const QString &column, QMailKey::Comparator op, const QString &value, bool multipleArgs = false, bool patternMatch = false, bool bitwiseMultiples = false)
+{
+    QString operation(operatorString(op, multipleArgs, patternMatch, bitwiseMultiples));
+
+    QString expression(column + operation);
+
+    // Special case handling:
+    if (bitwiseMultiples && (op == QMailKey::Excludes)) {
+        if (!value.isEmpty()) {
+            return "0 = (" + expression + value + ")";
+        } else {
+            return "0 = " + expression;
+        }
+    }
+
+    return expression + value;
+}
+
+QString columnExpression(const QString &column, QMailKey::Comparator op, const QVariantList &valueList, bool patternMatch = false, bool bitwiseMultiples = false)
+{
+    QString value(QMailStorePrivate::expandValueList(valueList)); 
+
+    return columnExpression(column, op, value, (valueList.count() > 1), patternMatch, bitwiseMultiples);
+}
+
+QString baseExpression(const QString &column, QMailKey::Comparator op, bool multipleArgs = false, bool patternMatch = false, bool bitwiseMultiples = false)
+{
+    return columnExpression(column, op, QString(), multipleArgs, patternMatch, bitwiseMultiples);
+}
+
+
+template<typename Key>
+QString whereClauseItem(const Key &key, const typename Key::ArgumentType &arg, const QString &alias, const QMailStorePrivate &store);
+
+template<>
+QString whereClauseItem<QMailAccountKey>(const QMailAccountKey &, const QMailAccountKey::ArgumentType &a, const QString &alias, const QMailStorePrivate &store)
+{
+    QString item;
+    {
+        QTextStream q(&item);
+
+        QString columnName = fieldName(a.property, alias);
+
+        bool bitwise((a.property == QMailAccountKey::Status) || (a.property == QMailAccountKey::MessageType));
+        bool patternMatching(a.property == QMailAccountKey::FromAddress);
+
+        QString expression = columnExpression(columnName, a.op, a.valueList, patternMatching, bitwise);
+        
+        switch(a.property)
+        {
+        case QMailAccountKey::Id:
+            if (a.valueList.first().canConvert<QMailAccountKey>()) {
+                QMailAccountKey subKey = a.valueList.first().value<QMailAccountKey>();
+                QString nestedAlias(incrementAlias(alias));
+
+                // Expand comparison to sub-query result
+                q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailaccounts " << nestedAlias;
+                q << store.buildWhereClause(QMailStorePrivate::Key(subKey, nestedAlias)) << ")";
+            } else {
+                q << expression;
+            }
+            break;
+
+        case QMailAccountKey::Custom:
+            // Match on custom field
+            {
+                QString nestedAlias(incrementAlias(alias));
+
+                // Is this an existence test or a value test?
+                if ((a.op == QMailKey::Present) || (a.op == QMailKey::Absent)) {
+                    q << qualifiedName("id", alias) << operatorString(a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias);
+                    q << " FROM mailaccountcustom " << nestedAlias << " WHERE name=? )";
+                } else {
+                    q << qualifiedName("id", alias) << " IN ( SELECT " << qualifiedName("id", nestedAlias); q << " FROM mailaccountcustom " << nestedAlias;
+                    q << " WHERE " << qualifiedName("name", nestedAlias) << "=? AND " << qualifiedName("value", nestedAlias) << operatorString(a.op, false) << "? )";
+                }
+            }
+            break;
+
+        case QMailAccountKey::Status:
+        case QMailAccountKey::MessageType:
+        case QMailAccountKey::Name:
+        case QMailAccountKey::FromAddress:
+
+            q << expression;
+            break;
+        }
+    }
+    return item;
+}
+
+template<>
+QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &key, const QMailMessageKey::ArgumentType &a, const QString &alias, const QMailStorePrivate &store)
+{
+    QString item;
+    {
+        QTextStream q(&item);
+
+        QString columnName = fieldName(a.property, alias);
+
+        bool bitwise((a.property == QMailMessageKey::Type) || (a.property == QMailMessageKey::Status));
+        bool patternMatching((a.property == QMailMessageKey::Sender) || (a.property == QMailMessageKey::Recipients) ||
+                             (a.property == QMailMessageKey::ContentScheme) || (a.property == QMailMessageKey::ContentIdentifier));
+
+        QString expression = columnExpression(columnName, a.op, a.valueList, patternMatching, bitwise);
+        
+        switch(a.property)
+        {
+        case QMailMessageKey::Id:
+            if (a.valueList.count() >= IdLookupThreshold) {
+                q << baseExpression(columnName, a.op, true) << "( SELECT id FROM " << QMailStorePrivate::temporaryTableName(key) << ")";
+            } else {
+                if (a.valueList.first().canConvert<QMailMessageKey>()) {
+                    QMailMessageKey subKey = a.valueList.first().value<QMailMessageKey>();
+                    QString nestedAlias(incrementAlias(alias));
+
+                    // Expand comparison to sub-query result
+                    q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailmessages " << nestedAlias;
+                    q << store.buildWhereClause(QMailStorePrivate::Key(subKey, nestedAlias)) << ")";
+                } else {
+                    q << expression;
+                }
+            }
+            break;
+
+        case QMailMessageKey::ParentFolderId:
+        case QMailMessageKey::PreviousParentFolderId:
+            if(a.valueList.first().canConvert<QMailFolderKey>()) {
+                QMailFolderKey parentFolderKey = a.valueList.first().value<QMailFolderKey>();
+                QString nestedAlias(incrementAlias(alias));
+
+                q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailfolders " << nestedAlias;
+                q << store.buildWhereClause(QMailStorePrivate::Key(parentFolderKey, nestedAlias)) << ")";
+            } else {
+                q << expression;
+            }
+            break;
+
+        case QMailMessageKey::AncestorFolderIds:
+            if (a.valueList.first().canConvert<QMailFolderKey>()) {
+                QMailFolderKey folderSubKey = a.valueList.first().value<QMailFolderKey>();
+                QString nestedAlias(incrementAlias(alias));
+
+                q << baseExpression(fieldName(QMailMessageKey::ParentFolderId, alias), a.op, true);
+                q << "( SELECT DISTINCT descendantid FROM mailfolderlinks WHERE id IN ( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailfolders" << nestedAlias;
+                q << store.buildWhereClause(QMailStorePrivate::Key(folderSubKey, nestedAlias)) << ") )";
+            } else {
+                q << baseExpression(fieldName(QMailMessageKey::ParentFolderId, alias), a.op, true) << "( SELECT DISTINCT descendantid FROM mailfolderlinks WHERE id";
+                if (a.valueList.count() > 1) {
+                    q << " IN " << QMailStorePrivate::expandValueList(a.valueList) << ")";
+                } else {
+                    q << "=? )";
+                }
+            }
+            break;
+
+        case QMailMessageKey::ParentAccountId:
+            if(a.valueList.first().canConvert<QMailAccountKey>()) {
+                QMailAccountKey parentAccountKey = a.valueList.first().value<QMailAccountKey>();
+                QString nestedAlias(incrementAlias(alias));
+
+                q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailaccounts " << nestedAlias;
+                q << store.buildWhereClause(QMailStorePrivate::Key(parentAccountKey, nestedAlias)) << ")";
+            } else {
+                q << expression;
+            }
+            break;
+
+        case QMailMessageKey::Custom:
+            // Match on custom field
+            {
+                QString nestedAlias(incrementAlias(alias));
+
+                // Is this an existence test or a value test?
+                if ((a.op == QMailKey::Present) || (a.op == QMailKey::Absent)) {
+                    q << qualifiedName("id", alias) << operatorString(a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias);
+                    q << " FROM mailmessagecustom " << nestedAlias << " WHERE name=? )";
+                } else {
+                    q << qualifiedName("id", alias) << " IN ( SELECT " << qualifiedName("id", nestedAlias); q << " FROM mailmessagecustom " << nestedAlias;
+                    q << " WHERE " << qualifiedName("name", nestedAlias) << "=? AND " << qualifiedName("value", nestedAlias) << operatorString(a.op, false) << "? )";
+                }
+            }
+            break;
+
+        case QMailMessageKey::InResponseTo:
+            if (a.valueList.first().canConvert<QMailMessageKey>()) {
+                QMailMessageKey messageKey = a.valueList.first().value<QMailMessageKey>();
+                QString nestedAlias(incrementAlias(alias));
+
+                q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailmessages " << nestedAlias;
+                q << store.buildWhereClause(QMailStorePrivate::Key(messageKey, nestedAlias)) << ")";
+            } else {
+                q << expression;
+            }
+            break;
+
+        case QMailMessageKey::Type:
+        case QMailMessageKey::Status:
+        case QMailMessageKey::Sender:
+        case QMailMessageKey::Recipients:
+        case QMailMessageKey::Subject:
+        case QMailMessageKey::TimeStamp:
+        case QMailMessageKey::ReceptionTimeStamp:
+        case QMailMessageKey::ServerUid:
+        case QMailMessageKey::Size:
+        case QMailMessageKey::ContentType:
+        case QMailMessageKey::ContentScheme:
+        case QMailMessageKey::ContentIdentifier:
+        case QMailMessageKey::ResponseType:
+            q << expression;
+            break;     
+
+        case QMailMessageKey::Conversation:
+            // TODO: Not yet implemented
+            break;
+        }
+    }
+    return item;
+}
+
+template<>
+QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &, const QMailFolderKey::ArgumentType &a, const QString &alias, const QMailStorePrivate &store)
+{
+    QString item;
+    {
+        QTextStream q(&item);
+
+        QString columnName(fieldName(a.property, alias));
+
+        bool bitwise(a.property == QMailFolderKey::Status);
+        QString expression = columnExpression(columnName, a.op, a.valueList, false, bitwise);
+        
+        switch (a.property)
+        {
+        case QMailFolderKey::Id:
+            if (a.valueList.first().canConvert<QMailFolderKey>()) {
+                QMailFolderKey subKey = a.valueList.first().value<QMailFolderKey>();
+                QString nestedAlias(incrementAlias(alias));
+
+                // Expand comparison to sub-query result
+                q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailfolders " << nestedAlias;
+                q << store.buildWhereClause(QMailStorePrivate::Key(subKey, nestedAlias)) << ")";
+            } else {
+                q << expression;
+            }
+            break;
+
+        case QMailFolderKey::ParentFolderId:
+            if(a.valueList.first().canConvert<QMailFolderKey>()) {
+                QMailFolderKey folderSubKey = a.valueList.first().value<QMailFolderKey>();
+                QString nestedAlias(incrementAlias(alias));
+
+                q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailfolders " << nestedAlias;
+                q << store.buildWhereClause(QMailStorePrivate::Key(folderSubKey, nestedAlias)) << ")";
+            } else {
+                q << expression;
+            }
+            break;
+
+        case QMailFolderKey::AncestorFolderIds:
+            if (a.valueList.first().canConvert<QMailFolderKey>()) {
+                QMailFolderKey folderSubKey = a.valueList.first().value<QMailFolderKey>();
+                QString nestedAlias(incrementAlias(alias));
+
+                q << baseExpression(fieldName(QMailFolderKey::Id, alias), a.op, true);
+                q << "( SELECT DISTINCT descendantid FROM mailfolderlinks WHERE id IN ( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailfolders" << nestedAlias;
+                q << store.buildWhereClause(QMailStorePrivate::Key(folderSubKey, nestedAlias)) << ") )";
+            } else {
+                q << baseExpression(fieldName(QMailFolderKey::Id, alias), a.op, true) << "( SELECT DISTINCT descendantid FROM mailfolderlinks WHERE id";
+                if (a.valueList.count() > 1) {
+                    q << " IN " << QMailStorePrivate::expandValueList(a.valueList) << ")";
+                } else {
+                    q << "=? )";
+                }
+            }
+            break;
+
+        case QMailFolderKey::ParentAccountId:
+            if(a.valueList.first().canConvert<QMailAccountKey>()) {
+                QMailAccountKey accountSubKey = a.valueList.first().value<QMailAccountKey>();
+                QString nestedAlias(incrementAlias(alias));
+
+                q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailaccounts " << nestedAlias;
+                q << store.buildWhereClause(QMailStorePrivate::Key(accountSubKey, nestedAlias)) << ")";
+            } else {
+                q << expression;
+            }
+            break;
+
+        case QMailFolderKey::Custom:
+            // Match on custom field
+            {
+                QString nestedAlias(incrementAlias(alias));
+
+                // Is this an existence test or a value test?
+                if ((a.op == QMailKey::Present) || (a.op == QMailKey::Absent)) {
+                    q << qualifiedName("id", alias) << operatorString(a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias);
+                    q << " FROM mailfoldercustom " << nestedAlias << " WHERE name=? )";
+                } else {
+                    q << qualifiedName("id", alias) << " IN ( SELECT " << qualifiedName("id", nestedAlias); q << " FROM mailfoldercustom " << nestedAlias;
+                    q << " WHERE " << qualifiedName("name", nestedAlias) << "=? AND " << qualifiedName("value", nestedAlias) << operatorString(a.op, false) << "? )";
+                }
+            }
+            break;
+
+        case QMailFolderKey::Status:
+        case QMailFolderKey::Path:
+        case QMailFolderKey::DisplayName:
+        case QMailFolderKey::ServerCount:
+        case QMailFolderKey::ServerUnreadCount:
+
+            q << expression;
+            break;
+        }
+    }
+    return item;
+}
+
+template<typename KeyType, typename ArgumentListType, typename KeyListType, typename CombineType>
+QString buildWhereClause(const KeyType &key, 
+                         const ArgumentListType &args, 
+                         const KeyListType &subKeys, 
+                         CombineType combine, 
+                         bool negated, 
+                         bool nested,
+                         bool firstClause,
+                         const QString &alias, 
+                         const QMailStorePrivate& store)
+{
+    QString whereClause;
+    QString logicalOpString(combineOperatorString(combine));
+
+    if (!key.isEmpty()) {
+        QTextStream s(&whereClause);
+
+        QString op = " ";
+        foreach (typename ArgumentListType::const_reference a, args) {
+            s << op << whereClauseItem(key, a, alias, store);
+            op = logicalOpString;
+        }
+
+        // subkeys
+        s.flush();
+        if (whereClause.isEmpty())
+            op = " ";
+
+        foreach (typename KeyListType::const_reference subkey, subKeys) {
+            QString nestedWhere(store.buildWhereClause(QMailStorePrivate::Key(subkey, alias), true));
+            if (!nestedWhere.isEmpty()) 
+                s << op << " (" << nestedWhere << ") ";
+
+            op = logicalOpString;
+        }       
+    }       
+
+    // Finalise the where clause
+    if (!whereClause.isEmpty()) {
+        if (negated) {
+            whereClause = " NOT (" + whereClause + ")";
+        }
+        if (!nested) {
+            whereClause.prepend(firstClause ? " WHERE " : " AND ");
+        }
+    }
+
+    return whereClause;
+}
+
+QPair<QString, qint64> tableInfo(const QString &name, qint64 version)
+{
+    return qMakePair(name, version);
+}
+
+QPair<quint64, QString> folderInfo(QMailFolder::StandardFolder id, const QString &name)
+{
+    return qMakePair(static_cast<quint64>(id), name);
+}
+
+/* SPARQL CODE */
+QString nmoRecipients(const QList<QMailAddress>& recipients)
+{
+    QString result;
+    foreach (const QMailAddress& address, recipients)
+    {
+        QString triplet(QString(
+    "        nmo:recipient [\n"
+    "            rdf:type nco:Contact ;\n"
+    "            nco:fullname \"%1\" ; \n"
+    "            nco:hasEmailAddress <mailto:%2> ] ;\n")
+                .arg(address.name())
+                .arg(address.address()));
+        result.append(triplet);
+    }
+    return result;
+}
+
+template <class T>
+T IdFromUri(const QString& uri)
+{
+    int pos = uri.indexOf('#');
+    if (pos >= 0)
+    {
+        bool ok = false;
+        quint64 postfix = uri.right(uri.length() - pos-1).toULongLong(&ok);
+
+        if (ok)
+            return T(postfix);
+    }
+
+    return T();
+}
+
+QString comparator(QMailKey::Comparator comparator)
+{
+    static QMap<QMailKey::Comparator, QString> comparatorMap;
+    comparatorMap.insert(QMailKey::LessThan, "<");
+    comparatorMap.insert(QMailKey::LessThanEqual, "<-");
+    comparatorMap.insert(QMailKey::GreaterThan, ">");
+    comparatorMap.insert(QMailKey::GreaterThanEqual, ">=");
+    comparatorMap.insert(QMailKey::Equal, "=");
+    comparatorMap.insert(QMailKey::NotEqual, "!=");
+    comparatorMap.insert(QMailKey::Includes, "IN");
+    comparatorMap.insert(QMailKey::Excludes, "NOT IN");
+    comparatorMap.insert(QMailKey::Present, "EXISTS");
+    comparatorMap.insert(QMailKey::Absent, "NOT EXISTS");
+
+    return comparatorMap.value(comparator);
+}
+
+QString messageConstraint(const QString& variable, const QMailMessageKey& key)
+{
+    QString constraint;
+    foreach (QMailMessageKey::ArgumentType argument, key.arguments())
+    {
+        switch (argument.property)
+        {
+            case QMailMessageKey::Id:
+                // Nothing to select
+            break;
+            case QMailMessageKey::Type:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::ParentFolderId:
+                constraint += QString(variable + " nie:isLogicalPartOf <qmf://groove.nokia.com/folder#%1> . \n").arg(argument.valueList.first().value<QMailFolderId>().toULongLong());
+            break;
+            case QMailMessageKey::Sender:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::Recipients:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::Subject:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::TimeStamp:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::Status:
+                constraint += QString(variable + " nmo:status \"%1\" . \n").arg(argument.valueList.first().toULongLong());
+            break;
+            case QMailMessageKey::Conversation:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::ReceptionTimeStamp:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::ServerUid:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::Size:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::ParentAccountId:
+                constraint += QString(variable + " nie:relatedTo <qmf://groove.nokia.com/accounts#%1> . \n").arg(argument.valueList.first().value<QMailAccountId>().toULongLong());
+            break;
+            case QMailMessageKey::AncestorFolderIds:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::ContentType:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::PreviousParentFolderId:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::ContentScheme:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::ContentIdentifier:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::InResponseTo:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::ResponseType:
+                Q_ASSERT(false);
+            break;
+            case QMailMessageKey::Custom:
+                Q_ASSERT(false);
+            break;
+
+            default:
+                Q_ASSERT(false);
+        }
+    }
+    return "    " + constraint;
+}
+
+QString folderConstraint(const QString& variable, const QMailFolderKey& key)
+{
+    QString constraint;
+    foreach (QMailFolderKey::ArgumentType argument, key.arguments())
+    {
+        switch (argument.property)
+        {
+            case QMailFolderKey::Id:
+                // Nothing to select
+            break;
+            case QMailFolderKey::Path:
+                constraint += QString(variable + " nmo:folderName \"%1\" . \n").arg(argument.valueList.first().toString());
+            break;
+            case QMailFolderKey::ParentFolderId:
+                constraint += QString(variable + " nie:isLogicalPartOf <qmf://groove.nokia.com/folder#%1> . \n").arg(argument.valueList.first().value<QMailFolderId>().toULongLong());
+            break;
+            case QMailFolderKey::ParentAccountId:
+                constraint += QString(variable + " nie:relatedTo <qmf://groove.nokia.com/accounts#%1> . \n").arg(argument.valueList.first().value<QMailAccountId>().toULongLong());
+            break;
+            case QMailFolderKey::DisplayName:
+                constraint += QString(variable + " nmo:folderDisplayName \"%1\" . \n").arg(argument.valueList.first().toULongLong());
+            break;
+            case QMailFolderKey::Status:
+                constraint += QString(variable + " nmo:status : \"%1\" . \n").arg(argument.valueList.first().toULongLong());
+            break;
+            case QMailFolderKey::AncestorFolderIds:
+                Q_ASSERT(false);
+            break;
+            case QMailFolderKey::ServerCount:
+                constraint += QString(variable + " nmo:serverCount \"%1\" . \n").arg(argument.valueList.first().toULongLong());
+            break;
+            case QMailFolderKey::ServerUnreadCount:
+                constraint += QString(variable + " nmo:serverUnreadCount \"%1\" . \n").arg(argument.valueList.first().toULongLong());
+            break;
+            case QMailFolderKey::Custom:
+                Q_ASSERT(false);
+            break;
+            default:
+                Q_ASSERT(false);
+        }
+    }
+    return "    " + constraint;
+}
+
+QString accountConstraint(const QString& variable, const QMailAccountKey& key)
+{
+    QString constraint;
+    foreach (QMailAccountKey::ArgumentType argument, key.arguments())
+    {
+        switch (argument.property)
+        {
+            case QMailAccountKey::Id:
+                // Nothing to select
+            break;
+            case QMailAccountKey::Name:
+                constraint += QString(variable + " nmo:accountName \"%1\" . \n").arg(argument.valueList.first().toString());
+            break;
+            case QMailAccountKey::MessageType:
+                constraint += QString(variable + " nmo:fromAddress [ nco:emailAddress \"%1\" ] . \n").arg(argument.valueList.first().toString());
+            break;
+            case QMailAccountKey::FromAddress:
+                Q_ASSERT(false);
+            break;
+            case QMailAccountKey::Status:
+                constraint += QString(variable + " nmo:status \"%1\"^^xsd:integer . \n").arg(argument.valueList.first().toULongLong());
+            break;
+            case QMailAccountKey::Custom:
+                Q_ASSERT(false);
+            break;
+            default:
+                Q_ASSERT(false);
+        }
+    }
+    return "    " + constraint;
+}
+
+
+} // namespace
+
+
+// We need to support recursive locking, per-process
+static volatile int mutexLockCount = 0;
+static volatile int readLockCount = 0;
+
+class QMailStorePrivate::Transaction
+{
+    QMailStorePrivate *m_d;
+    bool m_initted;
+    bool m_committed;
+
+public:
+    Transaction(QMailStorePrivate *);
+    ~Transaction();
+
+    bool commit();
+
+    bool committed() const;
+};
+
+QMailStorePrivate::Transaction::Transaction(QMailStorePrivate* d)
+    : m_d(d), 
+      m_initted(false),
+      m_committed(false)
+{
+    if (mutexLockCount > 0) {
+        // Increase lock recursion depth
+        ++mutexLockCount;
+        m_initted = true;
+    } else {
+        // This process does not yet have a mutex lock
+        if (m_d->databaseMutex().lock(10000)) {
+            // Wait for any readers to complete
+            if (m_d->databaseReadLock().wait(10000)) {
+                if (m_d->transaction()) {
+                    ++mutexLockCount;
+                    m_initted = true;
+                }
+            } else {
+                qWarning() << "Unable to wait for database read lock to reach zero!";
+            }
+
+            if (!m_initted) {
+                m_d->databaseMutex().unlock();
+            }
+        } else {
+            qWarning() << "Unable to lock database mutex for transaction!";
+        }
+    }
+}
+
+QMailStorePrivate::Transaction::~Transaction()
+{
+    if (m_initted && !m_committed) {
+        m_d->rollback();
+
+        --mutexLockCount;
+        if (mutexLockCount == 0)
+            m_d->databaseMutex().unlock();
+    }
+}
+
+bool QMailStorePrivate::Transaction::commit()
+{
+    if (m_initted && !m_committed) {
+        if ((m_committed = m_d->commit())) {
+            --mutexLockCount;
+            if (mutexLockCount == 0)
+                m_d->databaseMutex().unlock();
+        }
+    }
+
+    return m_committed;
+}
+
+bool QMailStorePrivate::Transaction::committed() const
+{
+    return m_committed;
+}
+
+
+class QMailStorePrivate::ReadLock
+{
+    QMailStorePrivate *m_d;
+    bool m_locked;
+
+public:
+    ReadLock(QMailStorePrivate *);
+    ~ReadLock();
+};
+
+QMailStorePrivate::ReadLock::ReadLock(QMailStorePrivate* d)
+    : m_d(d),
+      m_locked(false)
+{
+    if (readLockCount > 0) {
+        // Increase lock recursion depth
+        ++readLockCount;
+        m_locked = true;
+    } else {
+        // This process does not yet have a read lock
+        // Lock the mutex to ensure no writers are active or waiting (unless we have already locked it)
+        if ((mutexLockCount > 0) || m_d->databaseMutex().lock(10000)) {
+            m_d->databaseReadLock().lock();
+            ++readLockCount;
+            m_locked = true;
+
+            if (mutexLockCount == 0)
+                m_d->databaseMutex().unlock();
+        } else {
+            qWarning() << "Unable to lock database mutex for read lock!";
+        }
+    }
+}
+
+QMailStorePrivate::ReadLock::~ReadLock()
+{
+    if (m_locked) {
+        --readLockCount;
+        if (readLockCount == 0)
+            m_d->databaseReadLock().unlock();
+    }
+}
+
+
+template<typename FunctionType>
+QMailStorePrivate::AttemptResult evaluate(QMailStorePrivate::WriteAccess, FunctionType func, const QString& description, QMailStorePrivate* d)
+{
+    QMailStorePrivate::Transaction t(d);
+
+    QMailStorePrivate::AttemptResult result = func(t);
+
+    // Ensure that the transaction was committed
+    if ((result == QMailStorePrivate::Success) && !t.committed()) {
+        qMailLog(Messaging) << ::getpid() << "Failed to commit successful" << qPrintable(description) << "!";
+    }
+
+    return result;
+}
+
+template<typename FunctionType>
+QMailStorePrivate::AttemptResult evaluate(QMailStorePrivate::ReadAccess, FunctionType func, const QString&, QMailStorePrivate* d)
+{
+    QMailStorePrivate::ReadLock l(d);
+
+    return func(l);
+}
+
+
+QMailStore::ErrorCode errorType(QMailStorePrivate::ReadAccess)
+{
+    return QMailStore::InvalidId;
+}
+
+QMailStore::ErrorCode errorType(QMailStorePrivate::WriteAccess)
+{
+    return QMailStore::ConstraintFailure;
+}
+
+
+const QMailMessageKey::Properties &QMailStorePrivate::updatableMessageProperties()
+{
+    static QMailMessageKey::Properties p = QMailMessageKey::ParentFolderId |
+                                           QMailMessageKey::Type |
+                                           QMailMessageKey::Sender |
+                                           QMailMessageKey::Recipients |
+                                           QMailMessageKey::Subject |
+                                           QMailMessageKey::TimeStamp |
+                                           QMailMessageKey::ReceptionTimeStamp |
+                                           QMailMessageKey::Status |
+                                           QMailMessageKey::ParentAccountId |
+                                           QMailMessageKey::ServerUid |
+                                           QMailMessageKey::Size |
+                                           QMailMessageKey::ContentType |
+                                           QMailMessageKey::PreviousParentFolderId |
+                                           QMailMessageKey::ContentScheme |
+                                           QMailMessageKey::ContentIdentifier |
+                                           QMailMessageKey::InResponseTo |
+                                           QMailMessageKey::ResponseType;
+    return p;
+}
+
+const QMailMessageKey::Properties &QMailStorePrivate::allMessageProperties()
+{
+    static QMailMessageKey::Properties p = QMailMessageKey::Id | updatableMessageProperties();
+    return p;
+}
+
+const QMailStorePrivate::MessagePropertyMap& QMailStorePrivate::messagePropertyMap() 
+{
+    static const MessagePropertyMap map(::messagePropertyMap());
+    return map;
+}
+
+const QMailStorePrivate::MessagePropertyList& QMailStorePrivate::messagePropertyList() 
+{
+    static const MessagePropertyList list(messagePropertyMap().keys());
+    return list;
+}
+
+const QString &QMailStorePrivate::defaultContentScheme() 
+{
+    static QString scheme(QMailContentManagerFactory::defaultScheme());
+    return scheme;
+}
+
+int QMailStorePrivate::pathIdentifier(const QString &filePath)
+{
+    return static_cast<int>(::ftok(filePath.toAscii(), 1));
+}
+
+int QMailStorePrivate::databaseIdentifier(int n) const
+{
+    int result = static_cast<int>(::ftok(database.databaseName().toAscii(), n));
+    if (result == -1)
+        qFatal("Could not create database semaphore. Database could not be found.");
+    return result;
+}
+
+
+ProcessMutex* QMailStorePrivate::contentMutex = 0;
+
+QMailStorePrivate::QMailStorePrivate(QMailStore* parent)
+    : QMailStoreImplementation(parent),
+      headerCache(headerCacheSize),
+      folderCache(folderCacheSize),
+      accountCache(accountCacheSize),
+      inTransaction(false),
+      lastQueryError(0),
+      mutex(0)
+{
+    qDebug() << "QMailStorePrivate::QMailStorePrivate";
+    ProcessMutex creationMutex(pathIdentifier(QDir::rootPath()));
+    MutexGuard guard(creationMutex);
+    if (guard.lock(1000)) {
+        //open the database
+        database = QMail::createDatabase();
+    }
+    mutex = new ProcessMutex(databaseIdentifier(1));
+    readLock = new ProcessReadLock(databaseIdentifier(2));
+    if (contentMutex == 0) {
+        contentMutex = new ProcessMutex(databaseIdentifier(3));
+    }
+}
+
+QMailStorePrivate::~QMailStorePrivate()
+{
+    delete mutex;
+    delete readLock;
+}
+
+ProcessMutex& QMailStorePrivate::databaseMutex(void) const
+{
+    return *mutex;
+}
+
+ProcessReadLock& QMailStorePrivate::databaseReadLock(void) const
+{
+    return *readLock;
+}
+
+ProcessMutex& QMailStorePrivate::contentManagerMutex(void)
+{
+    return *contentMutex;
+}
+
+bool QMailStorePrivate::initStore()
+{
+    ProcessMutex creationMutex(pathIdentifier(QDir::rootPath()));
+    MutexGuard guard(creationMutex);
+    if (!guard.lock(1000)) {
+        return init;
+    }
+
+    if (database.isOpenError()) {
+        qMailLog(Messaging) << "Unable to open database in initStore!";
+        return false;
+    }
+
+    {
+        Transaction t(this);
+
+        if (!ensureVersionInfo() ||
+            !setupTables(QList<TableInfo>() << tableInfo("mailaccounts", 106)
+                                            << tableInfo("mailaccountcustom", 100)
+                                            << tableInfo("mailaccountconfig", 100)
+                                            << tableInfo("mailaccountfolders", 100)
+                                            << tableInfo("mailfolders", 102)
+                                            << tableInfo("mailfoldercustom", 100)
+                                            << tableInfo("mailfolderlinks", 100)
+                                            << tableInfo("mailmessages", 105)
+                                            << tableInfo("mailmessagecustom", 100)
+                                            << tableInfo("mailstatusflags", 101)
+                                            << tableInfo("deletedmessages", 101)) ||
+            !setupFolders(QList<FolderInfo>() << folderInfo(QMailFolder::InboxFolder, tr("Inbox"))
+                                              << folderInfo(QMailFolder::OutboxFolder, tr("Outbox"))
+                                              << folderInfo(QMailFolder::DraftsFolder, tr("Drafts"))
+                                              << folderInfo(QMailFolder::SentFolder, tr("Sent"))
+                                              << folderInfo(QMailFolder::TrashFolder, tr("Trash")))) {
+            return false;
+        }
+
+        if (!t.commit()) {
+            qMailLog(Messaging) << "Could not commit setup operation to database";
+            return false;
+        }
+
+        QMailAccount::initStore();
+        QMailFolder::initStore();
+        QMailMessage::initStore();
+    }
+
+#if defined(Q_USE_SQLITE)
+    // default sqlite cache_size of 2000*1.5KB is too large, as we only want
+    // to cache 100 metadata records 
+    QSqlQuery query( database );
+    query.exec(QLatin1String("PRAGMA cache_size=50"));
+#endif
+
+    if (!QMailContentManagerFactory::init()) {
+        qMailLog(Messaging) << "Could not initialize content manager factory";
+        return false;
+    }
+
+    // We are now correctly initialized
+    init = true;
+    return true;
+}
+
+void QMailStorePrivate::clearContent()
+{
+    // Clear all caches
+    accountCache.clear();
+    folderCache.clear();
+    headerCache.clear();
+
+    // Drop all data
+    foreach (const QString &table, database.tables()) {
+        if (table != "versioninfo") {
+            QString sql("DELETE FROM %1");
+            QSqlQuery query(database);
+            if (!query.exec(sql.arg(table))) {
+                qMailLog(Messaging) << "Failed to delete from table - query:" << sql << "- error:" << query.lastError().text();
+            }
+        }
+    }
+    
+    // Remove all content
+    QMailContentManagerFactory::clearContent();
+}
+
+bool QMailStorePrivate::transaction(void)
+{
+    if (inTransaction) {
+        qMailLog(Messaging) << "(" << ::getpid() << ")" << "Transaction already exists at begin!";
+        qWarning() << "Transaction already exists at begin!";
+    }
+
+    clearQueryError();
+
+    // Ensure any outstanding temp tables are removed before we begin this transaction
+    destroyTemporaryTables();
+
+    if (!database.transaction()) {
+        setQueryError(database.lastError(), "Failed to initiate transaction");
+        return false;
+    }
+
+    inTransaction = true;
+    return true;
+}
+
+static QString queryText(const QString &query, const QList<QVariant> &values)
+{
+    static const QChar marker('?');
+    static const QChar quote('\'');
+
+    QString result(query);
+
+    QList<QVariant>::const_iterator it = values.begin(), end = values.end();
+    int index = result.indexOf(marker);
+    while ((index != -1) && (it != end)) {
+        QString substitute((*it).toString());
+        if ((*it).type() == QVariant::String)
+            substitute.prepend(quote).append(quote);
+
+        result.replace(index, 1, substitute);
+
+        ++it;
+        index = result.indexOf(marker, index + substitute.length());
+    }
+
+    return result;
+}
+
+static QString queryText(const QSqlQuery &query)
+{
+    // Note: we currently only handle positional parameters
+    return queryText(query.lastQuery().simplified(), query.boundValues().values());
+}
+
+QSqlQuery QMailStorePrivate::prepare(const QString& sql)
+{
+    if (!inTransaction) {
+        // Ensure any outstanding temp tables are removed before we begin this query
+        destroyTemporaryTables();
+    }
+
+    clearQueryError();
+
+    QSqlQuery query(database);
+    
+    // Create any temporary tables needed for this query
+    while (!requiredTableKeys.isEmpty()) {
+        const QMailMessageKey *key = requiredTableKeys.takeFirst();
+        if (!temporaryTableKeys.contains(key)) {
+            QString tableName = temporaryTableName(*key);
+
+            bool ok = true;
+            QSqlQuery tableQuery(database);
+            if (!tableQuery.exec(QString("CREATE TEMP TABLE %1 ( id INTEGER PRIMARY KEY )").arg(tableName))) { 
+                ok = false;
+            } else {
+                temporaryTableKeys.append(key);
+
+                // Add the ID values to the temp table
+                foreach (const QVariant &var, key->arguments().first().valueList) {
+                    quint64 id = 0;
+
+                    if (qVariantCanConvert<QMailMessageId>(var)) {
+                        id = var.value<QMailMessageId>().toULongLong(); 
+                    } else if (qVariantCanConvert<QMailFolderId>(var)) {
+                        id = var.value<QMailFolderId>().toULongLong(); 
+                    } else if (qVariantCanConvert<QMailAccountId>(var)) {
+                        id = var.value<QMailAccountId>().toULongLong(); 
+                    }
+
+                    if (id != 0) {
+                        tableQuery = QSqlQuery(database);
+                        if (!tableQuery.exec(QString("INSERT INTO %1 VALUES (%2)").arg(tableName).arg(id))) { 
+                            ok = false;
+                            break;
+                        }
+                    } else {
+                        qMailLog(Messaging) << "Unable to extract ID value from valuelist!";
+                        ok = false;
+                        break;
+                    }
+                }
+            }
+            
+            if (!ok) {
+                setQueryError(tableQuery.lastError(), "Failed to create temporary table", queryText(tableQuery));
+                qMailLog(Messaging) << "Unable to prepare query:" << sql;
+                return query;
+            }
+        }
+    }
+
+    if (!query.prepare(sql)) {
+        setQueryError(query.lastError(), "Failed to prepare query", queryText(query));
+    }
+
+    // TODO: setForwardOnly?
+    return query;
+}
+
+bool QMailStorePrivate::execute(QSqlQuery& query, bool batch)
+{
+    bool success = (batch ? query.execBatch() : query.exec());
+    if (!success) {
+        setQueryError(query.lastError(), "Failed to execute query", queryText(query));
+        return false;
+    }
+
+#ifdef QMAILSTORE_LOG_SQL 
+    qMailLog(Messaging) << "(" << ::getpid() << ")" << qPrintable(queryText(query));
+#endif
+
+    if (!inTransaction) {
+        // We should be finished with these temporary tables
+        expiredTableKeys = temporaryTableKeys;
+        temporaryTableKeys.clear();
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::commit(void)
+{
+    if (!inTransaction) {
+        qMailLog(Messaging) << "(" << ::getpid() << ")" << "Transaction does not exist at commit!";
+        qWarning() << "Transaction does not exist at commit!";
+    }
+    
+    if (!database.commit()) {
+        setQueryError(database.lastError(), "Failed to commit transaction");
+        return false;
+    } else {
+        inTransaction = false;
+
+        // Expire any temporary tables we were using
+        expiredTableKeys = temporaryTableKeys;
+        temporaryTableKeys.clear();
+    }
+
+    return true;
+}
+
+void QMailStorePrivate::rollback(void)
+{
+    if (!inTransaction) {
+        qMailLog(Messaging) << "(" << ::getpid() << ")" << "Transaction does not exist at rollback!";
+        qWarning() << "Transaction does not exist at rollback!";
+    }
+    
+    inTransaction = false;
+
+    if (!database.rollback()) {
+        setQueryError(database.lastError(), "Failed to rollback transaction");
+    }
+}
+
+int QMailStorePrivate::queryError() const
+{
+    return lastQueryError;
+}
+
+void QMailStorePrivate::setQueryError(const QSqlError &error, const QString &description, const QString &statement)
+{
+    QString s;
+    QTextStream ts(&s);
+
+    lastQueryError = error.number();
+
+    ts << qPrintable(description) << "; error:\"" << error.text() << '"';
+    if (!statement.isEmpty())
+        ts << "; statement:\"" << statement.simplified() << '"';
+
+    qMailLog(Messaging) << "(" << ::getpid() << ")" << qPrintable(s);
+    qWarning() << qPrintable(s);
+}
+
+void QMailStorePrivate::clearQueryError(void) 
+{
+    lastQueryError = 0;
+}
+
+template<bool PtrSizeExceedsLongSize>
+QString numericPtrValue(const void *ptr)
+{
+    return QString::number(reinterpret_cast<unsigned long long>(ptr), 16).rightJustified(16, '0');
+}
+
+template<>
+QString numericPtrValue<false>(const void *ptr)
+{
+    return QString::number(reinterpret_cast<unsigned long>(ptr), 16).rightJustified(8, '0');;
+}
+
+QString QMailStorePrivate::temporaryTableName(const QMailMessageKey& key)
+{
+    const QMailMessageKey *ptr = &key;
+    return QString("qtopiamail_idmatch_%1").arg(numericPtrValue<(sizeof(void*) > sizeof(unsigned long))>(ptr));
+}
+
+void QMailStorePrivate::createTemporaryTable(const QMailMessageKey& key) const
+{
+    requiredTableKeys.append(&key);
+}
+
+void QMailStorePrivate::destroyTemporaryTables()
+{
+    while (!expiredTableKeys.isEmpty()) {
+        const QMailMessageKey *key = expiredTableKeys.takeFirst();
+        QString tableName = temporaryTableName(*key);
+
+        QSqlQuery query(database);
+        if (!query.exec(QString("DROP TABLE %1").arg(tableName))) {
+            QString sql = queryText(query);
+            QString err = query.lastError().text();
+
+            qMailLog(Messaging) << "(" << ::getpid() << ")" << "Failed to drop temporary table - query:" << qPrintable(sql) << "; error:" << qPrintable(err);
+            qWarning() << "Failed to drop temporary table - query:" << qPrintable(sql) << "; error:" << qPrintable(err);
+        }
+    }
+}
+
+bool QMailStorePrivate::idValueExists(quint64 id, const QString& table)
+{
+    QSqlQuery query(database);
+    QString sql = "SELECT id FROM " + table + " WHERE id=?";
+    if(!query.prepare(sql)) {
+        setQueryError(query.lastError(), "Failed to prepare idExists query", queryText(query));
+        return false;
+    }
+
+    query.addBindValue(id);
+
+    if(!query.exec()) {
+        setQueryError(query.lastError(), "Failed to execute idExists query", queryText(query));
+        return false;
+    }
+
+    return (query.first());
+}
+
+bool QMailStorePrivate::idExists(const QMailAccountId& id, const QString& table)
+{
+    return idValueExists(id.toULongLong(), (table.isEmpty() ? "mailaccounts" : table));
+}
+
+bool QMailStorePrivate::idExists(const QMailFolderId& id, const QString& table)
+{
+    return idValueExists(id.toULongLong(), (table.isEmpty() ? "mailfolders" : table));
+}
+
+bool QMailStorePrivate::idExists(const QMailMessageId& id, const QString& table)
+{
+    return idValueExists(id.toULongLong(), (table.isEmpty() ? "mailmessages" : table));
+}
+
+QMailAccount QMailStorePrivate::extractAccount(const QSqlRecord& r)
+{
+    const AccountRecord record(r);
+
+    QMailAccount result;
+    result.setId(record.id());
+    result.setName(record.name());
+    result.setMessageType(record.messageType());
+    result.setStatus(record.status());
+    result.setSignature(record.signature());
+    result.setFromAddress(QMailAddress(record.fromAddress()));
+
+    return result;
+}
+
+QMailFolder QMailStorePrivate::extractFolder(const QSqlRecord& r)
+{
+    const FolderRecord record(r);
+
+    QMailFolder result(record.path(), record.parentFolderId(), record.parentAccountId());
+    result.setId(record.id());
+    result.setDisplayName(record.displayName());
+    result.setStatus(record.status());
+    result.setServerCount(record.serverCount());
+    result.setServerUnreadCount(record.serverUnreadCount());
+    return result;
+}
+
+void QMailStorePrivate::extractMessageMetaData(const QSqlRecord& r,
+                                               QMailMessageKey::Properties recordProperties,
+                                               const QMailMessageKey::Properties& properties,
+                                               QMailMessageMetaData* metaData)
+{
+    // Record whether we have loaded all data for this message
+    bool unloadedProperties = (properties != allMessageProperties());
+    if (!unloadedProperties) {
+        // If there is message content, mark the object as not completely loaded
+        if (!r.value("mailfile").toString().isEmpty())
+            unloadedProperties = true;
+    }
+
+    // Use wrapper to extract data items
+    const MessageRecord messageRecord(r, recordProperties);
+
+    foreach (QMailMessageKey::Property p, messagePropertyList()) {
+        switch (properties & p)
+        {
+            case QMailMessageKey::Id:
+                metaData->setId(messageRecord.id());
+                break;
+
+            case QMailMessageKey::Type:
+                metaData->setMessageType(messageRecord.messageType());
+                break;
+
+            case QMailMessageKey::ParentFolderId:
+                metaData->setParentFolderId(messageRecord.parentFolderId());
+                break;
+
+            case QMailMessageKey::Sender:
+                metaData->setFrom(messageRecord.from());
+                break;
+
+            case QMailMessageKey::Recipients:
+                metaData->setTo(messageRecord.to());
+                break;
+
+            case QMailMessageKey::Subject:
+                metaData->setSubject(messageRecord.subject());
+                break;
+
+            case QMailMessageKey::TimeStamp:
+                metaData->setDate(messageRecord.date());
+                break;
+
+            case QMailMessageKey::ReceptionTimeStamp:
+                metaData->setReceivedDate(messageRecord.receivedDate());
+                break;
+
+            case QMailMessageKey::Status:
+                metaData->setStatus(messageRecord.status());
+                break;
+
+            case QMailMessageKey::ParentAccountId:
+                metaData->setParentAccountId(messageRecord.parentAccountId());
+                break;
+
+            case QMailMessageKey::ServerUid:
+                metaData->setServerUid(messageRecord.serverUid());
+                break;
+
+            case QMailMessageKey::Size:
+                metaData->setSize(messageRecord.size());
+                break;
+
+            case QMailMessageKey::ContentType:
+                metaData->setContent(messageRecord.content());
+                break;
+
+            case QMailMessageKey::PreviousParentFolderId:
+                metaData->setPreviousParentFolderId(messageRecord.previousParentFolderId());
+                break;
+
+            case QMailMessageKey::ContentScheme:
+                metaData->setContentScheme(messageRecord.contentScheme());
+                break;
+
+            case QMailMessageKey::ContentIdentifier:
+                metaData->setContentIdentifier(messageRecord.contentIdentifier());
+                break;
+
+            case QMailMessageKey::InResponseTo:
+                metaData->setInResponseTo(messageRecord.inResponseTo());
+                break;
+
+            case QMailMessageKey::ResponseType:
+                metaData->setResponseType(messageRecord.responseType());
+                break;
+        }
+    }
+    
+    if (unloadedProperties) {
+        // This message is not completely loaded
+        metaData->setStatus(QMailMessage::UnloadedData, true);
+    }
+
+    metaData->setUnmodified();
+}
+
+QMailMessageMetaData QMailStorePrivate::extractMessageMetaData(const QSqlRecord& r, QMailMessageKey::Properties recordProperties, const QMailMessageKey::Properties& properties)
+{
+    QMailMessageMetaData metaData;
+
+    extractMessageMetaData(r, recordProperties, properties, &metaData);
+    return metaData;
+}
+
+QMailMessage QMailStorePrivate::extractMessage(const QSqlRecord& r, const QMap<QString, QString> &customFields, const QMailMessageKey::Properties& properties)
+{
+    QMailMessage newMessage;
+
+    // Load the meta data items (note 'SELECT *' does not give the same result as 'SELECT expand(allMessageProperties())')
+    extractMessageMetaData(r, QMailMessageKey::Properties(0), properties, &newMessage);
+    newMessage.setUnmodified();
+
+    newMessage.setCustomFields(customFields);
+    newMessage.setCustomFieldsModified(false);
+
+    QString contentUri(r.value("mailfile").toString());
+    if (!contentUri.isEmpty()) {
+        QPair<QString, QString> elements(::uriElements(contentUri));
+
+        MutexGuard lock(contentManagerMutex());
+        if (!lock.lock(1000)) {
+            qMailLog(Messaging) << "Unable to acquire message body mutex in extractMessage!";
+            return QMailMessage();
+        } 
+
+        QMailContentManager *contentManager = QMailContentManagerFactory::create(elements.first);
+        if (contentManager) {
+            // Load the message content (manager should be able to access the metadata also)
+            QMailStore::ErrorCode code = contentManager->load(elements.second, &newMessage);
+            if (code != QMailStore::NoError) {
+                setLastError(code);
+                qMailLog(Messaging) << "Unable to load message content:" << contentUri;
+                return QMailMessage();
+            }
+        } else {
+            qMailLog(Messaging) << "Unable to create content manager for scheme:" << elements.first;
+            return QMailMessage();
+        }
+
+        // Re-load the meta data items so that they take precedence over the loaded content
+        extractMessageMetaData(r, QMailMessageKey::Properties(0), properties, &newMessage);
+        newMessage.setUnmodified();
+
+        newMessage.setCustomFields(customFields);
+        newMessage.setCustomFieldsModified(false);
+    }
+
+    return newMessage;
+}
+
+QMailMessageRemovalRecord QMailStorePrivate::extractMessageRemovalRecord(const QSqlRecord& r)
+{
+    const MessageRemovalRecord record(r);
+
+    QMailMessageRemovalRecord result(record.parentAccountId(), record.serverUid(), record.parentFolderId());
+    return result;
+}
+
+QString QMailStorePrivate::buildOrderClause(const Key& key) const
+{
+    if (key.isType<QMailMessageSortKey>()) {
+        const QMailMessageSortKey &sortKey(key.key<QMailMessageSortKey>());
+        return ::buildOrderClause(sortKey.arguments(), key.alias());
+    } else if (key.isType<QMailFolderSortKey>()) {
+        const QMailFolderSortKey &sortKey(key.key<QMailFolderSortKey>());
+        return ::buildOrderClause(sortKey.arguments(), key.alias());
+    } else if (key.isType<QMailAccountSortKey>()) {
+        const QMailAccountSortKey &sortKey(key.key<QMailAccountSortKey>());
+        return ::buildOrderClause(sortKey.arguments(), key.alias());
+    } 
+
+    return QString();
+}
+
+QString QMailStorePrivate::buildWhereClause(const Key& key, bool nested, bool firstClause) const
+{
+    if (key.isType<QMailMessageKey>()) {
+        const QMailMessageKey &messageKey(key.key<QMailMessageKey>());
+
+        // See if we need to create any temporary tables to use in this query
+        foreach (const QMailMessageKey::ArgumentType &a, messageKey.arguments()) {
+            if (a.property == QMailMessageKey::Id && a.valueList.count() >= IdLookupThreshold) {
+                createTemporaryTable(messageKey);
+            }
+        }
+
+        return ::buildWhereClause(messageKey, messageKey.arguments(), messageKey.subKeys(), messageKey.combiner(), messageKey.isNegated(), nested, firstClause, key.alias(), *this);
+    } else if (key.isType<QMailFolderKey>()) {
+        const QMailFolderKey &folderKey(key.key<QMailFolderKey>());
+        return ::buildWhereClause(folderKey, folderKey.arguments(), folderKey.subKeys(), folderKey.combiner(), folderKey.isNegated(), nested, firstClause, key.alias(), *this);
+    } else if (key.isType<QMailAccountKey>()) {
+        const QMailAccountKey &accountKey(key.key<QMailAccountKey>());
+        return ::buildWhereClause(accountKey, accountKey.arguments(), accountKey.subKeys(), accountKey.combiner(), accountKey.isNegated(), nested, firstClause, key.alias(), *this);
+    }
+
+    return QString();
+}
+
+QVariantList QMailStorePrivate::whereClauseValues(const Key& key) const
+{
+    if (key.isType<QMailMessageKey>()) {
+        const QMailMessageKey &messageKey(key.key<QMailMessageKey>());
+        return ::whereClauseValues(messageKey);
+    } else if (key.isType<QMailFolderKey>()) {
+        const QMailFolderKey &folderKey(key.key<QMailFolderKey>());
+        return ::whereClauseValues(folderKey);
+    } else if (key.isType<QMailAccountKey>()) {
+        const QMailAccountKey &accountKey(key.key<QMailAccountKey>());
+        return ::whereClauseValues(accountKey);
+    } 
+
+    return QVariantList();
+}
+
+bool QMailStorePrivate::containsProperty(const QMailMessageKey::Property& p,
+                                         const QMailMessageKey& key) const
+{
+    foreach(const QMailMessageKey::ArgumentType &a, key.arguments())
+        if(a.property == p)  
+            return true;
+       
+    foreach(const QMailMessageKey &k, key.subKeys())
+        if(containsProperty(p,k))
+            return true;
+
+    return false;
+}
+
+bool QMailStorePrivate::containsProperty(const QMailMessageSortKey::Property& p,
+                                         const QMailMessageSortKey& key) const
+{
+    foreach(const QMailMessageSortKey::ArgumentType &a, key.arguments())
+        if(a.first == p)  
+            return true;
+
+    return false;
+}
+
+QVariantList QMailStorePrivate::messageValues(const QMailMessageKey::Properties& prop, const QMailMessageMetaData& data)
+{
+    QVariantList values;
+
+    const MessageValueExtractor<QMailMessageMetaData> extractor(data);
+
+    // The ContentScheme and ContentIdentifier properties map to the same field
+    QMailMessageKey::Properties properties(prop);
+    if ((properties & QMailMessageKey::ContentScheme) && (properties & QMailMessageKey::ContentIdentifier))
+        properties &= ~QMailMessageKey::ContentIdentifier;
+
+    foreach (QMailMessageKey::Property p, messagePropertyList()) {
+        switch (properties & p)
+        {
+            case QMailMessageKey::Id:
+                values.append(extractor.id());
+                break;
+
+            case QMailMessageKey::Type:
+                values.append(extractor.messageType());
+                break;
+
+            case QMailMessageKey::ParentFolderId:
+                values.append(extractor.parentFolderId());
+                break;
+
+            case QMailMessageKey::Sender:
+                values.append(extractor.from());
+                break;
+
+            case QMailMessageKey::Recipients:
+                values.append(extractor.to());
+                break;
+
+            case QMailMessageKey::Subject:
+                values.append(extractor.subject());
+                break;
+
+            case QMailMessageKey::TimeStamp:
+                values.append(extractor.date());
+                break;
+
+            case QMailMessageKey::ReceptionTimeStamp:
+                values.append(extractor.receivedDate());
+                break;
+
+            case QMailMessageKey::Status:
+                values.append(extractor.status());
+                break;
+
+            case QMailMessageKey::ParentAccountId:
+                values.append(extractor.parentAccountId());
+                break;
+
+            case QMailMessageKey::ServerUid:
+                values.append(extractor.serverUid());
+                break;
+
+            case QMailMessageKey::Size:
+                values.append(extractor.size());
+                break;
+
+            case QMailMessageKey::ContentType:
+                values.append(extractor.content());
+                break;
+
+            case QMailMessageKey::PreviousParentFolderId:
+                values.append(extractor.previousParentFolderId());
+                break;
+
+            case QMailMessageKey::ContentScheme:
+            case QMailMessageKey::ContentIdentifier:
+                // For either of these (there can be only one) we want to produce the entire URI
+                values.append(::contentUri(extractor.contentScheme().toString(), extractor.contentIdentifier().toString()));
+                break;
+
+            case QMailMessageKey::InResponseTo:
+                values.append(extractor.inResponseTo());
+                break;
+
+            case QMailMessageKey::ResponseType:
+                values.append(extractor.responseType());
+                break;
+        }
+    }
+
+    return values;
+}
+
+void QMailStorePrivate::updateMessageValues(const QMailMessageKey::Properties& properties, const QVariantList& values, const QMap<QString, QString>& customFields, QMailMessageMetaData& metaData)
+{
+    QPair<QString, QString> uriElements;
+    QVariantList::const_iterator it = values.constBegin();
+
+    foreach (QMailMessageKey::Property p, messagePropertyList()) {
+        const MessageValueExtractor<QVariant> extractor(*it);
+        bool valueConsumed(true);
+
+        switch (properties & p)
+        {
+            case QMailMessageKey::Id:
+                metaData.setId(extractor.id());
+                break;
+
+            case QMailMessageKey::Type:
+                metaData.setMessageType(extractor.messageType());
+                break;
+
+            case QMailMessageKey::ParentFolderId:
+                metaData.setParentFolderId(extractor.parentFolderId());
+                break;
+
+            case QMailMessageKey::Sender:
+                metaData.setFrom(extractor.from());
+                break;
+
+            case QMailMessageKey::Recipients:
+                metaData.setTo(extractor.to());
+                break;
+
+            case QMailMessageKey::Subject:
+                metaData.setSubject(extractor.subject());
+                break;
+
+            case QMailMessageKey::TimeStamp:
+                metaData.setDate(extractor.date());
+                break;
+
+            case QMailMessageKey::ReceptionTimeStamp:
+                metaData.setReceivedDate(extractor.receivedDate());
+                break;
+
+            case QMailMessageKey::Status:
+                metaData.setStatus(extractor.status());
+                break;
+
+            case QMailMessageKey::ParentAccountId:
+                metaData.setParentAccountId(extractor.parentAccountId());
+                break;
+
+            case QMailMessageKey::ServerUid:
+                metaData.setServerUid(extractor.serverUid());
+                break;
+
+            case QMailMessageKey::Size:
+                metaData.setSize(extractor.size());
+                break;
+
+            case QMailMessageKey::ContentType:
+                metaData.setContent(extractor.content());
+                break;
+
+            case QMailMessageKey::PreviousParentFolderId:
+                metaData.setPreviousParentFolderId(extractor.previousParentFolderId());
+                break;
+
+            case QMailMessageKey::ContentScheme:
+                if (uriElements.first.isEmpty()) {
+                    uriElements = ::uriElements(extractor.contentUri());
+                } else {
+                    valueConsumed = false;
+                }
+                metaData.setContentScheme(uriElements.first);
+                break;
+
+            case QMailMessageKey::ContentIdentifier:
+                if (uriElements.first.isEmpty()) {
+                    uriElements = ::uriElements(extractor.contentUri());
+                } else {
+                    valueConsumed = false;
+                }
+                metaData.setContentIdentifier(uriElements.second);
+                break;
+
+            case QMailMessageKey::InResponseTo:
+                metaData.setInResponseTo(extractor.inResponseTo());
+                break;
+
+            case QMailMessageKey::ResponseType:
+                metaData.setResponseType(extractor.responseType());
+                break;
+
+            case QMailMessageKey::Custom:
+                metaData.setCustomFields(customFields);
+                break;
+
+            default:
+                valueConsumed = false;
+                break;
+        }
+
+        if (valueConsumed)
+            ++it;
+    }
+
+    if (it != values.constEnd())
+        qWarning() << QString("updateMessageValues: %1 values not consumed!").arg(values.constEnd() - it);
+
+    // The target message is not completely loaded
+    metaData.setStatus(QMailMessage::UnloadedData, true);
+}
+
+bool QMailStorePrivate::executeFile(QFile &file)
+{
+    bool result(true);
+
+    // read assuming utf8 encoding.
+    QTextStream ts(&file);
+    ts.setCodec(QTextCodec::codecForName("utf8"));
+    ts.setAutoDetectUnicode(true);
+    
+    QString sql = parseSql(ts);
+    while (result && !sql.isEmpty()) {
+        QSqlQuery query(database);
+        if (!query.exec(sql)) {
+            qMailLog(Messaging) << "Failed to exec table creation SQL query:" << sql << "- error:" << query.lastError().text();
+            result = false;
+        }
+        sql = parseSql(ts);
+    }
+
+    return result;
+}
+
+bool QMailStorePrivate::ensureVersionInfo()
+{
+    if (!database.tables().contains("versioninfo", Qt::CaseInsensitive)) {
+        // Use the same version scheme as dbmigrate, in case we need to cooperate later
+        QString sql("CREATE TABLE versioninfo ("
+                    "   tableName NVARCHAR (255) NOT NULL,"
+                    "   versionNum INTEGER NOT NULL,"
+                    "   lastUpdated NVARCHAR(20) NOT NULL,"
+                    "   PRIMARY KEY(tableName, versionNum))");
+
+        QSqlQuery query(database);
+        if (!query.exec(sql)) {
+            qMailLog(Messaging) << "Failed to create versioninfo table - query:" << sql << "- error:" << query.lastError().text();
+            return false;
+        }
+    }
+
+    return true;
+}
+
+qint64 QMailStorePrivate::tableVersion(const QString &name) const
+{
+    QString sql("SELECT COALESCE(MAX(versionNum), 0) FROM versioninfo WHERE tableName=?");
+
+    QSqlQuery query(database);
+    query.prepare(sql);
+    query.addBindValue(name);
+    if (query.exec() && query.first())
+        return query.value(0).value<qint64>();
+
+    qMailLog(Messaging) << "Failed to query versioninfo - query:" << sql << "- error:" << query.lastError().text();
+    return 0;
+}
+
+bool QMailStorePrivate::setTableVersion(const QString &name, qint64 version)
+{
+    QString sql("DELETE FROM versioninfo WHERE tableName=? AND versionNum=?");
+
+    // Delete any existing entry for this table
+    QSqlQuery query(database);
+    query.prepare(sql);
+    query.addBindValue(name);
+    query.addBindValue(version);
+
+    if (!query.exec()) {
+        qMailLog(Messaging) << "Failed to delete versioninfo - query:" << sql << "- error:" << query.lastError().text();
+        return false;
+    } else {
+        sql = "INSERT INTO versioninfo (tablename,versionNum,lastUpdated) VALUES (?,?,?)";
+
+        // Insert the updated info
+        query = QSqlQuery(database);
+        query.prepare(sql);
+        query.addBindValue(name);
+        query.addBindValue(version);
+        query.addBindValue(QDateTime::currentDateTime().toString());
+
+        if (!query.exec()) {
+            qMailLog(Messaging) << "Failed to insert versioninfo - query:" << sql << "- error:" << query.lastError().text();
+            return false;
+        }
+    }
+
+    return true;
+}
+
+qint64 QMailStorePrivate::incrementTableVersion(const QString &name, qint64 current)
+{
+    qint64 next = current + 1;
+
+    QString versionInfo("-" + QString::number(current) + "-" + QString::number(next));
+    QString scriptName(":/QtopiaSql/" + database.driverName() + "/" + name + versionInfo);
+
+    QFile data(scriptName);
+    if (!data.open(QIODevice::ReadOnly)) {
+        qMailLog(Messaging) << "Failed to load table upgrade resource:" << name;
+    } else {
+        if (executeFile(data)) {
+            // Update the table version number
+            if (setTableVersion(name, next))
+                current = next;
+        }
+    }
+
+    return current;
+}
+
+bool QMailStorePrivate::upgradeTableVersion(const QString &name, qint64 current, qint64 final)
+{
+    while (current < final) {
+        int newVersion = incrementTableVersion(name, current);
+        if (newVersion == current) {
+            qMailLog(Messaging) << "Failed to increment table version from:" << current << "(" << name << ")";
+            break;
+        } else {
+            current = newVersion;
+        }
+    }
+
+    return (current == final);
+}
+
+bool QMailStorePrivate::createTable(const QString &name)
+{
+    bool result = true;
+
+    // load schema.
+    QFile data(":/QtopiaSql/" + database.driverName() + "/" + name);
+    if (!data.open(QIODevice::ReadOnly)) {
+        qMailLog(Messaging) << "Failed to load table schema resource:" << name;
+        result = false;
+    } else {
+        result = executeFile(data);
+    }
+
+    return result;
+}
+
+bool QMailStorePrivate::setupTables(const QList<TableInfo> &tableList)
+{
+    bool result = true;
+
+    QStringList tables = database.tables();
+
+    foreach (const TableInfo &table, tableList) {
+        const QString &tableName(table.first);
+        qint64 version(table.second);
+
+        if (!tables.contains(tableName, Qt::CaseInsensitive)) {
+            // Create the table
+            result &= (createTable(tableName) && setTableVersion(tableName, version));
+        } else {
+            // Ensure the table does not have an incompatible version
+            qint64 dbVersion = tableVersion(tableName);
+            if (dbVersion == 0) {
+                qWarning() << "No version for existing table:" << tableName;
+                result = false;
+            } else if (dbVersion != version) {
+                if (version > dbVersion) {
+                    // Try upgrading the table
+                    result = upgradeTableVersion(tableName, dbVersion, version);
+                    qMailLog(Messaging) << (result ? "Upgraded" : "Unable to upgrade") << "version for table:" << tableName << " from" << dbVersion << "to" << version;
+                } else {
+                    qWarning() << "Incompatible version for table:" << tableName << "- existing" << dbVersion << "!=" << version;
+                    result = false;
+                }
+            }
+        }
+    }
+        
+    return result;
+}
+
+bool QMailStorePrivate::setupFolders(const QList<FolderInfo> &folderList)
+{
+    QSet<quint64> folderIds;
+
+    {
+        QSqlQuery query(simpleQuery("SELECT id FROM mailfolders", 
+                                    "folder ids query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+
+        while (query.next())
+            folderIds.insert(query.value(0).toULongLong());
+    }
+
+    foreach (const FolderInfo &folder, folderList) {
+        if (folderIds.contains(folder.first))
+            continue;
+        QSqlQuery query(simpleQuery("INSERT INTO mailfolders (id,name,parentid,parentaccountid,displayname,status,servercount,serverunreadcount) VALUES (?,?,?,?,?,?,?,?)",
+                                    QVariantList() << folder.first
+                                                   << folder.second
+                                                   << quint64(0)
+                                                   << quint64(0)
+                                                   << QString()
+                                                   << quint64(0)
+                                                   << int(0)
+                                                   << int(0),
+                                    "setupFolders insert query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    return true;
+}
+
+QString QMailStorePrivate::parseSql(QTextStream& ts)
+{
+    QString qry = "";
+    while(!ts.atEnd())
+    {
+        QString line = ts.readLine();
+        // comment, remove.
+        if (line.contains(QLatin1String("--")))
+            line.truncate (line.indexOf (QLatin1String("--")));
+        if (line.trimmed ().length () == 0)
+            continue;
+        qry += line;
+        
+        if ( line.contains( ';' ) == false) 
+            qry += QLatin1String(" ");
+        else
+            return qry;
+    }
+    return qry;
+}
+
+QString QMailStorePrivate::expandValueList(const QVariantList& valueList)
+{
+    Q_ASSERT(!valueList.isEmpty());
+    return expandValueList(valueList.count());
+}
+
+QString QMailStorePrivate::expandValueList(int valueCount)
+{
+    Q_ASSERT(valueCount > 0);
+
+    if (valueCount == 1) {
+        return "(?)";
+    } else {
+        QString inList = " (?";
+        for (int i = 1; i < valueCount; ++i)
+            inList += ",?";
+        inList += ")";
+        return inList;
+    }
+}
+
+QString QMailStorePrivate::expandProperties(const QMailMessageKey::Properties& prop, bool update) const 
+{
+    QString out;
+
+    // The ContentScheme and ContentIdentifier properties map to the same field
+    QMailMessageKey::Properties properties(prop);
+    if ((properties & QMailMessageKey::ContentScheme) && (properties & QMailMessageKey::ContentIdentifier))
+        properties &= ~QMailMessageKey::ContentIdentifier;
+
+    const QMailStorePrivate::MessagePropertyMap &map(messagePropertyMap());
+    foreach (QMailMessageKey::Property p, messagePropertyList()) {
+        if (properties & p) {
+            if (!out.isEmpty())
+                out += ",";                     
+            out += map.value(p);
+            if (update)
+                out += "=?";
+        }
+    }
+
+    return out;
+}
+
+bool QMailStorePrivate::addAccount(QMailAccount *account, QMailAccountConfiguration *config,
+                                   QMailAccountIdList *addedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptAddAccount, this, 
+                                        account, config, 
+                                        addedAccountIds), 
+                                   "addAccount");
+}
+
+bool QMailStorePrivate::addFolder(QMailFolder *folder,
+                                  QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{   
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptAddFolder, this, 
+                                        folder, 
+                                        addedFolderIds, modifiedAccountIds), 
+                                   "addFolder");
+}
+
+bool QMailStorePrivate::addMessage(QMailMessage *message,
+                                   QMailMessageIdList *addedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    if (!message->parentAccountId().isValid()) {
+        // Require a parent account - possibly relax this later
+        qMailLog(Messaging) << "Unable to add message without parent account";
+        return false;
+    }
+
+    if (message->contentScheme().isEmpty()) {
+        // Use the default storage scheme
+        message->setContentScheme(defaultContentScheme());
+    }
+
+    MutexGuard lock(contentManagerMutex());
+    if (!lock.lock(1000)) {
+        qMailLog(Messaging) << "Unable to acquire message body mutex in addMessage!";
+        return false;
+    } 
+
+    if (QMailContentManager *contentManager = QMailContentManagerFactory::create(message->contentScheme())) {
+        QMailStore::ErrorCode code = contentManager->add(message);
+        if (code != QMailStore::NoError) {
+            setLastError(code);
+            qMailLog(Messaging) << "Unable to add message content to URI:" << ::contentUri(*message);
+            return false;
+        }
+
+        if (!addMessage(static_cast<QMailMessageMetaData*>(message), addedMessageIds, modifiedFolderIds, modifiedAccountIds)) {
+            QMailStore::ErrorCode code = contentManager->remove(message->contentIdentifier());
+            if (code != QMailStore::NoError) {
+                setLastError(code);
+                qMailLog(Messaging) << "Could not remove extraneous message content:" << ::contentUri(*message);
+            }
+
+            return false;
+        }
+    } else {
+        qMailLog(Messaging) << "Unable to create content manager for scheme:" << message->contentScheme();
+        return false;
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::addMessage(QMailMessageMetaData *metaData,
+                                   QMailMessageIdList *addedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptAddMessage, this, 
+                                        metaData,
+                                        addedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "addMessage");
+}
+
+bool QMailStorePrivate::removeAccounts(const QMailAccountKey &key,
+                                       QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRemoveAccounts, this, 
+                                        cref(key), 
+                                        deletedAccounts, deletedFolders, deletedMessages), 
+                                   "removeAccounts");
+}
+
+bool QMailStorePrivate::removeFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option,
+                                      QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRemoveFolders, this, 
+                                        cref(key), option, 
+                                        deletedFolders, deletedMessages, modifiedAccounts), 
+                                   "removeFolders");
+}
+
+bool QMailStorePrivate::removeMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option,
+                                       QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts, QMailFolderIdList *modifiedFolders)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRemoveMessages, this, 
+                                        cref(key), option, 
+                                        deletedMessages, modifiedAccounts, modifiedFolders), 
+                                   "removeMessages");
+}
+
+bool QMailStorePrivate::updateAccount(QMailAccount *account, QMailAccountConfiguration *config,
+                                      QMailAccountIdList *updatedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateAccount, this, 
+                                        account, config, 
+                                        updatedAccountIds), 
+                                   "updateAccount");
+}
+
+bool QMailStorePrivate::updateAccountConfiguration(QMailAccountConfiguration *config,
+                                                   QMailAccountIdList *updatedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateAccount, this, 
+                                        reinterpret_cast<QMailAccount*>(0), config, 
+                                        updatedAccountIds), 
+                                   "updateAccount");
+}
+
+bool QMailStorePrivate::updateFolder(QMailFolder *folder,
+                                     QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateFolder, this, 
+                                        folder, 
+                                        updatedFolderIds, modifiedAccountIds), 
+                                   "updateFolder");
+}
+
+bool QMailStorePrivate::updateMessage(QMailMessageMetaData *metaData, QMailMessage *message,
+                                      QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, bool *modifiedContent)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateMessage, this, 
+                                        metaData, message, 
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds, modifiedContent), 
+                                   "updateMessage");
+}
+
+bool QMailStorePrivate::updateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, const QMailMessageMetaData &data,
+                                               QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateMessagesMetaData, this, 
+                                        cref(key), cref(properties), cref(data), 
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "updateMessagesMetaData");
+}
+
+bool QMailStorePrivate::updateMessagesMetaData(const QMailMessageKey &key, quint64 status, bool set,
+                                               QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateMessagesStatus, this, 
+                                        cref(key), status, set,
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "updateMessagesMetaData"); // not 'updateMessagesStatus', due to function name exported by QMailStore
+}
+
+bool QMailStorePrivate::restoreToPreviousFolder(const QMailMessageKey &key,
+                                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRestoreToPreviousFolder, this, 
+                                        cref(key), 
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "restoreToPreviousFolder");
+}
+
+bool QMailStorePrivate::purgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptPurgeMessageRemovalRecords, this, 
+                                        cref(accountId), cref(serverUids)), 
+                                   "purgeMessageRemovalRecords");
+}
+
+int QMailStorePrivate::countAccounts(const QMailAccountKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptCountAccounts, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "countAccounts");
+    return result;
+}
+
+int QMailStorePrivate::countFolders(const QMailFolderKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptCountFolders, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "countFolders");
+    return result;
+}
+
+int QMailStorePrivate::countMessages(const QMailMessageKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptCountMessages, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "countMessages");
+    return result;
+}
+
+int QMailStorePrivate::sizeOfMessages(const QMailMessageKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptSizeOfMessages, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "sizeOfMessages");
+    return result;
+}
+
+QMailAccountIdList QMailStorePrivate::queryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey) const
+{
+    QMailAccountIdList ids;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptQueryAccounts, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(sortKey), &ids), 
+                           "queryAccounts");
+    return ids;
+}
+
+QMailFolderIdList QMailStorePrivate::queryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey) const
+{
+    QMailFolderIdList ids;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptQueryFolders, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(sortKey), &ids), 
+                           "queryFolders");
+    return ids;
+}
+
+QMailMessageIdList QMailStorePrivate::queryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey) const
+{
+    QMailMessageIdList ids;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptQueryMessages, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(sortKey), &ids), 
+                           "queryMessages");
+    return ids;
+}
+
+QMailAccount QMailStorePrivate::account(const QMailAccountId &id) const
+{
+    if (accountCache.contains(id))
+        return accountCache.lookup(id);
+
+    QMailAccount account;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptAccount, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &account), 
+                           "account");
+    return account;
+}
+
+QMailAccountConfiguration QMailStorePrivate::accountConfiguration(const QMailAccountId &id) const
+{
+    QMailAccountConfiguration config;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptAccountConfiguration, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &config), 
+                           "accountConfiguration");
+    return config;
+}
+
+QMailFolder QMailStorePrivate::folder(const QMailFolderId &id) const
+{
+    if (folderCache.contains(id))
+        return folderCache.lookup(id);
+
+    QMailFolder folder;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptFolder, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &folder), 
+                           "folder");
+    return folder;
+}
+
+QMailMessage QMailStorePrivate::message(const QMailMessageId &id) const
+{
+    // Resolve from overloaded member functions:
+    AttemptResult (QMailStorePrivate::*func)(const QMailMessageId&, QMailMessage*, ReadLock&) = &QMailStorePrivate::attemptMessage;
+
+    QMailMessage msg;
+    repeatedly<ReadAccess>(bind(func, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &msg), 
+                           "message(id)");
+    return msg;
+}
+
+QMailMessage QMailStorePrivate::message(const QString &uid, const QMailAccountId &accountId) const
+{
+    // Resolve from overloaded member functions:
+    AttemptResult (QMailStorePrivate::*func)(const QString&, const QMailAccountId&, QMailMessage*, ReadLock&) = &QMailStorePrivate::attemptMessage;
+
+    QMailMessage msg;
+    repeatedly<ReadAccess>(bind(func, const_cast<QMailStorePrivate*>(this), 
+                                cref(uid), cref(accountId), &msg), 
+                           "message(uid, accountId)");
+    return msg;
+}
+
+QMailMessageMetaData QMailStorePrivate::messageMetaData(const QMailMessageId &id) const
+{
+    if (headerCache.contains(id))
+        return headerCache.lookup(id);
+
+    //if not in the cache, then preload the cache with the id and its most likely requested siblings
+    preloadHeaderCache(id);
+
+    return headerCache.lookup(id);
+}
+
+QMailMessageMetaData QMailStorePrivate::messageMetaData(const QString &uid, const QMailAccountId &accountId) const
+{
+    QMailMessageKey uidKey(QMailMessageKey::serverUid(uid));
+    QMailMessageKey accountKey(QMailMessageKey::parentAccountId(accountId));
+
+    QMailMessageMetaDataList results = messagesMetaData(uidKey & accountKey, allMessageProperties(), QMailStore::ReturnAll);
+    if (!results.isEmpty()) {
+        if (results.count() > 1){
+            qMailLog(Messaging) << "Warning, messageMetaData by uid returned more than 1 result";
+        }
+
+        headerCache.insert(results.first());
+        return results.first();
+    }
+
+    return QMailMessageMetaData();
+}
+
+QMailMessageMetaDataList QMailStorePrivate::messagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option) const
+{
+    QMailMessageMetaDataList metaData;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptMessagesMetaData, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(properties), option, &metaData), 
+                           "messagesMetaData");
+    return metaData;
+}
+
+QMailMessageRemovalRecordList QMailStorePrivate::messageRemovalRecords(const QMailAccountId &accountId, const QMailFolderId &folderId) const
+{
+    QMailMessageRemovalRecordList removalRecords;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptMessageRemovalRecords, const_cast<QMailStorePrivate*>(this), 
+                                cref(accountId), cref(folderId), &removalRecords), 
+                           "messageRemovalRecords(accountId, folderId)");
+    return removalRecords;
+}
+
+bool QMailStorePrivate::registerAccountStatusFlag(const QString &name)
+{
+    if (accountStatusMask(name) != 0)
+        return true;
+
+    static const QString context("accountstatus");
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRegisterStatusBit, this,
+                                        cref(name), cref(context), 64), 
+                                   "registerAccountStatusBit");
+}
+
+quint64 QMailStorePrivate::accountStatusMask(const QString &name) const
+{
+    static QMap<QString, quint64> statusMap;
+    static const QString context("accountstatus");
+
+    return queryStatusMap(name, context, statusMap);
+}
+
+bool QMailStorePrivate::registerFolderStatusFlag(const QString &name)
+{
+    if (folderStatusMask(name) != 0)
+        return true;
+
+    static const QString context("folderstatus");
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRegisterStatusBit, this,
+                                        cref(name), cref(context), 64), 
+                                   "registerFolderStatusBit");
+}
+
+quint64 QMailStorePrivate::folderStatusMask(const QString &name) const
+{
+    static QMap<QString, quint64> statusMap;
+    static const QString context("folderstatus");
+
+    return queryStatusMap(name, context, statusMap);
+}
+
+bool QMailStorePrivate::registerMessageStatusFlag(const QString &name)
+{
+    if (messageStatusMask(name) != 0)
+        return true;
+
+    static const QString context("messagestatus");
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRegisterStatusBit, this,
+                                        cref(name), cref(context), 64), 
+                                   "registerMessageStatusBit");
+}
+
+quint64 QMailStorePrivate::messageStatusMask(const QString &name) const
+{
+    static QMap<QString, quint64> statusMap;
+    static const QString context("messagestatus");
+
+    return queryStatusMap(name, context, statusMap);
+}
+
+quint64 QMailStorePrivate::queryStatusMap(const QString &name, const QString &context, QMap<QString, quint64> &map) const
+{
+    QMap<QString, quint64>::const_iterator it = map.find(name);
+    if (it != map.end())
+        return it.value();
+
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptStatusBit, const_cast<QMailStorePrivate*>(this), 
+                                cref(name), cref(context), &result), 
+                           "folderStatusMask");
+    if (result == 0)
+        return 0;
+
+    quint64 maskValue = (1 << (result - 1));
+    map[name] = maskValue;
+    return maskValue;
+}
+
+QMailFolderIdList QMailStorePrivate::folderAncestorIds(const QMailFolderIdList& ids, bool inTransaction, AttemptResult *result) const
+{
+    QMailFolderIdList ancestorIds;
+
+    QMailStorePrivate *self(const_cast<QMailStorePrivate*>(this));
+    if (inTransaction) {
+        // We can't retry this query after a busy error if we're in a transaction
+        ReadLock l(self);
+        *result = self->attemptFolderAncestorIds(ids, &ancestorIds, l);
+    } else {
+        bool ok = repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptFolderAncestorIds, self,
+                                              cref(ids), &ancestorIds), 
+                                         "folderAncestorIds");
+        if (result)
+            *result = ok ? Success : Failure;
+    }
+
+    return ancestorIds;
+}
+
+void QMailStorePrivate::removeExpiredData(const QMailMessageIdList& messageIds, const QStringList& contentUris, const QMailFolderIdList& folderIds, const QMailAccountIdList& accountIds)
+{
+    foreach (const QMailMessageId& id, messageIds) {
+        headerCache.remove(id);
+    }
+
+    {
+        MutexGuard lock(contentManagerMutex());
+        if (!lock.lock(1000)) {
+            qMailLog(Messaging) << "Unable to acquire message body mutex in removeExpiredData!";
+        } else {
+            foreach (const QString& contentUri, contentUris) {
+                QPair<QString, QString> elements(::uriElements(contentUri));
+
+                if (QMailContentManager *contentManager = QMailContentManagerFactory::create(elements.first)) {
+                    QMailStore::ErrorCode code = contentManager->remove(elements.second);
+                    if (code != QMailStore::NoError) {
+                        setLastError(code);
+                        qMailLog(Messaging) << "Unable to remove expired message content:" << contentUri;
+                        continue;
+                    }
+                } else {
+                    qMailLog(Messaging) << "Unable to create content manager for scheme:" << elements.first;
+                    continue;
+                }
+            }
+        }
+    }
+
+    foreach (const QMailFolderId& id, folderIds) {
+        folderCache.remove(id);
+    }
+
+    foreach (const QMailAccountId& id, accountIds) {
+        accountCache.remove(id);
+    }
+}
+
+template<typename AccessType, typename FunctionType>
+bool QMailStorePrivate::repeatedly(FunctionType func, const QString &description) const
+{
+    static const unsigned int MinRetryDelay = 64;
+    static const unsigned int MaxRetryDelay = 2048;
+    static const unsigned int MaxAttempts = 10;
+
+    // This function calls the supplied function repeatedly, retrying whenever it
+    // returns the DatabaseFailure result and the database's last error is SQLITE_BUSY.
+    // It sleeps between repeated attempts, for increasing amounts of time.
+    // The argument should be an object allowing nullary invocation returning an
+    // AttemptResult value, created with tr1::bind if necessary.
+
+    unsigned int attemptCount = 0;
+    unsigned int delay = MinRetryDelay;
+
+     while (true) {
+        AttemptResult result = evaluate(AccessType(), func, description, const_cast<QMailStorePrivate*>(this));
+
+        if (result == Success) {
+            if (attemptCount > 0) {
+                qMailLog(Messaging) << ::getpid() << "Able to" << qPrintable(description) << "after" << attemptCount << "failed attempts";
+            }
+            return true;
+        } else if (result == Failure) {
+            qMailLog(Messaging) << ::getpid() << "Unable to" << qPrintable(description);
+            if (lastError() == QMailStore::NoError) {
+                setLastError(errorType(AccessType()));
+            }
+            return false;
+        } else { 
+            // result == DatabaseFailure
+            if (queryError() == Sqlite3BusyErrorNumber) {
+                if (attemptCount < MaxAttempts) {
+                    qMailLog(Messaging) << ::getpid() << "Failed to" << qPrintable(description) << "- busy, pausing to retry";
+
+                    // Pause before we retry
+                    QMail::usleep(delay * 1000);
+                    if (delay < MaxRetryDelay)
+                        delay *= 2;
+
+                    ++attemptCount;
+                } else {
+                    qMailLog(Messaging) << ::getpid() << "Retry count exceeded - failed to" << qPrintable(description);
+                    break;
+                }
+            } else if (queryError() == Sqlite3ConstraintErrorNumber) {
+                qMailLog(Messaging) << ::getpid() << "Unable to" << qPrintable(description) << "- constraint failure";
+                setLastError(QMailStore::ConstraintFailure);
+                break;
+            } else {
+                qMailLog(Messaging) << ::getpid() << "Unable to" << qPrintable(description) << "- code:" << queryError();
+                break;
+            }
+        }
+    }
+
+    // We experienced a database-related failure
+    if (lastError() == QMailStore::NoError) {
+        setLastError(QMailStore::FrameworkFault);
+    }
+    return false;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::addCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName)
+{
+    if (!fields.isEmpty()) {
+        QVariantList customFields;
+        QVariantList customValues;
+
+        // Insert any custom fields belonging to this account
+        QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+        for ( ; it != end; ++it) {
+            customFields.append(QVariant(it.key()));
+            customValues.append(QVariant(it.value()));
+        }
+
+        // Batch insert the custom fields
+        QString sql("INSERT INTO %1 (id,name,value) VALUES (%2,?,?)");
+        QSqlQuery query(batchQuery(sql.arg(tableName).arg(QString::number(id)),
+                                   QVariantList() << QVariant(customFields)
+                                                  << QVariant(customValues),
+                                   QString("%1 custom field insert query").arg(tableName)));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::updateCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName)
+{
+    QMap<QString, QString> existing;
+
+    {
+        // Find the existing fields
+        QString sql("SELECT name,value FROM %1 WHERE id=?");
+        QSqlQuery query(simpleQuery(sql.arg(tableName),
+                                    QVariantList() << id,
+                                    QString("%1 update custom select query").arg(tableName)));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        while (query.next())
+            existing.insert(query.value(0).toString(), query.value(1).toString());
+    }
+
+    QVariantList obsoleteFields;
+    QVariantList modifiedFields;
+    QVariantList modifiedValues;
+    QVariantList addedFields;
+    QVariantList addedValues;
+
+    // Compare the sets
+    QMap<QString, QString>::const_iterator fend = fields.end(), eend = existing.end();
+    QMap<QString, QString>::const_iterator it = existing.begin();
+    for ( ; it != eend; ++it) {
+        QMap<QString, QString>::const_iterator current = fields.find(it.key());
+        if (current == fend) {
+            obsoleteFields.append(QVariant(it.key()));
+        } else if (*current != *it) {
+            modifiedFields.append(QVariant(current.key()));
+            modifiedValues.append(QVariant(current.value()));
+        }
+    }
+
+    for (it = fields.begin(); it != fend; ++it) {
+        if (existing.find(it.key()) == eend) {
+            addedFields.append(QVariant(it.key()));
+            addedValues.append(QVariant(it.value()));
+        }
+    }
+
+    if (!obsoleteFields.isEmpty()) {
+        // Remove the obsolete fields
+        QString sql("DELETE FROM %1 WHERE id=? AND name IN %2");
+        QSqlQuery query(simpleQuery(sql.arg(tableName).arg(expandValueList(obsoleteFields)),
+                                    QVariantList() << id << obsoleteFields,
+                                    QString("%1 update custom delete query").arg(tableName)));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+    }
+
+    if (!modifiedFields.isEmpty()) {
+        // Batch update the modified fields
+        QString sql("UPDATE %1 SET value=? WHERE id=%2 AND name=?");
+        QSqlQuery query(batchQuery(sql.arg(tableName).arg(QString::number(id)),
+                                   QVariantList() << QVariant(modifiedValues)
+                                                  << QVariant(modifiedFields),
+                                   QString("%1 update custom update query").arg(tableName)));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+    }
+
+    if (!addedFields.isEmpty()) {
+        // Batch insert the added fields
+        QString sql("INSERT INTO %1 (id,name,value) VALUES (%2,?,?)");
+        QSqlQuery query(batchQuery(sql.arg(tableName).arg(QString::number(id)),
+                                   QVariantList() << QVariant(addedFields)
+                                                  << QVariant(addedValues),
+                                   QString("%1 update custom insert query").arg(tableName)));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName)
+{
+    QString sql("SELECT name,value FROM %1 WHERE id=?");
+    QSqlQuery query(simpleQuery(sql.arg(tableName),
+                                QVariantList() << id,
+                                QString("%1 custom field query").arg(tableName)));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        fields->insert(query.value(0).toString(), query.value(1).toString());
+
+    return Success;
+}
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config, 
+                                                                      QMailAccountIdList *addedAccountIds, 
+                                                                      Transaction &t)
+{
+    if (account->id().isValid() && idExists(account->id())) {
+        qMailLog(Messaging) << "Account already exists in database, use update instead";
+        return Failure;
+    }
+
+    QMailAccountId insertId;
+
+    {
+        QString properties("type,name,status,signature,emailaddress");
+        QString values("?,?,?,?,?");
+        QVariantList propertyValues;
+        propertyValues << static_cast<int>(account->messageType()) 
+                       << account->name() 
+                       << account->status()
+                       << account->signature()
+                       << account->fromAddress().toString(true);
+
+        {
+            QSqlQuery query(simpleQuery(QString("INSERT INTO mailaccounts (%1) VALUES (%2)").arg(properties).arg(values),
+                                        propertyValues,
+                                        "addAccount mailaccounts query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            //Extract the insert id
+            insertId = QMailAccountId(extractValue<quint64>(query.lastInsertId()));
+        }
+
+        // Insert any standard folders configured for this account
+        const QMap<QMailFolder::StandardFolder, QMailFolderId> &folders(account->standardFolders());
+        if (!folders.isEmpty()) {
+            QVariantList types;
+            QVariantList folderIds;
+
+            QMap<QMailFolder::StandardFolder, QMailFolderId>::const_iterator it = folders.begin(), end = folders.end();
+            for ( ; it != end; ++it) {
+                types.append(QVariant(static_cast<int>(it.key())));
+                folderIds.append(QVariant(it.value().toULongLong()));
+            }
+
+            // Batch insert the folders
+            QString sql("INSERT into mailaccountfolders (id,foldertype,folderid) VALUES (%1,?,?)");
+            QSqlQuery query(batchQuery(sql.arg(QString::number(insertId.toULongLong())),
+                                       QVariantList() << QVariant(types)
+                                                      << QVariant(folderIds),
+                                       "addAccount mailaccountfolders query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        // Insert any custom fields belonging to this account
+        AttemptResult result = addCustomFields(insertId.toULongLong(), account->customFields(), "mailaccountcustom");
+        if (result != Success)
+            return result;
+    }
+
+    if (config) {
+        foreach (const QString &service, config->services()) {
+            QMailAccountConfiguration::ServiceConfiguration &serviceConfig(config->serviceConfiguration(service));
+            const QMap<QString, QString> &fields = serviceConfig.values();
+
+            QVariantList configFields;
+            QVariantList configValues;
+
+            // Insert any configuration fields belonging to this account
+            QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+            for ( ; it != end; ++it) {
+                configFields.append(QVariant(it.key()));
+                configValues.append(QVariant(it.value()));
+            }
+
+            // Batch insert the custom fields
+            QString sql("INSERT INTO mailaccountconfig (id,service,name,value) VALUES (%1,'%2',?,?)");
+            QSqlQuery query(batchQuery(sql.arg(QString::number(insertId.toULongLong())).arg(service),
+                                    QVariantList() << QVariant(configFields)
+                                                    << QVariant(configValues),
+                                    "addAccount mailaccountconfig query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        config->setId(insertId);
+    }
+
+    account->setId(insertId);
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit account changes to database";
+
+        account->setId(QMailAccountId()); //revert the id
+        return DatabaseFailure;
+    }
+
+    addedAccountIds->append(insertId);
+    return Success;
+}
+*/
+/*  Replaced with SQPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddFolder(QMailFolder *folder, 
+                                                                     QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                     Transaction &t)
+{   
+    //check that the parent folder actually exists
+    if (!checkPreconditions(*folder))
+        return Failure;
+
+    QMailFolderId insertId;
+
+    {
+        {
+            QSqlQuery query(simpleQuery("INSERT INTO mailfolders (name,parentid,parentaccountid,displayname,status,servercount,serverunreadcount) VALUES (?,?,?,?,?,?,?)",
+                                        QVariantList() << folder->path()
+                                                       << folder->parentFolderId().toULongLong()
+                                                       << folder->parentAccountId().toULongLong()
+                                                       << folder->displayName()
+                                                       << folder->status()
+                                                       << folder->serverCount()
+                                                       << folder->serverUnreadCount(),
+                                        "addFolder mailfolders query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            // Extract the inserted id
+            insertId = QMailFolderId(extractValue<quint64>(query.lastInsertId()));
+        }
+
+        // Insert any custom fields belonging to this folder
+        AttemptResult result = addCustomFields(insertId.toULongLong(), folder->customFields(), "mailfoldercustom");
+        if (result != Success)
+            return result;
+    }
+
+    folder->setId(insertId);
+
+    //create links to ancestor folders
+    if (folder->parentFolderId().isValid()) {
+        {
+            //add records for each ancestor folder
+            QSqlQuery query(simpleQuery("INSERT INTO mailfolderlinks "
+                                        "SELECT DISTINCT id,? FROM mailfolderlinks WHERE descendantid=?",
+                                        QVariantList() << folder->id().toULongLong() 
+                                                       << folder->parentFolderId().toULongLong(),
+                                        "mailfolderlinks insert ancestors"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        {
+            // Our direct parent is also an ancestor
+            QSqlQuery query(simpleQuery("INSERT INTO mailfolderlinks VALUES (?,?)",
+                                        QVariantList() << folder->parentFolderId().toULongLong() 
+                                                       << folder->id().toULongLong(),
+                                        "mailfolderlinks insert parent"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit folder changes to database";
+
+        folder->setId(QMailFolderId()); //revert the id
+        return DatabaseFailure;
+    }
+   
+    addedFolderIds->append(insertId);
+    if (folder->parentAccountId().isValid())
+        modifiedAccountIds->append(folder->parentAccountId());
+    return Success;
+}
+*/
+
+/*  Replaced with SQPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddMessage(QMailMessageMetaData *metaData,
+                                                                      QMailMessageIdList *addedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                                      Transaction &t)
+{
+    if (!metaData->parentFolderId().isValid()) {
+        qMailLog(Messaging) << "Unable to add message. Invalid parent folder id";
+        return Failure;
+    }
+
+    if (metaData->id().isValid() && idExists(metaData->id())) {
+        qMailLog(Messaging) << "Message ID" << metaData->id() << "already exists in database, use update instead";
+        return Failure;
+    }
+
+    // Ensure that any phone numbers are added in minimal form
+    QMailAddress from(metaData->from());
+    QString fromText(from.isPhoneNumber() ? from.minimalPhoneNumber() : from.toString());
+
+    QStringList recipients;
+    foreach (const QMailAddress& address, metaData->to())
+        recipients.append(address.isPhoneNumber() ? address.minimalPhoneNumber() : address.toString());
+
+    QMailMessageId insertId;
+
+    {
+        // Add the record to the mailmessages table
+        QSqlQuery query(simpleQuery("INSERT INTO mailmessages (type,"
+                                                              "parentfolderid,"
+                                                              "sender,"
+                                                              "recipients,"
+                                                              "subject,"
+                                                              "stamp,"
+                                                              "status,"
+                                                              "parentaccountid,"
+                                                              "mailfile,"
+                                                              "serveruid,"
+                                                              "size,"
+                                                              "contenttype,"
+                                                              "responseid,"
+                                                              "responsetype,"
+                                                              "receivedstamp"
+                                                              ") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)",
+                                    QVariantList() << static_cast<int>(metaData->messageType())
+                                                   << metaData->parentFolderId().toULongLong()
+                                                   << fromText
+                                                   << recipients.join(",")
+                                                   << metaData->subject()
+                                                   << QMailTimeStamp(metaData->date()).toLocalTime()
+                                                   << static_cast<int>(metaData->status())
+                                                   << metaData->parentAccountId().toULongLong()
+                                                   << ::contentUri(*metaData)
+                                                   << metaData->serverUid()
+                                                   << metaData->size()
+                                                   << static_cast<int>(metaData->content())
+                                                   << metaData->inResponseTo().toULongLong()
+                                                   << metaData->responseType()
+                                                   << QMailTimeStamp(metaData->receivedDate()).toLocalTime(),
+                                    "addMessage mailmessages query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        //retrieve the insert id
+        insertId = QMailMessageId(extractValue<quint64>(query.lastInsertId()));
+    }
+
+    // Insert any custom fields belonging to this message
+    AttemptResult result = addCustomFields(insertId.toULongLong(), metaData->customFields(), "mailmessagecustom");
+    if (result != Success)
+        return result;
+
+    // Find the complete set of modified folders, including ancestor folders
+    QMailFolderIdList folderIds;
+    folderIds.append(metaData->parentFolderId());
+    folderIds += folderAncestorIds(folderIds, true, &result);
+    if (result != Success)
+        return result;
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit message changes to database";
+        return DatabaseFailure;
+    }
+
+    metaData->setId(insertId);
+    addedMessageIds->append(insertId);
+    *modifiedFolderIds = folderIds;
+    if (metaData->parentAccountId().isValid())
+        modifiedAccountIds->append(metaData->parentAccountId());
+    return Success;
+}
+*/
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRemoveAccounts(const QMailAccountKey &key, 
+                                                                          QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages,
+                                                                          Transaction &t)
+{
+    QStringList expiredContent;
+
+    if (deleteAccounts(key, *deletedAccounts, *deletedFolders, *deletedMessages, expiredContent)) {
+        if (t.commit()) {
+            //remove deleted objects from caches
+            removeExpiredData(*deletedMessages, expiredContent, *deletedFolders, *deletedAccounts);
+            return Success;
+        }
+    }
+
+    return DatabaseFailure;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRemoveFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option, 
+                                                                         QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts,
+                                                                         Transaction &t)
+{
+    QStringList expiredContent;
+
+    if (deleteFolders(key, option, *deletedFolders, *deletedMessages, expiredContent, *modifiedAccounts)) {
+        if (t.commit()) {
+            //remove deleted objects from caches
+            removeExpiredData(*deletedMessages, expiredContent, *deletedFolders);
+            return Success;
+        }
+    }
+
+    return DatabaseFailure;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRemoveMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option, 
+                                                                          QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts, QMailFolderIdList *modifiedFolders,
+                                                                          Transaction &t)
+{
+    QStringList expiredContent;
+
+    if (deleteMessages(key, option, *deletedMessages, expiredContent, *modifiedAccounts, *modifiedFolders)) {
+        if (t.commit()) {
+            //remove deleted objects from caches
+            removeExpiredData(*deletedMessages, expiredContent);
+            return Success;
+        }
+    }
+
+    return DatabaseFailure;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAccount *account, QMailAccountConfiguration *config, 
+                                                                         QMailAccountIdList *updatedAccountIds,
+                                                                         Transaction &t)
+{
+    QMailAccountId id(account ? account->id() : config ? config->id() : QMailAccountId());
+    if (!id.isValid())
+        return Failure;
+
+    if (account) {
+        QString properties("type=?, name=?, status=?, signature=?, emailaddress=?");
+        QVariantList propertyValues;
+        propertyValues << static_cast<int>(account->messageType()) 
+                       << account->name() 
+                       << account->status()
+                       << account->signature()
+                       << account->fromAddress().toString(true);
+
+        {
+            QSqlQuery query(simpleQuery(QString("UPDATE mailaccounts SET %1 WHERE id=?").arg(properties),
+                                        propertyValues << id.toULongLong(),
+                                        "updateAccount mailaccounts query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        // Update any standard folders configured
+        const QMap<QMailFolder::StandardFolder, QMailFolderId> &folders(account->standardFolders());
+        QMap<QMailFolder::StandardFolder, QMailFolderId> existingFolders;
+
+        {
+            // Find the existing folders
+            QSqlQuery query(simpleQuery("SELECT foldertype,folderid FROM mailaccountfolders WHERE id=?", 
+                                        QVariantList() << id.toULongLong(),
+                                        "updateAccount mailaccountfolders select query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            while (query.next())
+                existingFolders.insert(QMailFolder::StandardFolder(query.value(0).toInt()), QMailFolderId(query.value(1).toULongLong()));
+        }
+
+        QVariantList obsoleteTypes;
+        QVariantList modifiedTypes;
+        QVariantList modifiedFolders;
+        QVariantList addedTypes;
+        QVariantList addedFolders;
+
+        // Compare the sets
+        QMap<QMailFolder::StandardFolder, QMailFolderId>::const_iterator fend = folders.end(), eend = existingFolders.end();
+        QMap<QMailFolder::StandardFolder, QMailFolderId>::const_iterator it = existingFolders.begin();
+        for ( ; it != eend; ++it) {
+            QMap<QMailFolder::StandardFolder, QMailFolderId>::const_iterator current = folders.find(it.key());
+            if (current == fend) {
+                obsoleteTypes.append(QVariant(static_cast<int>(it.key())));
+            } else if (*current != *it) {
+                modifiedTypes.append(QVariant(static_cast<int>(current.key())));
+                modifiedFolders.append(QVariant(current.value().toULongLong()));
+            }
+        }
+
+        for (it = folders.begin(); it != fend; ++it) {
+            if (existingFolders.find(it.key()) == eend) {
+                addedTypes.append(QVariant(static_cast<int>(it.key())));
+                addedFolders.append(QVariant(it.value().toULongLong()));
+            }
+        }
+
+        if (!obsoleteTypes.isEmpty()) {
+            // Remove the obsolete folders
+            QString sql("DELETE FROM mailaccountfolders WHERE id=? AND foldertype IN %2");
+            QSqlQuery query(simpleQuery(sql.arg(expandValueList(obsoleteTypes)),
+                                        QVariantList() << id.toULongLong() << obsoleteTypes,
+                                        "updateAccount mailaccountfolders delete query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        if (!modifiedTypes.isEmpty()) {
+            // Batch update the modified folders
+            QString sql("UPDATE mailaccountfolders SET folderid=? WHERE id=%2 AND foldertype=?");
+            QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())),
+                                       QVariantList() << QVariant(modifiedFolders)
+                                                      << QVariant(modifiedTypes),
+                                       "updateAccount mailaccountfolders update query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        if (!addedTypes.isEmpty()) {
+            // Batch insert the added fields
+            QString sql("INSERT INTO mailaccountfolders (id,foldertype,folderid) VALUES (%2,?,?)");
+            QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())),
+                                       QVariantList() << QVariant(addedTypes)
+                                                      << QVariant(addedFolders),
+                                       "updateAccount mailaccountfolders insert query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        if (account->customFieldsModified()) {
+            AttemptResult result = updateCustomFields(id.toULongLong(), account->customFields(), "mailaccountcustom");
+            if (result != Success)
+                return result;
+        }
+    }
+
+    if (config) {
+        // Find the complete set of configuration fields
+        QMap<QPair<QString, QString>, QString> fields;
+
+        foreach (const QString &service, config->services()) {
+            QMailAccountConfiguration::ServiceConfiguration &serviceConfig(config->serviceConfiguration(service));
+            const QMap<QString, QString> &values = serviceConfig.values();
+
+            // Insert any configuration fields belonging to this account
+            QMap<QString, QString>::const_iterator it = values.begin(), end = values.end();
+            for ( ; it != end; ++it)
+                fields.insert(qMakePair(service, it.key()), it.value());
+        }
+
+        // Find the existing fields in the database
+        QMap<QPair<QString, QString>, QString> existing;
+
+        {
+            QSqlQuery query(simpleQuery("SELECT service,name,value FROM mailaccountconfig WHERE id=?",
+                                        QVariantList() << id.toULongLong(),
+                                        "updateAccount mailaccountconfig select query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            while (query.next())
+                existing.insert(qMakePair(query.value(0).toString(), query.value(1).toString()), query.value(2).toString());
+        }
+
+        QMap<QString, QVariantList> obsoleteFields;
+        QMap<QString, QVariantList> modifiedFields;
+        QMap<QString, QVariantList> modifiedValues;
+        QMap<QString, QVariantList> addedFields;
+        QMap<QString, QVariantList> addedValues;
+
+        // Compare the sets
+        QMap<QPair<QString, QString>, QString>::const_iterator fend = fields.end(), eend = existing.end();
+        QMap<QPair<QString, QString>, QString>::const_iterator it = existing.begin();
+        for ( ; it != eend; ++it) {
+            const QPair<QString, QString> &name = it.key();
+            QMap<QPair<QString, QString>, QString>::const_iterator current = fields.find(name);
+            if (current == fend) {
+                obsoleteFields[name.first].append(QVariant(name.second));
+            } else if (*current != *it) {
+                modifiedFields[name.first].append(QVariant(name.second));
+                modifiedValues[name.first].append(QVariant(current.value()));
+            }
+        }
+
+        for (it = fields.begin(); it != fend; ++it) {
+            const QPair<QString, QString> &name = it.key();
+            if (existing.find(name) == eend) {
+                addedFields[name.first].append(QVariant(name.second));
+                addedValues[name.first].append(QVariant(it.value()));
+            }
+        }
+
+        if (!obsoleteFields.isEmpty()) {
+            // Remove the obsolete fields
+            QMap<QString, QVariantList>::const_iterator it = obsoleteFields.begin(), end = obsoleteFields.end();
+            for ( ; it != end; ++it) {
+                const QString &service = it.key();
+                const QVariantList &fields = it.value();
+                
+                QString sql("DELETE FROM mailaccountconfig WHERE id=? AND service='%1' AND name IN %2");
+                QSqlQuery query(simpleQuery(sql.arg(service).arg(expandValueList(fields)),
+                                            QVariantList() << id.toULongLong() << fields,
+                                            "updateAccount mailaccountconfig delete query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+            }
+        }
+
+        if (!modifiedFields.isEmpty()) {
+            // Batch update the modified fields
+            QMap<QString, QVariantList>::const_iterator it = modifiedFields.begin(), end = modifiedFields.end();
+            for (QMap<QString, QVariantList>::const_iterator vit = modifiedValues.begin(); it != end; ++it, ++vit) {
+                const QString &service = it.key();
+                const QVariantList &fields = it.value();
+                const QVariantList &values = vit.value();
+                
+                QString sql("UPDATE mailaccountconfig SET value=? WHERE id=%1 AND service='%2' AND name=?");
+                QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())).arg(service),
+                                           QVariantList() << QVariant(values) << QVariant(fields),
+                                           "updateAccount mailaccountconfig update query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+            }
+        }
+
+        if (!addedFields.isEmpty()) {
+            // Batch insert the added fields
+            QMap<QString, QVariantList>::const_iterator it = addedFields.begin(), end = addedFields.end();
+            for (QMap<QString, QVariantList>::const_iterator vit = addedValues.begin(); it != end; ++it, ++vit) {
+                const QString &service = it.key();
+                const QVariantList &fields = it.value();
+                const QVariantList &values = vit.value();
+                
+                QString sql("INSERT INTO mailaccountconfig (id,service,name,value) VALUES (%1,'%2',?,?)");
+                QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())).arg(service),
+                                           QVariantList() << QVariant(fields) << QVariant(values),
+                                           "updateAccount mailaccountconfig insert query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+            }
+        }
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit account update to database";
+        return DatabaseFailure;
+    }
+        
+    if (account) {
+        // Update the account cache
+        if (accountCache.contains(id))
+            accountCache.insert(*account);
+    }
+
+    updatedAccountIds->append(id);
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateFolder(QMailFolder *folder, 
+                                                                        QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                        Transaction &t)
+{
+    //check that the parent folder actually exists
+    if(!checkPreconditions(*folder, true))
+        return Failure;
+
+    QMailFolderId parentFolderId;
+    QMailAccountId parentAccountId;
+
+    {
+        //find the current parent folder
+        QSqlQuery query(simpleQuery("SELECT parentid, parentaccountid FROM mailfolders WHERE id=?",
+                                    QVariantList() << folder->id().toULongLong(),
+                                    "mailfolder parent query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        if (query.first()) {
+            parentFolderId = QMailFolderId(extractValue<quint64>(query.value(0)));
+            parentAccountId = QMailAccountId(extractValue<quint64>(query.value(1)));
+        }
+    }
+
+    {
+        QSqlQuery query(simpleQuery("UPDATE mailfolders SET name=?,parentid=?,parentaccountid=?,displayname=?,status=?,servercount=?,serverunreadcount=? WHERE id=?",
+                                    QVariantList() << folder->path()
+                                                   << folder->parentFolderId().toULongLong()
+                                                   << folder->parentAccountId().toULongLong()
+                                                   << folder->displayName()
+                                                   << folder->status()
+                                                   << folder->serverCount()
+                                                   << folder->serverUnreadCount()
+                                                   << folder->id().toULongLong(),
+                                    "updateFolder mailfolders query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+    }
+    
+    if (folder->customFieldsModified()) {
+        AttemptResult result = updateCustomFields(folder->id().toULongLong(), folder->customFields(), "mailfoldercustom");
+        if (result != Success)
+            return result;
+    }
+
+    if (parentFolderId != folder->parentFolderId()) {
+        // QMailAccount contains a copy of the folder data; we need to tell it to reload
+        if (parentFolderId.isValid())
+            modifiedAccountIds->append(parentAccountId);
+        if (folder->parentFolderId().isValid() && !modifiedAccountIds->contains(folder->parentAccountId()))
+            modifiedAccountIds->append(folder->parentAccountId());
+
+        {
+            //remove existing links to this folder
+            QSqlQuery query(simpleQuery("DELETE FROM mailfolderlinks WHERE descendantid = ?",
+                                        QVariantList() << folder->id().toULongLong(),
+                                        "mailfolderlinks delete in update"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        {
+            //add links to the new parent
+            QSqlQuery query(simpleQuery("INSERT INTO mailfolderlinks "
+                                        "SELECT DISTINCT id,? FROM mailfolderlinks WHERE descendantid=?",
+                                        QVariantList() << folder->id().toULongLong() 
+                                                       << folder->parentFolderId().toULongLong(),
+                                        "mailfolderlinks insert ancestors"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        {
+            QSqlQuery query(simpleQuery("INSERT INTO mailfolderlinks VALUES (?,?)",
+                                        QVariantList() << folder->parentFolderId().toULongLong()
+                                                       << folder->id().toULongLong(),
+                                        "mailfolderlinks insert parent"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+    }
+        
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit folder update to database";
+        return DatabaseFailure;
+    }
+
+    //update the folder cache
+    if (folderCache.contains(folder->id()))
+        folderCache.insert(*folder);
+
+    updatedFolderIds->append(folder->id());
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateMessage(QMailMessageMetaData *metaData, QMailMessage *message, 
+                                                                         QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, bool *modifiedContent,
+                                                                         Transaction &t)
+{
+    if (!metaData->id().isValid())
+        return Failure;
+
+    QMailAccountId parentAccountId;
+    QMailFolderId parentFolderId;
+    QString contentUri;
+    QMailFolderIdList folderIds;
+
+    QMailMessageKey::Properties updateProperties(QMailStorePrivate::updatableMessageProperties());
+    QVariantList extractedValues;
+
+    // Do we actually have an update to perform?
+    bool updateContent(message && message->contentModified());
+    if (metaData->dataModified() || updateContent) {
+        // Find the existing properties 
+        {
+            QSqlQuery query(simpleQuery("SELECT parentaccountId,parentfolderId,mailfile FROM mailmessages WHERE id=?",
+                                        QVariantList() << metaData->id().toULongLong(),
+                                        "updateMessage existing properties query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            if (query.first()) {
+                parentAccountId = QMailAccountId(extractValue<quint64>(query.value(0)));
+                parentFolderId = QMailFolderId(extractValue<quint64>(query.value(1)));
+                contentUri = extractValue<QString>(query.value(2));
+
+                // Find any folders affected by this update
+                folderIds.append(metaData->parentFolderId());
+                if (parentFolderId != metaData->parentFolderId()) {
+                    // The previous location folder has also changed
+                    folderIds.append(parentFolderId);
+                    metaData->setPreviousParentFolderId(parentFolderId);
+                }
+
+                // Ancestor folders are also considered to be affected
+                AttemptResult result;
+                folderIds += folderAncestorIds(folderIds, true, &result);
+                if (result != Success)
+                    return result;
+            } else {
+                qMailLog(Messaging) << "Could not query parent account, folder and content URI";
+                return Failure;
+            }
+        }
+
+        if (updateContent) {
+            updateProperties |= QMailMessageKey::ContentIdentifier;
+
+            bool addContent(updateContent && contentUri.isEmpty());
+            if (addContent)
+                updateProperties |= QMailMessageKey::ContentScheme;
+
+            // We need to update the content for this message
+            if (metaData->contentScheme().isEmpty()) {
+                // Use the default storage scheme
+                metaData->setContentScheme(defaultContentScheme());
+            }
+
+            MutexGuard lock(contentManagerMutex());
+            if (!lock.lock(1000)) {
+                qMailLog(Messaging) << "Unable to acquire message body mutex in updateMessage!";
+                return Failure;
+            } 
+
+            if (QMailContentManager *contentManager = QMailContentManagerFactory::create(metaData->contentScheme())) {
+                if (addContent) {
+                    // We need to add this content to the message
+                    QMailStore::ErrorCode code = contentManager->add(message);
+                    if (code != QMailStore::NoError) {
+                        setLastError(code);
+                        qMailLog(Messaging) << "Unable to add message content to URI:" << ::contentUri(*metaData);
+                        return Failure;
+                    }
+                } else {
+                    QMailStore::ErrorCode code = contentManager->update(message);
+                    if (code != QMailStore::NoError) {
+                        setLastError(code);
+                        qMailLog(Messaging) << "Unable to update message content:" << contentUri;
+                        return Failure;
+                    }
+                }
+
+                metaData->setContentIdentifier(message->contentIdentifier());
+            } else {
+                qMailLog(Messaging) << "Unable to create content manager for scheme:" << metaData->contentScheme();
+                return Failure;
+            }
+        }
+
+        // Don't update the previous parent folder if it isn't set
+        if (!metaData->previousParentFolderId().isValid())
+            updateProperties &= ~QMailMessageKey::PreviousParentFolderId;
+
+        extractedValues = messageValues(updateProperties, *metaData);
+
+        {
+            QString sql("UPDATE mailmessages SET %1 WHERE id=?");
+            QSqlQuery query(simpleQuery(sql.arg(expandProperties(updateProperties, true)),
+                                        extractedValues + (QVariantList() << metaData->id().toULongLong()),
+                                        "updateMessage mailmessages update"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        if (metaData->customFieldsModified()) {
+            AttemptResult result = updateCustomFields(metaData->id().toULongLong(), metaData->customFields(), "mailmessagecustom");
+            if (result != Success)
+                return result;
+
+            updateProperties |= QMailMessageKey::Custom;
+        }
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit folder update to database";
+        return DatabaseFailure;
+    }
+
+    if (parentAccountId.isValid()) {
+        // The message is now up-to-date with data store
+        metaData->setUnmodified();
+
+        if (headerCache.contains(metaData->id())) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(metaData->id());
+            updateMessageValues(updateProperties, extractedValues, metaData->customFields(), cachedMetaData);
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+        }
+
+        updatedMessageIds->append(metaData->id());
+        *modifiedFolderIds = folderIds;
+
+        if (metaData->parentAccountId().isValid())
+            modifiedAccountIds->append(metaData->parentAccountId());
+        if (parentAccountId.isValid()) {
+            if (parentAccountId != metaData->parentAccountId())
+                modifiedAccountIds->append(parentAccountId);
+        }
+    }
+
+    *modifiedContent = updateContent;
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::affectedByMessageIds(const QMailMessageIdList &messages, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const
+{
+    AttemptResult result;
+
+    // Find the set of folders whose contents are modified by this update
+    QMailFolderIdList messageFolderIds;
+
+    QMailStorePrivate *self(const_cast<QMailStorePrivate*>(this));
+    {
+        ReadLock l(self);
+        result = self->attemptMessageFolderIds(QMailMessageKey::id(messages), &messageFolderIds, l);
+    }
+
+    if (result != Success)
+        return result;
+
+    return affectedByFolderIds(messageFolderIds, folderIds, accountIds);
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::affectedByFolderIds(const QMailFolderIdList &folders, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const
+{
+    AttemptResult result;
+
+    // Any ancestor folders are also modified
+    QMailFolderIdList ancestorIds;
+
+    QMailStorePrivate *self(const_cast<QMailStorePrivate*>(this));
+    {
+        ReadLock l(self);
+        result = self->attemptFolderAncestorIds(folders, &ancestorIds, l);
+    }
+
+    if (result != Success)
+        return result;
+
+    *folderIds = folders + ancestorIds;
+
+    // Find the set of accounts whose contents are modified by this update
+    ReadLock l(self);
+    result = self->attemptFolderAccountIds(QMailFolderKey::id(*folderIds), accountIds, l);
+    return result;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &props, const QMailMessageMetaData &data, 
+                                                                                  QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                                  Transaction &t) 
+{
+    //do some checks first
+    if (props & QMailMessageKey::Id) {
+        qMailLog(Messaging) << "Updating of messages IDs is not supported";
+        return Failure;
+    }
+    
+    QMailMessageKey::Properties properties(props);
+
+    if (properties & QMailMessageKey::ParentFolderId) {
+        if (!idExists(data.parentFolderId())) {
+            qMailLog(Messaging) << "Update of messages failed. Parent folder does not exist";
+            return Failure;
+        }
+    }
+
+    QVariantList extractedValues;
+
+    //get the valid ids
+    *updatedMessageIds = queryMessages(key, QMailMessageSortKey());
+    if (!updatedMessageIds->isEmpty()) {
+        // Find the set of folders and accounts whose contents are modified by this update
+        QMailMessageKey modifiedMessageKey(QMailMessageKey::id(*updatedMessageIds));
+        AttemptResult result = affectedByMessageIds(*updatedMessageIds, modifiedFolderIds, modifiedAccountIds);
+        if (result != Success)
+            return result;
+
+        // If we're setting parentFolderId, that folder is modified also
+        if (properties & QMailMessageKey::ParentFolderId) {
+            if (!modifiedFolderIds->contains(data.parentFolderId()))
+                modifiedFolderIds->append(data.parentFolderId());
+
+            // All these messages need to have previousparentfolderid updated, where it will change
+            QSqlQuery query(simpleQuery("UPDATE mailmessages SET previousparentfolderid=parentfolderid",
+                                        QVariantList(),
+                                        QList<Key>() << Key(modifiedMessageKey),
+                                        "updateMessagesMetaData mailmessages previousparentfolderid update query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        if (properties & QMailMessageKey::Custom) {
+            // Here, we can't compare the input to each target individually.  Instead, remove
+            // all custom fields from the affected messages, and add (or re-add) the new ones
+            QVariantList addedFields;
+            QVariantList addedValues;
+
+            const QMap<QString, QString> &fields = data.customFields();
+            QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+            for ( ; it != end; ++it) {
+                addedFields.append(QVariant(it.key()));
+                addedValues.append(QVariant(it.value()));
+            }
+
+            {
+                // Remove the obsolete fields
+                QSqlQuery query(simpleQuery("DELETE FROM mailmessagecustom",
+                                            Key(modifiedMessageKey),
+                                            "updateMessagesMetaData mailmessagecustom delete query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+            }
+
+            if (!addedFields.isEmpty()) {
+                foreach (const QMailMessageId &id, *updatedMessageIds) {
+                    // Batch insert the added fields
+                    QString sql("INSERT INTO mailmessagecustom (id,name,value) VALUES (%1,?,?)");
+                    QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())),
+                                               QVariantList() << QVariant(addedFields)
+                                                              << QVariant(addedValues),
+                                               "updateMessagesMetaData mailmessagecustom insert query"));
+                    if (query.lastError().type() != QSqlError::NoError)
+                        return DatabaseFailure;
+                }
+            }
+
+            properties &= ~QMailMessageKey::Custom;
+        }
+
+        if (properties != 0) {
+            extractedValues = messageValues(properties, data);
+
+            QString sql("UPDATE mailmessages SET %1");
+            QSqlQuery query(simpleQuery(sql.arg(expandProperties(properties, true)),
+                                        extractedValues,
+                                        Key(modifiedMessageKey),
+                                        "updateMessagesMetaData mailmessages query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit metadata update to database";
+        return DatabaseFailure;
+    }
+
+    // Update the header cache
+    foreach (const QMailMessageId& id, *updatedMessageIds) {
+        if (headerCache.contains(id)) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(id);
+            updateMessageValues(properties, extractedValues, data.customFields(), cachedMetaData);
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateMessagesStatus(const QMailMessageKey &key, quint64 status, bool set, 
+                                                                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                                                Transaction &t)
+{
+    //get the valid ids
+    *updatedMessageIds = queryMessages(key, QMailMessageSortKey());
+    if (!updatedMessageIds->isEmpty()) {
+        // Find the set of folders and accounts whose contents are modified by this update
+        AttemptResult result = affectedByMessageIds(*updatedMessageIds, modifiedFolderIds, modifiedAccountIds);
+        if (result != Success)
+            return result;
+
+        {
+            QString sql("UPDATE mailmessages SET status=(status %1 ?)");
+            QSqlQuery query(simpleQuery(sql.arg(set ? "|" : "&"),
+                                        QVariantList() << (set ? status : ~status),
+                                        Key(QMailMessageKey::id(*updatedMessageIds)),
+                                        "updateMessagesMetaData status query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit metadata status update to database";
+        return DatabaseFailure;
+    }
+
+    // Update the header cache
+    foreach (const QMailMessageId& id, *updatedMessageIds) {
+        if (headerCache.contains(id)) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(id);
+            quint64 newStatus = cachedMetaData.status();
+            newStatus = set ? (newStatus | status) : (newStatus & ~status);
+            cachedMetaData.setStatus(newStatus);
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRestoreToPreviousFolder(const QMailMessageKey &key, 
+                                                                                   QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                                                   Transaction &t)
+{
+    // Find the message and folders that are affected by this update
+    QSqlQuery query(simpleQuery("SELECT t0.id, t0.parentfolderid, t0.previousparentfolderid FROM mailmessages t0",
+                                Key(key, "t0"),
+                                "restoreToPreviousFolder info query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    QSet<quint64> folderIdSet;
+    while (query.next()) {
+        updatedMessageIds->append(QMailMessageId(extractValue<quint64>(query.value(0))));
+
+        folderIdSet.insert(extractValue<quint64>(query.value(1)));
+        folderIdSet.insert(extractValue<quint64>(query.value(2)));
+    }
+
+    if (!folderIdSet.isEmpty()) {
+        QMailFolderIdList folderIds;
+        foreach (quint64 id, folderIdSet)
+            folderIds.append(QMailFolderId(id));
+
+        // Find the set of folders and accounts whose contents are modified by this update
+        AttemptResult result = affectedByFolderIds(folderIds, modifiedFolderIds, modifiedAccountIds);
+        if (result != Success)
+            return result;
+
+        // Update the message records
+        QSqlQuery query(simpleQuery("UPDATE mailmessages SET parentfolderid=previousparentfolderid, previousparentfolderid=NULL",
+                                    Key(QMailMessageKey::id(*updatedMessageIds)),
+                                    "restoreToPreviousFolder update query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit message folder restoration to database";
+        return DatabaseFailure;
+    }
+
+    // Update the header cache
+    foreach (const QMailMessageId &id, *updatedMessageIds) {
+        if (headerCache.contains(id)) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(id);
+            cachedMetaData.setParentFolderId(cachedMetaData.previousParentFolderId());
+            cachedMetaData.setPreviousParentFolderId(QMailFolderId());
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptPurgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids,
+                                                                                      Transaction &t)
+{
+    QMailMessageIdList removalIds;
+
+    {
+        QString sql("SELECT id FROM deletedmessages WHERE parentaccountid=?");
+
+        QVariantList bindValues;
+        bindValues << accountId.toULongLong();
+
+        if (!serverUids.isEmpty()) {
+            QVariantList uidValues;
+            foreach (const QString& uid, serverUids)
+                uidValues.append(uid);
+
+            sql.append(" AND serveruid IN %1");
+            sql = sql.arg(expandValueList(uidValues));
+
+            bindValues << uidValues;
+        }
+
+        QSqlQuery query(simpleQuery(sql, 
+                                    bindValues,
+                                    "purgeMessageRemovalRecord info query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        while (query.next())
+            removalIds.append(QMailMessageId(extractValue<quint64>(query.value(0))));
+    }
+
+    // anything to remove?
+    if (!removalIds.isEmpty()) {
+        QSqlQuery query(simpleQuery("DELETE FROM deletedmessages",
+                                    Key(QMailMessageKey::id(removalIds)),
+                                    "purgeMessageRemovalRecord delete query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit message removal record deletion to database";
+        return DatabaseFailure;
+    }
+
+    return Success;
+}
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountAccounts(const QMailAccountKey &key, int *result, 
+                                                                         ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT COUNT(*) FROM mailaccounts",
+                                Key(key),
+                                "countAccounts mailaccounts query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    if (query.first())
+        *result = extractValue<int>(query.value(0));
+
+    return Success;
+}
+*/
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountFolders(const QMailFolderKey &key, int *result, 
+                                                                        ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT COUNT(*) FROM mailfolders",
+                                Key(key),
+                                "countFolders mailfolders query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    if (query.first())
+        *result = extractValue<int>(query.value(0));
+
+    return Success;
+}
+*/
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountMessages(const QMailMessageKey &key, 
+                                                                         int *result, 
+                                                                         ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT COUNT(*) FROM mailmessages",
+                                Key(key),
+                                "countMessages mailmessages query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    if (query.first())
+        *result = extractValue<int>(query.value(0));
+
+    return Success;
+}
+*/
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptSizeOfMessages(const QMailMessageKey &key, 
+                                                                          int *result, 
+                                                                          ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT SUM(size FROM mailmessages",
+                                Key(key),
+                                "sizeOfMessages mailmessages query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    if (query.first())
+        *result = extractValue<int>(query.value(0));
+
+    return Success;
+}
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey, 
+                                                                         QMailAccountIdList *ids, 
+                                                                         ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT id FROM mailaccounts",
+                                QVariantList(),
+                                QList<Key>() << Key(key) << Key(sortKey),
+                                "queryAccounts mailaccounts query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        ids->append(QMailAccountId(extractValue<quint64>(query.value(0))));
+
+    return Success;
+}
+*/
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey, 
+                                                                        QMailFolderIdList *ids, 
+                                                                        ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT id FROM mailfolders",
+                                QVariantList(),
+                                QList<Key>() << Key(key) << Key(sortKey),
+                                "queryFolders mailfolders query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        ids->append(QMailFolderId(extractValue<quint64>(query.value(0))));
+
+    return Success;
+}
+*/
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey,
+                                                                         QMailMessageIdList *ids, 
+                                                                         ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT id FROM mailmessages",
+                                QVariantList(),
+                                QList<Key>() << Key(key) << Key(sortKey),
+                                "queryMessages mailmessages query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        ids->append(QMailMessageId(extractValue<quint64>(query.value(0))));
+
+    //store the results of this call for cache preloading
+    lastQueryMessageResult = *ids;
+
+    return Success;
+}
+*/
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAccountId &id, 
+                                                                   QMailAccount *result, 
+                                                                   ReadLock &)
+{
+    {
+        QSqlQuery query(simpleQuery("SELECT * FROM mailaccounts WHERE id=?",
+                                    QVariantList() << id.toULongLong(),
+                                    "account mailaccounts query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        if (query.first()) {
+            *result = extractAccount(query.record());
+        }
+    }
+
+    if (result->id().isValid()) {
+        {
+            // Find any standard folders configured for this account
+            QSqlQuery query(simpleQuery("SELECT foldertype,folderid FROM mailaccountfolders WHERE id=?",
+                                        QVariantList() << id.toULongLong(),
+                                        "account mailaccountfolders query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            while (query.next())
+                result->setStandardFolder(QMailFolder::StandardFolder(query.value(0).toInt()), QMailFolderId(query.value(1).toULongLong()));
+        }
+
+        // Find any custom fields for this account
+        QMap<QString, QString> fields;
+        AttemptResult attemptResult = customFields(id.toULongLong(), &fields, "mailaccountcustom");
+        if (attemptResult != Success)
+            return attemptResult;
+
+        result->setCustomFields(fields);
+        result->setCustomFieldsModified(false);
+
+        {
+            // Find the type of the account
+            QSqlQuery query(simpleQuery("SELECT service,value FROM mailaccountconfig WHERE id=? AND name='servicetype'",
+                                        QVariantList() << id.toULongLong(),
+                                        "account mailaccountconfig query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            while (query.next()) {
+                QString service(query.value(0).toString());
+                QString type(query.value(1).toString());
+
+                if (type.contains("source")) {
+                    result->addMessageSource(service);
+                }
+                if (type.contains("sink")) {
+                    result->addMessageSink(service);
+                }
+            }
+        }
+
+        //update cache 
+        accountCache.insert(*result);
+        return Success;
+    }
+
+    return Failure;
+}
+*/
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(const QMailAccountId &id, 
+                                                                                QMailAccountConfiguration *result, 
+                                                                                ReadLock &)
+{
+    // Find any configuration fields for this account
+    QSqlQuery query(simpleQuery("SELECT service,name,value FROM mailaccountconfig WHERE id=? ORDER BY service",
+                                QVariantList() << id.toULongLong(),
+                                "accountConfiguration mailaccountconfig query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    QString service;
+    QMailAccountConfiguration::ServiceConfiguration *serviceConfig = 0;
+
+    while (query.next()) {
+        QString svc(query.value(0).toString());
+        if (svc != service) {
+            service = svc;
+
+            if (!result->services().contains(service)) {
+                // Add this service to the configuration
+                result->addServiceConfiguration(service);
+            }
+
+            serviceConfig = &result->serviceConfiguration(service);
+        }
+
+        serviceConfig->setValue(query.value(1).toString(), query.value(2).toString());
+    }
+
+    if (service.isEmpty()) {
+        // No services - is this an error?
+        QSqlQuery query(simpleQuery("SELECT COUNT(*) FROM mailaccounts WHERE id=?",
+                                    QVariantList() << id.toULongLong(),
+                                    "accountConfiguration mailaccounts query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        if (query.first()) {
+            if (extractValue<int>(query.value(0)) == 0)
+                return Failure;
+        }
+    } 
+
+    result->setId(id);
+    result->setModified(false);
+
+    return Success;
+}
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptFolder(const QMailFolderId &id, 
+                                                                  QMailFolder *result, 
+                                                                  ReadLock &)
+{
+    {
+        QSqlQuery query(simpleQuery("SELECT * FROM mailfolders WHERE id=?",
+                                    QVariantList() << id.toULongLong(),
+                                    "folder mailfolders query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        if (query.first()) {
+            *result = extractFolder(query.record());
+        }
+    }
+
+    if (result->id().isValid()) {
+        // Find any custom fields for this folder
+        QMap<QString, QString> fields;
+        AttemptResult attemptResult = customFields(id.toULongLong(), &fields, "mailfoldercustom");
+        if (attemptResult != Success)
+            return attemptResult;
+
+        result->setCustomFields(fields);
+        result->setCustomFieldsModified(false);
+
+        //update cache 
+        folderCache.insert(*result);
+        return Success;
+    }
+
+    return Failure;
+}
+*/
+
+/* Replaced with SPARQL
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessage(const QMailMessageId &id, 
+                                                                   QMailMessage *result, 
+                                                                   ReadLock &)
+{
+    // Find any custom fields for this message
+    QMap<QString, QString> fields;
+    AttemptResult attemptResult = customFields(id.toULongLong(), &fields, "mailmessagecustom");
+    if (attemptResult != Success)
+        return attemptResult;
+
+    QSqlQuery query(simpleQuery("SELECT * FROM mailmessages WHERE id=?",
+                                QVariantList() << id.toULongLong(),
+                                "message mailmessages id query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    if (query.first()) {
+        *result = extractMessage(query.record(), fields);
+        if (result->id().isValid())
+            return Success;
+    }
+
+    return Failure;
+}
+*/
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessage(const QString &uid, const QMailAccountId &accountId, 
+                                                                   QMailMessage *result, 
+                                                                   ReadLock &lock)
+{
+    quint64 id(0);
+
+    {
+        QSqlQuery query(simpleQuery("SELECT id FROM mailmessages WHERE serveruid=? AND parentaccountid=?",
+                                    QVariantList() << uid << accountId.toULongLong(),
+                                    "message mailmessages uid/parentaccountid query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        if (query.first()) {
+            id = extractValue<quint64>(query.value(0));
+        }
+    }
+            
+    if (id == 0) {
+        return Failure;
+    }
+
+    return attemptMessage(QMailMessageId(id), result, lock);
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessagesMetaData(const QMailMessageKey& key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option, 
+                                                                            QMailMessageMetaDataList *result, 
+                                                                            ReadLock &)
+{
+    if (properties == QMailMessageKey::Custom) {
+        // We're only selecting custom fields
+        QString sql("SELECT %1 name, value FROM mailmessagecustom WHERE id IN ( SELECT t0.id FROM mailmessages t0");
+        sql += buildWhereClause(Key(key, "t0")) + " )";
+
+        QVariantList whereValues(::whereClauseValues(key));
+        QSqlQuery query(simpleQuery(sql.arg(option == QMailStore::ReturnDistinct ? "DISTINCT " : ""),
+                                    whereValues,
+                                    "messagesMetaData combined query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        // Find all the values for each parameter name in the set
+        QMap<QString, QStringList> fields;
+        while (query.next())
+            fields[query.value(0).toString()].append(query.value(1).toString());
+
+        // Create records for each of these parameters
+        int maxLen = 0;
+        foreach (const QStringList &list, fields.values())
+            maxLen = qMax<uint>(maxLen, list.count());
+
+        for (int i = 0; i < maxLen; ++i)
+            result->append(QMailMessageMetaData());
+
+        // Add all pairs to the results
+        foreach (const QString &name, fields.keys()) {
+            QMailMessageMetaDataList::iterator it = result->begin();
+            foreach (const QString &value, fields[name]) {
+                (*it).setCustomField(name, value);
+                ++it;
+            }
+        }
+
+        QMailMessageMetaDataList::iterator it = result->begin(), end = result->end();
+        for ( ; it != end; ++it)
+            (*it).setCustomFieldsModified(false);
+    } else {
+        bool includeCustom(properties & QMailMessageKey::Custom);
+        if (includeCustom && (option == QMailStore::ReturnDistinct)) {
+            qWarning() << "Warning: Distinct-ness is not supported with custom fields!";
+        }
+
+        QString sql("SELECT %1 %2 FROM mailmessages t0");
+        sql = sql.arg(option == QMailStore::ReturnDistinct ? "DISTINCT " : "");
+
+        QMailMessageKey::Properties props(properties);
+
+        bool removeId(false);
+        if (includeCustom && !(props & QMailMessageKey::Id)) {
+            // We need the ID to match against the custom table
+            props |= QMailMessageKey::Id;
+            removeId = true;
+        }
+
+        {
+            QSqlQuery query(simpleQuery(sql.arg(expandProperties(props, false)),
+                                        Key(key, "t0"),
+                                        "messagesMetaData mailmessages query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            while (query.next())
+                result->append(extractMessageMetaData(query.record(), props, props));
+        }
+
+        if (includeCustom) {
+            QMailMessageMetaDataList::iterator it = result->begin(), end = result->end();
+            for ( ; it != end; ++it) {
+                // Add the custom fields to the record
+                QMap<QString, QString> fields;
+                AttemptResult attemptResult = customFields((*it).id().toULongLong(), &fields, "mailmessagecustom");
+                if (attemptResult != Success)
+                    return attemptResult;
+
+                QMailMessageMetaData &metaData(*it);
+                metaData.setCustomFields(fields);
+                metaData.setCustomFieldsModified(false);
+
+                if (removeId)
+                    metaData.setId(QMailMessageId());
+            }
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessageRemovalRecords(const QMailAccountId &accountId, const QMailFolderId &folderId, 
+                                                                                 QMailMessageRemovalRecordList *result, 
+                                                                                 ReadLock &)
+{
+    QVariantList values;
+    values << accountId.toULongLong();
+
+    QString sql("SELECT * FROM deletedmessages WHERE parentaccountid=?");
+    if (folderId.isValid()) {
+        sql += " AND parentfolderid=?";
+        values << folderId.toULongLong();
+    }
+
+    QSqlQuery query(simpleQuery(sql,
+                                values,
+                                "messageRemovalRecords deletedmessages query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        result->append(extractMessageRemovalRecord(query.record()));
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessageFolderIds(const QMailMessageKey &key, 
+                                                                            QMailFolderIdList *result, 
+                                                                            ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT DISTINCT t0.parentfolderid FROM mailmessages t0",
+                                Key(key, "t0"),
+                                "messageFolderIds folder select query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        result->append(QMailFolderId(extractValue<quint64>(query.value(0))));
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptFolderAccountIds(const QMailFolderKey &key, 
+                                                                            QMailAccountIdList *result, 
+                                                                            ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT DISTINCT parentaccountid FROM mailfolders t0",
+                                Key(key, "t0"),
+                                "folderAccountIds account select query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        result->append(QMailAccountId(extractValue<quint64>(query.value(0))));
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptFolderAncestorIds(const QMailFolderIdList &ids, 
+                                                                             QMailFolderIdList *result, 
+                                                                             ReadLock &)
+{
+    QVariantList idValues;
+    foreach (const QMailFolderId& id, ids)
+        idValues.append(id.toULongLong());
+
+    QString sql("SELECT DISTINCT id FROM mailfolderlinks WHERE descendantid IN %1");
+    QSqlQuery query(simpleQuery(sql.arg(expandValueList(idValues)),
+                                idValues,
+                                "folderAncestorIds id select query"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    while (query.next())
+        result->append(QMailFolderId(extractValue<quint64>(query.value(0))));
+
+    return Success;
+}
+
+void QMailStorePrivate::preloadHeaderCache(const QMailMessageId& id) const
+{
+    QMailMessageIdList idBatch;
+    idBatch.append(id);
+
+    int index = lastQueryMessageResult.indexOf(id);
+    if (index != -1) {
+        // Preload based on result of last call to queryMessages
+        int count = 1;
+
+        QMailMessageIdList::const_iterator begin = lastQueryMessageResult.begin();
+        QMailMessageIdList::const_iterator end = lastQueryMessageResult.end();
+        QMailMessageIdList::const_iterator lowIt = begin + index;
+        QMailMessageIdList::const_iterator highIt = lowIt;
+
+        bool ascend(true);
+        bool descend(lowIt != begin);
+
+        while ((count < (QMailStorePrivate::lookAhead * 2)) && (ascend || descend)) {
+            if (ascend) {
+                ++highIt;
+                if (highIt == end) {
+                    ascend = false;
+                } else  {
+                    if (!headerCache.contains(*highIt)) {
+                        idBatch.append(*highIt);
+                        ++count;
+                    } else {
+                        // Most likely, a sequence in the other direction will be more useful
+                        ascend = false;
+                    }
+                }
+            }
+
+            if (descend) {
+                --lowIt;
+                if (!headerCache.contains(*lowIt)) {
+                    idBatch.prepend(*lowIt);
+                    ++count;
+
+                    if (lowIt == begin) {
+                        descend = false;
+                    }
+                } else {
+                    // Most likely, a sequence in the other direction will be more useful
+                    descend = false;
+                }
+            }
+        }
+    } else {
+        // Don't bother preloading - if there is a query result, we have now searched outside it;
+        // we should consider it to have outlived its usefulness
+        if (!lastQueryMessageResult.isEmpty())
+            lastQueryMessageResult = QMailMessageIdList();
+    }
+
+    QMailMessageMetaData result;
+    QMailMessageKey key(QMailMessageKey::id(idBatch));
+    foreach (const QMailMessageMetaData& metaData, messagesMetaData(key, allMessageProperties(), QMailStore::ReturnAll)) {
+        if (metaData.id().isValid()) {
+            headerCache.insert(metaData);
+            if (metaData.id() == id)
+                result = metaData;
+        }
+    }
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptStatusBit(const QString &name, const QString &context, 
+                                                                     int *result, 
+                                                                     ReadLock &)
+{
+    QSqlQuery query(simpleQuery("SELECT COALESCE(statusbit,0) FROM mailstatusflags WHERE name=? AND context=?",
+                                QVariantList() << name << context,
+                                "mailstatusflags select"));
+    if (query.lastError().type() != QSqlError::NoError)
+        return DatabaseFailure;
+
+    *result = 0;
+    if (query.next())
+        *result = extractValue<int>(query.value(0));
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRegisterStatusBit(const QString &name, const QString &context, int maximum, 
+                                                                             Transaction &t)
+{
+    int highest = 0;
+
+    {
+        // Find the highest 
+        QSqlQuery query(simpleQuery("SELECT MAX(statusbit) FROM mailstatusflags WHERE context=?",
+                                    QVariantList() << context,
+                                    "mailstatusflags register select"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        if (query.next())
+            highest = extractValue<int>(query.value(0));
+    }
+
+    if (highest == maximum) {
+        return Failure;
+    } else {
+        QSqlQuery query(simpleQuery("INSERT INTO mailstatusflags (name,context,statusbit) VALUES (?,?,?)",
+                                    QVariantList() << name << context << (highest + 1),
+                                    "mailstatusflags register insert"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Could not commit statusflag changes to database";
+        return DatabaseFailure;
+    }
+
+    return Success;
+}
+
+bool QMailStorePrivate::checkPreconditions(const QMailFolder& folder, bool update)
+{
+    //if the parent is valid, check that it exists 
+    //if the account is valid, check that is exists 
+
+    if(!update)
+    {
+        if(folder.id().isValid())
+        {
+            qMailLog(Messaging) << "Folder exists, use update instead of add.";
+            return false;
+        }
+    }
+    else 
+    {
+        if(!folder.id().isValid())
+        {
+            qMailLog(Messaging) << "Folder does not exist, use add instead of update.";
+            return false;
+        }
+
+        if(folder.parentFolderId().isValid() && folder.parentFolderId() == folder.id())
+        {
+            qMailLog(Messaging) << "A folder cannot be a child to itself";
+            return false;
+        }
+    }
+
+    if(folder.parentFolderId().isValid())
+    {
+        if(!idExists(folder.parentFolderId(),"mailfolders"))
+        {
+            qMailLog(Messaging) << "Parent folder does not exist!";
+            return false;
+        }
+    }
+
+    if(folder.parentAccountId().isValid())
+    {
+        if(!idExists(folder.parentAccountId(),"mailaccounts"))
+        {
+            qMailLog(Messaging) << "Parent account does not exist!";
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::deleteMessages(const QMailMessageKey& key, 
+                                       QMailStore::MessageRemovalOption option, 
+                                       QMailMessageIdList& deletedMessages, 
+                                       QStringList& expiredContent, 
+                                       QMailAccountIdList& modifiedAccounts, 
+                                       QMailFolderIdList& modifiedFolders)
+{
+    QString elements("id,mailfile,parentaccountid,parentfolderId");
+    if (option == QMailStore::CreateRemovalRecord)
+        elements += ",serveruid,previousparentfolderid";
+
+    QVariantList removalAccountIds;
+    QVariantList removalServerUids;
+    QVariantList removalFolderIds;
+
+    {
+        // Get the information we need to delete these messages
+        QSqlQuery query(simpleQuery(QString("SELECT %1 FROM mailmessages").arg(elements),
+                                    Key(key),
+                                    "deleteMessages info query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+
+        while (query.next()) {
+            QMailMessageId messageId(extractValue<quint64>(query.value(0)));
+            deletedMessages.append(messageId);
+            
+            QString contentUri(extractValue<QString>(query.value(1)));
+            if (!contentUri.isEmpty())
+                expiredContent.append(contentUri);
+
+            QMailAccountId parentAccountId(extractValue<quint64>(query.value(2)));
+            if (!modifiedAccounts.contains(parentAccountId))
+                modifiedAccounts.append(parentAccountId);
+
+            QMailFolderId folderId(extractValue<quint64>(query.value(3)));
+            if (!modifiedFolders.contains(folderId))
+                modifiedFolders.append(folderId);
+
+            if (option == QMailStore::CreateRemovalRecord) {
+                // Extract the info needed to create removal records
+                removalAccountIds.append(parentAccountId.toULongLong());
+                removalServerUids.append(extractValue<QString>(query.value(4)));
+                if (folderId == QMailFolderId(QMailFolder::TrashFolder)) {
+                    removalFolderIds.append(extractValue<quint64>(query.value(5)));
+                } else {
+                    removalFolderIds.append(folderId.toULongLong());
+                }
+            }
+        }
+    }
+
+    // No messages? Then we're already done
+    if (deletedMessages.isEmpty())
+        return true;
+
+    // Any ancestor folders of the directly modified folders are indirectly modified
+    QVariantList folderIdValues(idValueList(modifiedFolders));
+
+    if (!folderIdValues.isEmpty()) {
+        QString sql("SELECT DISTINCT id FROM mailfolderlinks WHERE descendantid IN %1");
+        QSqlQuery query(simpleQuery(sql.arg(expandValueList(folderIdValues)),
+                                    folderIdValues,
+                                    "deleteMessages mailfolderlinks ancestor query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+
+        while (query.next())
+            modifiedFolders.append(QMailFolderId(extractValue<quint64>(query.value(0))));
+    }
+
+    // Insert the removal records
+    if (!removalAccountIds.isEmpty()) {
+        // WARNING - QList::operator<<(QList) actually appends the list items to the object,
+        // rather than insert the actual list!
+        QSqlQuery query(batchQuery("INSERT INTO deletedmessages (parentaccountid,serveruid,parentfolderid) VALUES (?,?,?)",
+                                   QVariantList() << QVariant(removalAccountIds)
+                                                  << QVariant(removalServerUids)
+                                                  << QVariant(removalFolderIds),
+                                   "deleteMessages insert removal records query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    // Use the derived ID list rather than the key, in case the deletion statements affect the key result
+    QVariantList idValues(idValueList(deletedMessages));
+
+    {
+        // Delete any custom fields associated with these messages
+        QString sql("DELETE FROM mailmessagecustom");
+        QSqlQuery query(simpleQuery(sql, Key(QMailMessageKey::id(deletedMessages)),
+                                            "deleteMessages delete mailmessagecustom query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    {
+        // Perform the message deletion
+        QString sql("DELETE FROM mailmessages");
+        QSqlQuery query(simpleQuery(sql, Key(QMailMessageKey::id(deletedMessages)),
+                                    "deleteMessages delete mailmessages query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::deleteFolders(const QMailFolderKey& key, 
+                                      QMailStore::MessageRemovalOption option, 
+                                      QMailFolderIdList& deletedFolders, 
+                                      QMailMessageIdList& deletedMessages, 
+                                      QStringList& expiredContent, 
+                                      QMailAccountIdList& modifiedAccounts)
+{
+    {
+        // Get the identifiers for all the folders we're deleting
+        QSqlQuery query(simpleQuery("SELECT t0.id FROM mailfolders t0",
+                                    Key(key, "t0"),
+                                    "deleteFolders info query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+
+        while (query.next())
+            deletedFolders.append(QMailFolderId(extractValue<quint64>(query.value(0))));
+    }
+
+    // No folders? Then we're already done
+    if (deletedFolders.isEmpty()) 
+        return true;
+
+    // Create a key to select messages in the folders to be deleted
+    QMailMessageKey messagesKey(QMailMessageKey::parentFolderId(key));
+    
+    // We won't report the modified folders, since they're about to be deleted
+    QMailFolderIdList modifiedFolders;
+
+    // Delete all the messages contained by the folders we're deleting
+    if (!deleteMessages(messagesKey, option, deletedMessages, expiredContent, modifiedAccounts, modifiedFolders))
+        return false;
+    
+    // Delete any references to these folders in the mailfolderlinks table
+    QString statement("DELETE FROM mailfolderlinks WHERE %1 IN ( SELECT t0.id FROM mailfolders t0");
+    statement += buildWhereClause(Key(key, "t0")) + " )";
+
+    QVariantList whereValues(::whereClauseValues(key));
+
+    {
+        // Delete where target folders are ancestors
+        QSqlQuery query(simpleQuery(statement.arg("id"),
+                                    whereValues,
+                                    "deleteFolders mailfolderlinks ancestor query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    {
+        // Delete where target folders are descendants
+        QSqlQuery query(simpleQuery(statement.arg("descendantid"),
+                                    whereValues,
+                                    "deleteFolders mailfolderlinks descendant query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    // Use the derived ID list rather than the key, in case the deletion statements affect the key result
+    QVariantList idValues(idValueList(deletedFolders));
+
+    {
+        // Delete any custom fields associated with these folders
+        QString sql("DELETE FROM mailfoldercustom");
+        QSqlQuery query(simpleQuery(sql, Key(QMailFolderKey::id(deletedFolders)),
+                                    "deleteFolders delete mailfoldercustom query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    {
+        // Perform the folder deletion
+        QString sql("DELETE FROM mailfolders");
+        QSqlQuery query(simpleQuery(sql, Key(QMailFolderKey::id(deletedFolders)),
+                                    "deleteFolders delete mailfolders query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key, 
+                                       QMailAccountIdList& deletedAccounts, 
+                                       QMailFolderIdList& deletedFolders, 
+                                       QMailMessageIdList& deletedMessages, 
+                                       QStringList& expiredContent)
+{
+    {
+        // Get the identifiers for all the accounts we're deleting
+        QSqlQuery query(simpleQuery("SELECT t0.id FROM mailaccounts t0",
+                                    Key(key, "t0"),
+                                    "deleteAccounts info query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+
+        while (query.next())
+            deletedAccounts.append(QMailAccountId(extractValue<quint64>(query.value(0))));
+    }
+
+    // No accounts? Then we're already done
+    if (deletedAccounts.isEmpty()) 
+        return true;
+
+    // Create a key to select folders from the accounts to be deleted
+    QMailFolderKey foldersKey(QMailFolderKey::parentAccountId(key));
+    
+    // We won't create new message removal records, since there will be no account to link them to
+    QMailStore::MessageRemovalOption option(QMailStore::NoRemovalRecord);
+    QMailAccountIdList modifiedAccounts;
+
+    // Delete all the folders contained by the accounts we're deleting
+    if (!deleteFolders(foldersKey, option, deletedFolders, deletedMessages, expiredContent, modifiedAccounts))
+        return false;
+    
+    // Also delete any messages belonging to these accounts, that aren't in folders owned by the accounts
+
+    // Create a key to select messages for the accounts to be deleted
+    QMailMessageKey messagesKey(QMailMessageKey::parentAccountId(key));
+
+    // We won't report the modified folders, since they're about to be deleted
+    QMailFolderIdList modifiedFolders;
+
+    // Delete all the messages contained by the folders we're deleting
+    if (!deleteMessages(messagesKey, option, deletedMessages, expiredContent, modifiedAccounts, modifiedFolders))
+        return false;
+
+    QVariantList idValues(idValueList(deletedAccounts));
+        
+    {
+        // Delete the removal records related to these accounts
+        QString sql("DELETE FROM deletedmessages WHERE parentaccountid IN %1");
+        QSqlQuery query(simpleQuery(sql.arg(expandValueList(idValues)),
+                                    idValues,
+                                    "deleteAccounts removal record delete query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    {
+        // Remove any standard folders associated with these accounts
+        QString sql("DELETE FROM mailaccountfolders WHERE id IN %1");
+        QSqlQuery query(simpleQuery(sql.arg(expandValueList(idValues)),
+                                    idValues,
+                                    "deleteAccounts delete mailaccountfolders query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    {
+        // Remove any custom fields associated with these accounts
+        QString sql("DELETE FROM mailaccountcustom WHERE id IN %1");
+        QSqlQuery query(simpleQuery(sql.arg(expandValueList(idValues)),
+                                    idValues,
+                                    "deleteAccounts delete mailaccountcustom query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    {
+        // Remove any configuration fields associated with these accounts
+        QString sql("DELETE FROM mailaccountconfig WHERE id IN %1");
+        QSqlQuery query(simpleQuery(sql.arg(expandValueList(idValues)),
+                                    idValues,
+                                    "deleteAccounts delete mailaccountconfig query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    {
+        // Perform the account deletion
+        QString sql("DELETE FROM mailaccounts WHERE id IN %1");
+        QSqlQuery query(simpleQuery(sql.arg(expandValueList(idValues)),
+                                    idValues,
+                                    "deleteAccounts delete mailaccounts query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return false;
+    }
+
+    return true;
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const QString& descriptor)
+{
+    return performQuery(statement, false, QVariantList(), QList<Key>(), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const QVariantList& bindValues, const QString& descriptor)
+{
+    return performQuery(statement, false, bindValues, QList<Key>(), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const Key& key, const QString& descriptor)
+{
+    return performQuery(statement, false, QVariantList(), QList<Key>() << key, descriptor);
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const QVariantList& bindValues, const Key& key, const QString& descriptor)
+{
+    return performQuery(statement, false, bindValues, QList<Key>() << key, descriptor);
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor)
+{
+    return performQuery(statement, false, bindValues, keys, descriptor);
+}
+
+QSqlQuery QMailStorePrivate::batchQuery(const QString& statement, const QVariantList& bindValues, const QString& descriptor)
+{
+    return performQuery(statement, true, bindValues, QList<Key>(), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::batchQuery(const QString& statement, const QVariantList& bindValues, const Key& key, const QString& descriptor)
+{
+    return performQuery(statement, true, bindValues, QList<Key>() << key, descriptor);
+}
+
+QSqlQuery QMailStorePrivate::batchQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor)
+{
+    return performQuery(statement, true, bindValues, keys, descriptor);
+}
+
+QSqlQuery QMailStorePrivate::performQuery(const QString& statement, bool batch, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor)
+{
+    QString keyStatements;
+    QVariantList keyValues;
+
+    bool firstClause(true);
+    foreach (const Key &key, keys) {
+        if (key.isType<QMailMessageKey>() || key.isType<QMailFolderKey>() || key.isType<QMailAccountKey>()) {
+            keyStatements.append(buildWhereClause(key, false, firstClause));
+            keyValues << whereClauseValues(key);
+        } else if (key.isType<QMailMessageSortKey>() || key.isType<QMailFolderSortKey>() || key.isType<QMailAccountSortKey>()) {
+            keyStatements.append(buildOrderClause(key));
+        } else if (key.isType<QString>()) {
+            keyStatements.append(key.key<QString>());
+        }
+
+        firstClause = false;
+    }
+
+    QSqlQuery query(prepare(statement + keyStatements));
+    if (query.lastError().type() != QSqlError::NoError) {
+        qMailLog(Messaging) << "Could not prepare query" << descriptor;
+    } else {
+        foreach (const QVariant& value, bindValues)
+            query.addBindValue(value);
+        foreach (const QVariant& value, keyValues)
+            query.addBindValue(value);
+
+        if (!execute(query, batch)){
+            qMailLog(Messaging) << "Could not execute query" << descriptor;
+        }
+    }
+
+    return query;
+}
+
+void QMailStorePrivate::emitIpcNotification(QMailStoreImplementation::AccountUpdateSignal signal, const QMailAccountIdList &ids)
+{
+    if ((signal == &QMailStore::accountsUpdated) || (signal == &QMailStore::accountsRemoved)) {
+        foreach (const QMailAccountId &id, ids)
+            accountCache.remove(id);
+    }
+
+    QMailStoreImplementation::emitIpcNotification(signal, ids);
+}
+
+void QMailStorePrivate::emitIpcNotification(QMailStoreImplementation::FolderUpdateSignal signal, const QMailFolderIdList &ids)
+{
+    if ((signal == &QMailStore::foldersUpdated) || (signal == &QMailStore::foldersRemoved)) {
+        foreach (const QMailFolderId &id, ids)
+            folderCache.remove(id);
+    }
+
+    QMailStoreImplementation::emitIpcNotification(signal, ids);
+}
+
+void QMailStorePrivate::emitIpcNotification(QMailStoreImplementation::MessageUpdateSignal signal, const QMailMessageIdList &ids)
+{
+    if ((signal == &QMailStore::messagesUpdated) || (signal == &QMailStore::messagesRemoved)) {
+        foreach (const QMailMessageId &id, ids)
+            headerCache.remove(id);
+    }
+
+    QMailStoreImplementation::emitIpcNotification(signal, ids);
+}
+
+/* SPARQL Code */
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddMessage(QMailMessageMetaData *metaData,
+                                                                      QMailMessageIdList *addedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                      Transaction &t)
+{
+    Q_UNUSED(t);
+
+    if (!metaData->parentFolderId().isValid()) {
+        qMailLog(Messaging) << "Unable to add message. Invalid parent folder id";
+        return Failure;
+    }
+
+    SparqlUri uri("qmf://groove.harmattan.com/email#");
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT {\n"
+    "   <%1> rdf:type nmo:Email ;\n"
+    "        nie:isLogicalPartOf <qmf://groove.nokia.com/folder#%2> ;\n"
+    "        nmo:sender [\n"
+    "            rdf:type nco:Contact ;\n"
+    "            nco:fullname \"%3\" ; \n"
+    "            nco:hasEmailAddress <mailto:%4> ] ;\n"
+
+    + nmoRecipients(metaData->to()) +
+
+    "        nmo:messageSubject \"%5\" ;\n"
+    "        nmo:sentDate \"%6\"^^xsd:dateTime ;\n"
+    "        nmo:status \"%7\"^^xsd:integer ;\n"
+    "        nie:relatedTo <qmf://groove.nokia.com/accounts#%8> ;\n"
+    "        nie:isStoredAs [\n"
+    "            rdf:type nie:DataObject ;\n"
+    "            nie:dataSource <%9> ] ;\n"
+    "        nmo:messageId <%10> ;\n"
+    "        nie:contentSize \"%11\"^^xsd:integer ;\n"
+    "        nie:mimeType \"%12\" ;\n"
+    "        nmo:inReplyTo <%13> ;\n"
+    "        nmo:messageHeader [\n"
+    "            rdf:type nmo:MessageHeader ;\n"
+    "            nmo:headerName \"responseType\" ;\n"
+    "            nmo:headerValue \"%14\" ] ;\n"
+    "        nmo:receivedDate \"%15\"^^xsd:dateTime .\n"
+    "}").arg(uri.uri())
+        .arg(metaData->parentFolderId().toULongLong())
+        .arg(metaData->from().name())
+        .arg(metaData->from().address())
+        .arg(metaData->subject())
+        .arg(QMailTimeStamp(metaData->date()).toLocalTime().toString())
+        .arg(static_cast<int>(metaData->status()))
+        .arg(metaData->parentAccountId().toULongLong())
+        .arg(::contentUri(*metaData))
+        .arg(metaData->serverUid())
+        .arg(metaData->size())
+        .arg(static_cast<int>(metaData->content()))
+        .arg(metaData->inResponseTo().toULongLong())
+        .arg(metaData->responseType())
+        .arg(QMailTimeStamp(metaData->receivedDate()).toLocalTime().toString()));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    qDebug() << "Query succeeded";
+    metaData->setId(QMailMessageId(uri.id()));
+
+    addedMessageIds->append(metaData->id());
+    *modifiedFolderIds = QMailFolderIdList() << metaData->parentFolderId();
+    if (metaData->parentAccountId().isValid())
+        modifiedAccountIds->append(metaData->parentAccountId());
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddFolder(QMailFolder *folder,
+                                                                     QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                     Transaction &t)
+{
+    Q_UNUSED(t);
+
+    //check that the parent folder actually exists
+    if (!checkPreconditions(*folder))
+        return Failure;
+
+    SparqlUri uri("qmf://groove.nokia.com/folder#");
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "<%1> rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName \"%2\" ; \n"
+    "   nie:isLogicalPartOf <qmf://groove.nokia.com/folder#%3> ; \n"
+    "   nie:relatedTo <qmf://groove.nokia.com/accounts#%4> ; \n"
+    "   nmo:folderDisplayName \"%5\" ; \n"
+    "   nmo:status \"%6\"^^xsd:integer ; \n"
+    "   nmo:serverCount \"%7\"^^xsd:integer ; \n"
+    "   nmo:serverUnreadCount \"%8\"^^xsd:integet . \n"
+    "}").arg(uri.uri())
+        .arg(folder->path())
+        .arg(folder->parentFolderId().toULongLong())
+        .arg(folder->parentAccountId().toULongLong())
+        .arg(folder->displayName())
+        .arg(folder->status())
+        .arg(folder->serverCount())
+        .arg(folder->serverUnreadCount()));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    qDebug() << "Query succeeded";
+    folder->setId(QMailFolderId(uri.id()));
+
+    // TBD: Update folder links also
+
+    addedFolderIds->append(folder->id());
+    if (folder->parentAccountId().isValid())
+        modifiedAccountIds->append(folder->parentAccountId());
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config,
+                                                                      QMailAccountIdList *addedAccountIds,
+                                                                      Transaction &t)
+{
+    Q_UNUSED(t);
+
+    SparqlUri uri("qmf://groove.nokia.com/accounts#");
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "<%1> rdf:type nmo:Mailbox ; \n"
+    "   nmo:accountName \"%2\" ; \n"
+    "   nmo:status \"%3\"^^xsd:integer ; \n"
+    "   nmo:signature \"%4\" ; \n"
+    "   nmo:fromAddress [ \n"
+    "       rdf:type nco:EmailAddress ; \n"
+    "       nco:emailAddress \"%5\" ] . \n"
+    "}").arg(uri.uri())
+        .arg(account->name())
+        .arg(account->status())
+        .arg(account->signature())
+        .arg(account->fromAddress().toString(true)));
+
+    // TBD: Add custom fields later
+    // TBD: Add account configuration
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    qDebug() << "Query succeeded";
+    account->setId(QMailAccountId(uri.id()));
+
+    addedAccountIds->append(account->id());
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAccountId &id,
+                                                                   QMailAccount *result,
+                                                                   ReadLock &)
+{
+    QMailAccount account;
+
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?name ?signature ?fromAddress \n"
+    "WHERE { \n"
+    "<qmf://groove.nokia.com/accounts#%1> rdf:type nmo:Mailbox ; \n"
+    "   nmo:accountName ?name ; \n"
+//    "   nmo:status ?status ; \n"
+    "   nmo:signature ?signature ; \n"
+    "   nmo:fromAddress [ \n"
+    "       rdf:type nco:EmailAddress ; \n"
+    "       nco:emailAddress ?fromAddress ] . \n"
+    "}").arg(id.toULongLong()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    Q_ASSERT(!res.end());
+
+    QStringList list = res.fetchRow();
+
+    account.setId(id);
+    account.setName(list.at(0));
+//  account.setStatus(list.at(1).toULongLong());
+    account.setSignature(list.at(1));
+    account.setFromAddress(QMailAddress(list.at(2)));
+
+    *result = account;
+
+    // Update cache
+    accountCache.insert(*result);
+    return Success;
+}
+
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptFolder(const QMailFolderId &id,
+                                                                  QMailFolder *result,
+                                                                  ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?name ?parentFolder ?parentAccount ?displayName \n"
+    "WHERE { \n"
+    "<qmf://groove.nokia.com/folder#%1> rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName ?name ; \n"
+    "   nie:isLogicalPartOf ?parentFolder ; \n"
+    "   nie:relatedTo ?parentAccount ; \n"
+    "   nmo:folderDisplayName ?displayName ; \n"
+//    "   nmo:status ?status ; \n"
+//    "   nmo:serverCount ?serverCount ; \n"
+//    "   nmo:serverUnreadCount ?serverUnreadCount . \n"
+    "}").arg(id.toULongLong()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    Q_ASSERT(!res.end());
+
+    QStringList list = res.fetchRow();
+
+    QMailFolder folder(list.at(0), IdFromUri<QMailFolderId>(list.at(1)), IdFromUri<QMailAccountId>(list.at(2)));
+    folder.setId(id);
+    folder.setDisplayName(list.at(3));
+//    folder.setStatus(list.at(4).toULongLong());
+//    folder.setServerCount(list.at(5).toUInt());
+//    folder.setServerUnreadCount(list.at(6).toUInt());
+
+    *result = folder;
+
+    //update cache
+    folderCache.insert(*result);
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessage(const QMailMessageId &id,
+                                                                   QMailMessage *result,
+                                                                   ReadLock &)
+{
+    if (!id.isValid())
+        return Failure;
+
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?fullName ?mailAddress \n"
+    "WHERE { \n"
+    "<qmf://groove.harmattan.com/email#%1> rdf:type nmo:Email ;\n"
+    "nmo:recipient [\n"
+    "    rdf:type nco:Contact ;\n"
+    "    nco:fullname ?fullName ; \n"
+    "    nco:hasEmailAddress ?mailAddress ] \n"
+    "}").arg(id.toULongLong()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    QList<QMailAddress> recipients;
+    while (!res.end())
+    {
+        QStringList row = res.fetchRow();
+        recipients.push_back(QMailAddress(row.at(0), row.at(1)));
+    }
+
+    query.prepare(QString(
+    "SELECT ?folderId ?senderFullName ?senderEmailAddress ?messageSubject ?sentDate ?status ?accountId ?dataSource ?uid ?contentSize ?mimeType ?inReplyTo ?headerValue ?receivedDate \n"
+    "WHERE { \n"
+    "   <qmf://groove.harmattan.com/email#%1> rdf:type nmo:Email ;\n"
+    "        nie:isLogicalPartOf ?folderId ;\n"
+    "        nmo:sender [\n"
+    "            rdf:type nco:Contact ;\n"
+    "            nco:fullname ?senderFullName ; \n"
+    "            nco:hasEmailAddress ?senderEmailAddress ] ;\n"
+    "        nmo:messageSubject ?messageSubject ;\n"
+    "        nmo:sentDate ?sentDate ;\n"
+    "        nmo:status ?status ;\n"
+    "        nie:relatedTo ?accountId ;\n"
+    "        nie:isStoredAs [\n"
+    "            rdf:type nie:DataObject ;\n"
+    "            nie:dataSource ?dataSource ] ;\n"
+    "        nmo:messageId ?uid ;\n"
+    "        nie:contentSize ?contentSize ;\n"
+    "        nie:mimeType ?mimeType ;\n"
+    "        nmo:inReplyTo ?inReplyTo ;\n"
+    "        nmo:messageHeader [\n"
+    "            rdf:type nmo:MessageHeader ;\n"
+    "            nmo:headerName \"responseType\" ;\n"
+    "            nmo:headerValue ?headerValue ] ;\n"
+    "        nmo:receivedDate ?receivedDate .\n"
+    "}").arg(id.toULongLong()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    res = query.result();
+
+    Q_ASSERT(!res.end());
+
+    QStringList list = res.fetchRow();
+
+    QMailMessage message;
+    message.setId(id);
+    message.setParentFolderId(IdFromUri<QMailFolderId>(list.at(0)));
+    message.setFrom(QMailAddress(list.at(1), list.at(2)));
+    message.setSubject(list.at(3));
+    message.setDate(QMailTimeStamp(list.at(4)));
+    message.setStatus(list.at(5).toULongLong());
+    message.setParentAccountId(IdFromUri<QMailAccountId>(list.at(6)));
+    message.setServerUid(list.at(10));
+    message.setSize(list.at(9).toUInt());
+    message.setContent((QMailMessageMetaDataFwd::ContentType)list.at(10).toInt());
+    message.setInResponseTo(QMailMessageId(IdFromUri<QMailMessageId>(list.at(11))));
+    message.setResponseType((QMailMessageMetaDataFwd::ResponseType)list.at(12).toInt());
+    message.setReceivedDate(QMailTimeStamp(list.at(13)));
+
+    message.setTo(recipients);
+
+    *result = message;
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey,
+                                                                         QMailAccountIdList *ids,
+                                                                         ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?account \n"
+    "WHERE { \n"
+    "   ?account rdf:type nmo:Mailbox . \n"
+    + accountConstraint("?account", key) +
+    "} \n"));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult result = query.result();
+
+    ids->clear();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        ids->append(IdFromUri<QMailAccountId>(row.first()));
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey,
+                                                                        QMailFolderIdList *ids,
+                                                                        ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?folder \n"
+    "WHERE { \n"
+    "   ?folder rdf:type nmo:MailFolder . \n"
+    + folderConstraint("?folder", key) +
+    "} \n"));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult result = query.result();
+
+    ids->clear();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        ids->append(IdFromUri<QMailFolderId>(row.first()));
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey,
+                                                                         QMailMessageIdList *ids,
+                                                                         ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?message \n"
+    "WHERE { \n"
+    "   ?message rdf:type nmo:Email . \n"
+    + messageConstraint("?message", key) +
+    "} \n"));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult result = query.result();
+
+    ids->clear();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        ids->append(IdFromUri<QMailMessageId>(row.first()));
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountAccounts(const QMailAccountKey &key, int *result,
+                                                                         ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT COUNT(?accountId) AS count \n"
+    "WHERE { \n"
+    "   ?accountId rdf:type nmo:Mailbox . \n"
+    + accountConstraint("?accountId", key) +
+    "} \n"));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    Q_ASSERT(!res.end());
+
+    *result = res.fetchRow().first().toInt();
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountFolders(const QMailFolderKey &key, int *result,
+                                                                        ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT COUNT(?folderId) AS count \n"
+    "WHERE { \n"
+    "   ?folderId rdf:type nmo:MailFolder . \n"
+    + folderConstraint("?folderId", key) +
+    "} \n"));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    Q_ASSERT(!res.end());
+
+    *result = res.fetchRow().first().toInt();
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountMessages(const QMailMessageKey &key,
+                                                                         int *result,
+                                                                         ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT COUNT(?emailId) AS count \n"
+    "WHERE { \n"
+    "   ?emailId rdf:type nmo:Email . \n"
+    + messageConstraint("?emailId", key) +
+    "} \n"));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    Q_ASSERT(!res.end());
+
+    *result = res.fetchRow().first().toInt();
+
+    return Success;
+}
diff --git a/src/libraries/qtopiamail/qmailstore_sparql.h b/src/libraries/qtopiamail/qmailstore_sparql.h
new file mode 100644
index 0000000..e7ec13a
--- /dev/null
+++ b/src/libraries/qtopiamail/qmailstore_sparql.h
@@ -0,0 +1,530 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMAILSTORE_P_H
+#define QMAILSTORE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt Extended API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qmailstoreimplementation_p.h"
+#include "sparqldatabase.h"
+
+#include <QSqlDatabase>
+#include <QCache>
+
+//#define QMAILSTORE_LOG_SQL //define to enable SQL query logging
+//#define QMAILSTORE_USE_RTTI //define if RTTI is available to assist debugging
+
+#ifdef QMAILSTORE_USE_RTTI
+#include <typeinfo>
+#endif
+
+class ProcessMutex;
+class ProcessReadLock;
+
+
+class QMailStorePrivate : public QMailStoreImplementation
+{
+    Q_OBJECT
+
+public:
+    typedef QMap<QMailMessageKey::Property, QString> MessagePropertyMap;
+    typedef QList<QMailMessageKey::Property> MessagePropertyList;
+
+    class Transaction;
+    class ReadLock;
+    class Key;
+
+    struct ReadAccess {};
+    struct WriteAccess {};
+
+    QMailStorePrivate(QMailStore* parent);
+    ~QMailStorePrivate();
+
+    virtual bool initStore();
+    void clearContent();
+
+    bool addAccount(QMailAccount *account, QMailAccountConfiguration *config,
+                    QMailAccountIdList *addedAccountIds);
+
+    bool addFolder(QMailFolder *f,
+                   QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool addMessage(QMailMessage *m,
+                    QMailMessageIdList *addedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool addMessage(QMailMessageMetaData *m,
+                    QMailMessageIdList *addedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool removeAccounts(const QMailAccountKey &key,
+                        QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages);
+
+    bool removeFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option,
+                       QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts);
+
+    bool removeMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option,
+                        QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts, QMailFolderIdList *modifiedFolders);
+
+    bool updateAccount(QMailAccount *account, QMailAccountConfiguration* config,
+                       QMailAccountIdList *updatedAccountIds);
+
+    bool updateAccountConfiguration(QMailAccountConfiguration* config,
+                                    QMailAccountIdList *updatedAccountIds);
+
+    bool updateFolder(QMailFolder* f,
+                      QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool updateMessage(QMailMessageMetaData *metaData, QMailMessage *mail,
+                       QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, bool *modifiedContent);
+
+    bool updateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, const QMailMessageMetaData &data,
+                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool updateMessagesMetaData(const QMailMessageKey &key, quint64 messageStatus, bool set,
+                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool restoreToPreviousFolder(const QMailMessageKey &key,
+                                 QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool purgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids);
+
+    int countAccounts(const QMailAccountKey &key) const;
+    int countFolders(const QMailFolderKey &key) const;
+    int countMessages(const QMailMessageKey &key) const;
+
+    int sizeOfMessages(const QMailMessageKey &key) const;
+
+    QMailAccountIdList queryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey) const;
+    QMailFolderIdList queryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey) const;
+    QMailMessageIdList queryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey) const;
+
+    QMailAccount account(const QMailAccountId &id) const;
+    QMailAccountConfiguration accountConfiguration(const QMailAccountId &id) const;
+
+    QMailFolder folder(const QMailFolderId &id) const;
+
+    QMailMessage message(const QMailMessageId &id) const;
+    QMailMessage message(const QString &uid, const QMailAccountId &accountId) const;
+
+    QMailMessageMetaData messageMetaData(const QMailMessageId &id) const;
+    QMailMessageMetaData messageMetaData(const QString &uid, const QMailAccountId &accountId) const;
+    QMailMessageMetaDataList messagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option) const;
+
+    QMailMessageRemovalRecordList messageRemovalRecords(const QMailAccountId &parentAccountId, const QMailFolderId &parentFolderId) const;
+
+    bool registerAccountStatusFlag(const QString &name);
+    quint64 accountStatusMask(const QString &name) const;
+
+    bool registerFolderStatusFlag(const QString &name);
+    quint64 folderStatusMask(const QString &name) const;
+
+    bool registerMessageStatusFlag(const QString &name);
+    quint64 messageStatusMask(const QString &name) const;
+
+    QString buildOrderClause(const Key& key) const;
+
+    QString buildWhereClause(const Key& key, bool nested = false, bool firstClause = true) const;
+    QVariantList whereClauseValues(const Key& key) const;
+
+    static QString expandValueList(const QVariantList& valueList);
+    static QString expandValueList(int valueCount);
+
+    static QString temporaryTableName(const QMailMessageKey &key);
+
+    template<typename ValueType>
+    static ValueType extractValue(const QVariant& var, const ValueType &defaultValue = ValueType());
+
+private:
+    friend class Transaction;
+    friend class ReadLock;
+
+    enum AttemptResult { Success = 0, Failure, DatabaseFailure };
+    
+    static ProcessMutex& contentManagerMutex(void);
+
+    ProcessMutex& databaseMutex(void) const;
+    ProcessReadLock& databaseReadLock(void) const;
+
+    static const MessagePropertyMap& messagePropertyMap();
+    static const MessagePropertyList& messagePropertyList();
+
+    static const QMailMessageKey::Properties &updatableMessageProperties();
+    static const QMailMessageKey::Properties &allMessageProperties();
+
+    bool containsProperty(const QMailMessageKey::Property& p, const QMailMessageKey& key) const;
+    bool containsProperty(const QMailMessageSortKey::Property& p, const QMailMessageSortKey& sortkey) const;
+
+    QString expandProperties(const QMailMessageKey::Properties& p, bool update = false) const;
+
+    int databaseIdentifier(int n) const;
+
+    bool ensureVersionInfo();
+    qint64 tableVersion(const QString &name) const;
+    bool setTableVersion(const QString &name, qint64 version);
+
+    qint64 incrementTableVersion(const QString &name, qint64 current);
+    bool upgradeTableVersion(const QString &name, qint64 current, qint64 final);
+
+    bool createTable(const QString &name);
+
+    typedef QPair<QString, qint64> TableInfo;
+    bool setupTables(const QList<TableInfo> &tableList);
+
+    typedef QPair<quint64, QString> FolderInfo;
+    bool setupFolders(const QList<FolderInfo> &folderList);
+
+    void createTemporaryTable(const QMailMessageKey &key) const;
+    void destroyTemporaryTables(void);
+
+    bool transaction(void);
+    bool commit(void);
+    void rollback(void);
+
+    void setQueryError(const QSqlError&, const QString& description = QString(), const QString& statement = QString());
+    void clearQueryError(void);
+
+    QSqlQuery prepare(const QString& sql);
+    bool execute(QSqlQuery& q, bool batch = false);
+    int queryError(void) const;
+
+    QSqlQuery performQuery(const QString& statement, bool batch, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor);
+
+    bool executeFile(QFile &file);
+
+    QSqlQuery simpleQuery(const QString& statement, const QString& descriptor);
+    QSqlQuery simpleQuery(const QString& statement, const QVariantList& bindValues, const QString& descriptor);
+
+    QSqlQuery simpleQuery(const QString& statement, const Key& key, const QString& descriptor);
+    QSqlQuery simpleQuery(const QString& statement, const QVariantList& bindValues, const Key& key, const QString& descriptor);
+    QSqlQuery simpleQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor);
+
+    QSqlQuery batchQuery(const QString& statement, const QVariantList& bindValues, const QString& descriptor);
+    QSqlQuery batchQuery(const QString& statement, const QVariantList& bindValues, const Key& key, const QString& descriptor);
+    QSqlQuery batchQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor);
+
+    bool idValueExists(quint64 id, const QString& table);
+
+    bool idExists(const QMailAccountId& id, const QString& table = QString());
+    bool idExists(const QMailFolderId& id, const QString& table = QString());
+    bool idExists(const QMailMessageId& id, const QString& table = QString());
+
+    bool checkPreconditions(const QMailFolder& folder, bool update = false);
+
+    void preloadHeaderCache(const QMailMessageId& id) const;
+
+    QMailFolderIdList folderAncestorIds(const QMailFolderIdList& ids, bool inTransaction, AttemptResult *result) const;
+
+    quint64 queryStatusMap(const QString &name, const QString &context, QMap<QString, quint64> &map) const;
+
+    bool deleteMessages(const QMailMessageKey& key,
+                        QMailStore::MessageRemovalOption option,
+                        QMailMessageIdList& deletedMessageIds,
+                        QStringList& expiredMailfiles,
+                        QMailAccountIdList& modifiedAccounts,
+                        QMailFolderIdList& modifiedFolders);
+
+    bool deleteFolders(const QMailFolderKey& key,
+                       QMailStore::MessageRemovalOption option,
+                       QMailFolderIdList& deletedFolders,
+                       QMailMessageIdList& deletedMessageIds,
+                       QStringList& expiredMailfiles,
+                       QMailAccountIdList& modifiedAccounts);
+
+    bool deleteAccounts(const QMailAccountKey& key,
+                        QMailAccountIdList& deletedAccounts,
+                        QMailFolderIdList& deletedFolders,
+                        QMailMessageIdList& deletedMessageIds,
+                        QStringList& expiredMailfile);
+
+    void removeExpiredData(const QMailMessageIdList& messageIds,
+                           const QStringList& mailfiles,
+                           const QMailFolderIdList& folderIds = QMailFolderIdList(),
+                           const QMailAccountIdList& accountIds = QMailAccountIdList());
+
+    template<typename AccessType, typename FunctionType>
+    bool repeatedly(FunctionType func, const QString &description) const;
+
+    AttemptResult addCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
+    AttemptResult updateCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
+    AttemptResult customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName);
+
+    AttemptResult attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config, 
+                                    QMailAccountIdList *addedAccountIds, 
+                                    Transaction &t);
+
+    AttemptResult attemptAddFolder(QMailFolder *folder, 
+                                   QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                   Transaction &t);
+
+    AttemptResult attemptAddMessage(QMailMessageMetaData *metaData,
+                                    QMailMessageIdList *addedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                    Transaction &t);
+
+    AttemptResult attemptRemoveAccounts(const QMailAccountKey &key, 
+                                        QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages,
+                                        Transaction &t);
+
+    AttemptResult attemptRemoveFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option, 
+                                       QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts,
+                                       Transaction &t);
+
+    AttemptResult attemptRemoveMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option, 
+                                        QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts, QMailFolderIdList *modifiedFolders,
+                                        Transaction &t);
+
+    AttemptResult attemptUpdateAccount(QMailAccount *account, QMailAccountConfiguration *config, 
+                                       QMailAccountIdList *updatedAccountIds,
+                                       Transaction &t);
+
+    AttemptResult attemptUpdateAccountConfiguration(QMailAccountConfiguration *config, 
+                                                    QMailAccountIdList *updatedAccountIds,
+                                                    Transaction &t);
+
+    AttemptResult attemptUpdateFolder(QMailFolder *folder, 
+                                      QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                      Transaction &t);
+
+    AttemptResult attemptUpdateMessage(QMailMessageMetaData *metaData, QMailMessage *mail, 
+                                       QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, bool *modifiedContent,
+                                       Transaction &t);
+
+    AttemptResult affectedByMessageIds(const QMailMessageIdList &messages, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const;
+
+    AttemptResult affectedByFolderIds(const QMailFolderIdList &folders, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const;
+
+    AttemptResult attemptUpdateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &props, const QMailMessageMetaData &data, 
+                                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                Transaction &t); 
+
+    AttemptResult attemptUpdateMessagesStatus(const QMailMessageKey &key, quint64 status, bool set, 
+                                              QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                              Transaction &t);
+
+    AttemptResult attemptRestoreToPreviousFolder(const QMailMessageKey &key, 
+                                                 QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                 Transaction &t);
+
+    AttemptResult attemptPurgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids,
+                                                    Transaction &t);
+
+    AttemptResult attemptCountAccounts(const QMailAccountKey &key, int *result, 
+                                       ReadLock &);
+
+    AttemptResult attemptCountFolders(const QMailFolderKey &key, int *result, 
+                                      ReadLock &);
+
+    AttemptResult attemptCountMessages(const QMailMessageKey &key, 
+                                       int *result, 
+                                       ReadLock &);
+
+    AttemptResult attemptSizeOfMessages(const QMailMessageKey &key, 
+                                        int *result, 
+                                        ReadLock &);
+
+    AttemptResult attemptQueryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey, 
+                                       QMailAccountIdList *ids, 
+                                       ReadLock &);
+
+    AttemptResult attemptQueryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey, 
+                                      QMailFolderIdList *ids, 
+                                      ReadLock &);
+
+    AttemptResult attemptQueryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey,
+                                       QMailMessageIdList *ids, 
+                                       ReadLock &);
+
+    AttemptResult attemptAccount(const QMailAccountId &id, 
+                                 QMailAccount *result, 
+                                 ReadLock &);
+
+    AttemptResult attemptAccountConfiguration(const QMailAccountId &id, 
+                                              QMailAccountConfiguration *result, 
+                                              ReadLock &);
+
+    AttemptResult attemptFolder(const QMailFolderId &id, 
+                                QMailFolder *result, 
+                                ReadLock &);
+
+    AttemptResult attemptMessage(const QMailMessageId &id, 
+                                 QMailMessage *result, 
+                                 ReadLock &);
+
+    AttemptResult attemptMessage(const QString &uid, const QMailAccountId &accountId, 
+                                 QMailMessage *result, 
+                                 ReadLock &);
+
+    AttemptResult attemptMessagesMetaData(const QMailMessageKey& key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option, 
+                                          QMailMessageMetaDataList *result, 
+                                          ReadLock &);
+
+    AttemptResult attemptMessageRemovalRecords(const QMailAccountId &accountId, const QMailFolderId &parentFolderId, 
+                                               QMailMessageRemovalRecordList *result,
+                                               ReadLock &);
+
+    AttemptResult attemptMessageFolderIds(const QMailMessageKey &key, 
+                                          QMailFolderIdList *result, 
+                                          ReadLock &);
+
+    AttemptResult attemptFolderAccountIds(const QMailFolderKey &key, 
+                                          QMailAccountIdList *result, 
+                                          ReadLock &);
+
+    AttemptResult attemptFolderAncestorIds(const QMailFolderIdList &ids, 
+                                           QMailFolderIdList *result, 
+                                           ReadLock &);
+
+    AttemptResult attemptStatusBit(const QString &name, const QString &context, 
+                                   int *result, 
+                                   ReadLock &);
+
+    AttemptResult attemptRegisterStatusBit(const QString &name, const QString &context, int maximum, 
+                                           Transaction &t);
+
+    QMailAccount extractAccount(const QSqlRecord& r);
+    QMailFolder extractFolder(const QSqlRecord& r);
+    QMailMessageMetaData extractMessageMetaData(const QSqlRecord& r, QMailMessageKey::Properties recordProperties, const QMailMessageKey::Properties& properties = allMessageProperties());
+    QMailMessage extractMessage(const QSqlRecord& r, const QMap<QString, QString> &customFields, const QMailMessageKey::Properties& properties = allMessageProperties());
+    QMailMessageRemovalRecord extractMessageRemovalRecord(const QSqlRecord& r);
+
+    virtual void emitIpcNotification(QMailStoreImplementation::AccountUpdateSignal signal, const QMailAccountIdList &ids);
+    virtual void emitIpcNotification(QMailStoreImplementation::FolderUpdateSignal signal, const QMailFolderIdList &ids);
+    virtual void emitIpcNotification(QMailStoreImplementation::MessageUpdateSignal signal, const QMailMessageIdList &ids);
+
+    static const int headerCacheSize = 100;
+    static const int folderCacheSize = 10;
+    static const int accountCacheSize = 10;
+    static const int lookAhead = 5;
+
+    static QString parseSql(QTextStream& ts);
+
+    static QVariantList messageValues(const QMailMessageKey::Properties& properties, const QMailMessageMetaData& data);
+    static void updateMessageValues(const QMailMessageKey::Properties& properties, const QVariantList& values, const QMap<QString, QString>& customFields, QMailMessageMetaData& metaData);
+
+    static const QString &defaultContentScheme();
+    static const QString &messagesBodyPath();
+    static QString messageFilePath(const QString &fileName);
+    static int pathIdentifier(const QString &filePath);
+
+    static void extractMessageMetaData(const QSqlRecord& r, QMailMessageKey::Properties recordProperties, const QMailMessageKey::Properties& properties, QMailMessageMetaData* metaData);
+
+private:
+    template <typename T, typename ID> 
+    class Cache
+    {
+    public:
+        Cache(unsigned int size = 10);
+        ~Cache();
+
+        T lookup(const ID& id) const;
+        void insert(const T& item);
+        bool contains(const ID& id) const;
+        void remove(const ID& id);
+        void clear();
+
+    private:
+        QCache<quint64,T> mCache;
+    };
+
+    mutable QSqlDatabase database;
+    
+    mutable QMailMessageIdList lastQueryMessageResult;
+
+    mutable Cache<QMailMessageMetaData, QMailMessageId> headerCache;
+    mutable Cache<QMailFolder, QMailFolderId> folderCache;
+    mutable Cache<QMailAccount, QMailAccountId> accountCache;
+
+    mutable QList<const QMailMessageKey*> requiredTableKeys;
+    mutable QList<const QMailMessageKey*> temporaryTableKeys;
+    QList<const QMailMessageKey*> expiredTableKeys;
+
+    bool inTransaction;
+    mutable int lastQueryError;
+
+    ProcessMutex *mutex;
+    ProcessReadLock *readLock;
+
+    static ProcessMutex *contentMutex;
+
+    SparqlDatabase sparqlDatabase;
+};
+
+template <typename ValueType>
+ValueType QMailStorePrivate::extractValue(const QVariant &var, const ValueType &defaultValue)
+{
+    if (!qVariantCanConvert<ValueType>(var)) {
+        qWarning() << "QMailStorePrivate::extractValue - Cannot convert variant to:"
+#ifdef QMAILSTORE_USE_RTTI
+                   << typeid(ValueType).name();
+#else
+                   << "requested type";
+#endif
+        return defaultValue;
+    }
+
+    return qVariantValue<ValueType>(var);
+}
+
+
+template <typename T, typename ID> 
+QMailStorePrivate::Cache<T, ID>::Cache(unsigned int cacheSize)
+    : mCache(cacheSize)
+{
+}
+
+template <typename T, typename ID> 
+QMailStorePrivate::Cache<T, ID>::~Cache()
+{
+}
+
+template <typename T, typename ID> 
+T QMailStorePrivate::Cache<T, ID>::lookup(const ID& id) const
+{
+    if (id.isValid())
+        if (T* cachedItem = mCache.object(id.toULongLong()))
+            return *cachedItem;
+
+    return T();
+}
+
+template <typename T, typename ID> 
+void QMailStorePrivate::Cache<T, ID>::insert(const T& item)
+{
+    if (item.id().isValid())
+        mCache.insert(item.id().toULongLong(),new T(item));
+}
+
+template <typename T, typename ID> 
+bool QMailStorePrivate::Cache<T, ID>::contains(const ID& id) const
+{
+    return mCache.contains(id.toULongLong());
+}
+
+template <typename T, typename ID> 
+void QMailStorePrivate::Cache<T, ID>::remove(const ID& id)
+{
+    mCache.remove(id.toULongLong());
+}
+
+template <typename T, typename ID> 
+void QMailStorePrivate::Cache<T, ID>::clear()
+{
+    mCache.clear();
+}
+
+#endif
diff --git a/src/libraries/qtopiamail/qtopiamail.pro b/src/libraries/qtopiamail/qtopiamail.pro
index c715160..069f2cd 100644
--- a/src/libraries/qtopiamail/qtopiamail.pro
+++ b/src/libraries/qtopiamail/qtopiamail.pro
@@ -1,17 +1,35 @@
 TEMPLATE = lib 
 
 TARGET = qtopiamail
-target.path += $$QMF_INSTALL_ROOT/lib 
-INSTALLS += target
 
 DEFINES += QT_BUILD_QCOP_LIB
 
 QT *= sql network
 
-CONFIG += warn_on
+CONFIG += warn_on create_pc create_prl
 
 INCLUDEPATH += support
 
+sparql {
+
+DEFINES += SPARQL_STORE
+
+HEADERS += qmailstore_sparql.h
+
+SOURCES += qmailstore_sparql.cpp
+
+INCLUDEPATH += ../sparql ../sparql/tracker
+
+LIBS += -L../sparql -lsparql
+
+} else {
+
+HEADERS += qmailstore_p.h
+
+SOURCES += qmailstore_p.cpp
+
+}
+
 HEADERS += bind_p.h \
            longstream_p.h \
            longstring_p.h \
@@ -46,12 +64,11 @@ HEADERS += bind_p.h \
            qmailmessagesortkey_p.h \
            qmailserviceaction.h \
            qmailstore.h \
-           qmailstore_p.h \
+           semaphore_p.h \
            qmailstoreimplementation_p.h \
            qmailtimestamp.h \
            qprivateimplementation.h \
            qprivateimplementationdef.h \
-           semaphore_p.h \
            support/qmailglobal.h \
            support/qmaillog.h \
            support/qmailnamespace.h \
@@ -62,7 +79,8 @@ HEADERS += bind_p.h \
            support/qcopchannelmonitor.h \
            support/qcopserver.h \
            support/qmailpluginmanager.h \
-           support/qringbuffer_p.h
+           support/qringbuffer_p.h \
+           support/qmailipc.h
 
 SOURCES += longstream.cpp \
            longstring.cpp \
@@ -90,7 +108,6 @@ SOURCES += longstream.cpp \
            qmailmessagesortkey.cpp \
            qmailserviceaction.cpp \
            qmailstore.cpp \
-           qmailstore_p.cpp \
            qmailstoreimplementation_p.cpp \
            qmailtimestamp.cpp \
            qprivateimplementation.cpp \
@@ -120,3 +137,19 @@ TRANSLATIONS += libqtopiamail-ar.ts \
                 libqtopiamail-pt_BR.ts \
                 libqtopiamail-zh_CN.ts \
                 libqtopiamail-zh_TW.ts
+
+
+target.path += $$QMF_INSTALL_ROOT/lib 
+INSTALLS += target
+
+# Install headers
+headers.files = $$HEADERS include/*
+headers.path  = $$QMF_INSTALL_ROOT/include/qmf
+
+INSTALLS += headers 
+
+# Install pkgconfig file
+QMAKE_PKGCONFIG_LIBDIR  = $$target.path
+QMAKE_PKGCONFIG_INCDIR  = $$headers.path
+QMAKE_PKGCONFIG_DESTDIR = pkgconfig
+
diff --git a/src/libraries/qtopiamail/support/qmaillog.h b/src/libraries/qtopiamail/support/qmaillog.h
index 9d61887..81373e8 100644
--- a/src/libraries/qtopiamail/support/qmaillog.h
+++ b/src/libraries/qtopiamail/support/qmaillog.h
@@ -86,12 +86,12 @@ public:
 
 #define qMailLog(dbgcat) if(!dbgcat##_QLog::enabled()); else dbgcat##_QLog::log(#dbgcat)
 
-QLOG_DISABLE() //uncategorized logging
-QLOG_DISABLE(Messaging)
-QLOG_DISABLE(IMAP)
-QLOG_DISABLE(SMTP)
-QLOG_DISABLE(POP)
-QLOG_DISABLE(ImapData)
-QLOG_DISABLE(MessagingState)
+QLOG_ENABLE() //uncategorized logging
+QLOG_ENABLE(Messaging)
+QLOG_ENABLE(IMAP)
+QLOG_ENABLE(SMTP)
+QLOG_ENABLE(POP)
+QLOG_ENABLE(ImapData)
+QLOG_ENABLE(MessagingState)
 
 #endif //QMAILLOG_H
diff --git a/src/libraries/qtopiamail/support/qmailnamespace.cpp b/src/libraries/qtopiamail/support/qmailnamespace.cpp
index d63acdf..ce4b0a7 100644
--- a/src/libraries/qtopiamail/support/qmailnamespace.cpp
+++ b/src/libraries/qtopiamail/support/qmailnamespace.cpp
@@ -178,9 +178,9 @@ QString QMail::pluginsPath()
 {
     static QString pluginsEnv(getenv(QMF_PLUGINS_ENV));
     if(!pluginsEnv.isEmpty())
-        return pluginsEnv + "/";
-    //default to "." if no env set
-    return pluginsEnv;
+        return pluginsEnv;
+    //default to "/usr/lib/qmf/" if no env set
+    return "/usr/lib/qmf/";
 }
 
 QString QMail::sslCertsPath()
diff --git a/src/libraries/sparql/sparql.pro b/src/libraries/sparql/sparql.pro
new file mode 100644
index 0000000..7a56540
--- /dev/null
+++ b/src/libraries/sparql/sparql.pro
@@ -0,0 +1,31 @@
+TEMPLATE = lib
+
+TARGET = sparql
+
+INCLUDEPATH += . tracker
+
+QT *= dbus
+
+# Input
+HEADERS += sparqldatabase.h \
+    sparqlquery.h \
+    sparqlresult.h \
+    tracker/registertypes.h \
+    tracker/resourcesproxy.h \
+    sparqluri.h
+SOURCES += sparqldatabase.cpp \
+    sparqlquery.cpp \
+    sparqlresult.cpp \
+    tracker/registertypes.cpp \
+    tracker/resourcesproxy.cpp \
+    sparqluri.cpp
+
+# Install headers
+headers.files = $$HEADERS include/*
+headers.path  = $$QMF_INSTALL_ROOT/include/qmf
+
+INSTALLS += headers
+
+target.path += $$QMF_INSTALL_ROOT/lib
+
+INSTALLS += target
diff --git a/src/libraries/sparql/sparqldatabase.cpp b/src/libraries/sparql/sparqldatabase.cpp
new file mode 100644
index 0000000..dce2971
--- /dev/null
+++ b/src/libraries/sparql/sparqldatabase.cpp
@@ -0,0 +1,31 @@
+#include "sparqldatabase.h"
+
+#include <QDBusConnection>
+
+// Pointer to the default database
+SparqlDatabase* SparqlDatabase::_defaultDatabase = NULL;
+
+
+SparqlDatabase::SparqlDatabase(const QString& databaseName) :
+        _proxy(databaseName, "/org/freedesktop/Tracker/Resources", QDBusConnection::sessionBus())
+{
+    qDebug() << "SparqlDatabase::SparqlDatabase";
+    if (!_defaultDatabase)
+    {
+        // Register Qt types
+        registerTypes();
+
+        _defaultDatabase = this;
+    }
+}
+
+SparqlDatabase::~SparqlDatabase()
+{
+    if (_defaultDatabase == this)
+        _defaultDatabase = NULL;
+}
+
+SparqlDatabase* SparqlDatabase::defaultDatabase()
+{
+    return _defaultDatabase;
+}
diff --git a/src/libraries/sparql/sparqldatabase.h b/src/libraries/sparql/sparqldatabase.h
new file mode 100644
index 0000000..5b8c246
--- /dev/null
+++ b/src/libraries/sparql/sparqldatabase.h
@@ -0,0 +1,44 @@
+#ifndef SPARQLDATABASE_H
+#define SPARQLDATABASE_H
+
+#include "tracker/resourcesproxy.h"
+
+/**
+ * @brief SparqlDatabase represents connection to the SPARQL data base.
+ *
+ * SparqlDatabase represents connection to the SPARQL data base. It relies on the
+ * proxy implementation. It is possible to keep several databases opened at the same
+ * time, but only one of them will be default. All queries without exact database
+ * specification will be performed with default database.
+ *
+ * @see SparqlQuery
+ */
+class SparqlDatabase
+{
+    friend class SparqlQuery;
+
+public:
+    /**
+     * @brief Creates new database
+     *
+     * @param databaseName Name of the data base.
+     */
+    SparqlDatabase(const QString& databaseName = "org.freedesktop.Tracker");
+    /// Default destructor
+    ~SparqlDatabase();
+
+
+    /**
+     * @brief Returns default database
+     *
+     * First created database will become default one.
+     */
+    static SparqlDatabase* defaultDatabase();
+
+private:
+    static SparqlDatabase* _defaultDatabase;
+
+    ResourcesProxy _proxy;
+};
+
+#endif // SPARQLDATABASE_H
diff --git a/src/libraries/sparql/sparqlquery.cpp b/src/libraries/sparql/sparqlquery.cpp
new file mode 100644
index 0000000..3241e07
--- /dev/null
+++ b/src/libraries/sparql/sparqlquery.cpp
@@ -0,0 +1,81 @@
+#include "sparqlquery.h"
+#include "sparqldatabase.h"
+#include "sparqlresult.h"
+
+#include <QDBusPendingReply>
+
+SparqlQuery::SparqlQuery(SparqlQuery::QueryType type, const QString& query,  SparqlDatabase* database) :
+        _type(type),
+        _query(query),
+        _database(database),
+        _result(NULL)
+{
+    if (!_database)
+        _database = SparqlDatabase::defaultDatabase();
+
+    Q_ASSERT(_database);
+}
+
+SparqlQuery::~SparqlQuery()
+{
+}
+
+bool SparqlQuery::prepare(const QString query)
+{
+    _query = query;
+
+    return true;
+}
+
+bool SparqlQuery::exec()
+{
+    Q_ASSERT(_database);
+
+    // Clear last error status and query result
+    _result.clear();
+    _error.clear();
+
+    qDebug() << _query;
+
+    bool err;
+    if (_type == SearchQuery)
+    {
+        QDBusPendingReply<QueryResultType> reply;
+        reply = _database->_proxy.Query(_query);
+
+        reply.waitForFinished();
+
+        err = reply.isError();
+        if (!err)
+        {
+            _result = reply.value();
+
+            foreach (const QStringList& row, _result)
+                qDebug() << row.join(", ");
+
+        } else
+            _error = reply.error().message();
+
+    } else {
+        QDBusPendingReply<> reply;
+        reply = _database->_proxy.SparqlUpdate(_query);
+
+        reply.waitForFinished();
+
+        err = reply.isError();
+        if (err)
+            _error = reply.error().message();
+    }
+
+    return !err;
+}
+
+SparqlResult SparqlQuery::result() const
+{
+    return SparqlResult(this);
+}
+
+QString SparqlQuery::error() const
+{
+    return _error;
+}
diff --git a/src/libraries/sparql/sparqlquery.h b/src/libraries/sparql/sparqlquery.h
new file mode 100644
index 0000000..bca2387
--- /dev/null
+++ b/src/libraries/sparql/sparqlquery.h
@@ -0,0 +1,84 @@
+#ifndef SPARQLQUERY_H
+#define SPARQLQUERY_H
+
+#include <QStringList>
+#include <QVector>
+#include <QString>
+
+class SparqlDatabase;
+class SparqlResult;
+
+/**
+ * @brief SparqlQuery represents SPARQL query.
+ *
+ * There are two different types of queries: search and update queries. Search query uses standard SPARQL syntax
+ * and can only read information from the database. Update queries exploit Advanced SPARQL syntax and allow to
+ * insert, delete and update information in the database.
+ *
+ * Database can be defeined explicitely or default database can be used. In anycase at least one SparqlDatabase
+ * object must be created.
+ *
+ * @see SparqlDatabase
+ */
+class SparqlQuery
+{
+    friend class SparqlResult;
+
+public:
+    /// Type of the query
+    enum QueryType
+    {
+        SearchQuery,  ///< Query can use SELECT, CONSTRUCT, DESCRIBE or ASK SPARQL statments
+        UpdateQuery   ///< Query can use INSERT, DELETE and UPDATE advances SPARQL statments
+    };
+
+    /**
+     * @brief Constructs SPARQL query
+     *
+     * @param type Type of the quey.
+     * @param query Query string, It can be defined later with prepare() method.
+     * @param database Pointer to the database. Default database will be used in case of NULL.
+     */
+    SparqlQuery(QueryType type, const QString& query = QString(),  SparqlDatabase* database = NULL);
+
+    /// Default destructor
+    ~SparqlQuery();
+
+    /// Prepare query for execution
+    bool prepare(const QString query);
+
+    /**
+     * @brief Execute prepared query
+     *
+     * Before executing a query it has to be prepared using prepare() method.
+     * In case of any errors exec() will return false. More detailes information
+     * about source of error can be retrieved using error() method.
+     *
+     * Result of query execution can be retrieved using result() method.
+     * Retult is available only for Search queries.
+     *
+     * @return true in case of success and false in case of failure.
+     */
+    bool exec();
+
+    /**
+     * @brief Returns result of the operation
+     *
+     * @return result can be NULL in case of error or Update query was executed.
+     */
+    SparqlResult result() const;
+
+    /// Returns textual representation of the error.
+    QString error() const;
+
+private:
+    QueryType       _type;
+    QString         _query;
+    SparqlDatabase* _database;
+    QString         _error;
+
+    typedef QVector<QStringList> QueryResultType;
+    QueryResultType _result;
+};
+
+#endif // SPARQLQUERY_H
diff --git a/src/libraries/sparql/sparqlresult.cpp b/src/libraries/sparql/sparqlresult.cpp
new file mode 100644
index 0000000..de7f2a0
--- /dev/null
+++ b/src/libraries/sparql/sparqlresult.cpp
@@ -0,0 +1,31 @@
+#include "sparqlresult.h"
+#include "sparqlquery.h"
+
+SparqlResult::SparqlResult(const SparqlQuery* query) :
+        _query(query),
+        _current(0)
+{
+}
+
+const QStringList& SparqlResult::fetchRow()
+{
+    Q_ASSERT(_query);
+
+    return _query->_result.at(_current++);
+}
+
+bool SparqlResult::begin() const
+{
+    return (_current == 0);
+}
+
+bool SparqlResult::end() const
+{
+    Q_ASSERT(_query);
+    return (_query->_result.count() == _current);
+}
+
+void SparqlResult::reset()
+{
+    _current = 0;
+}
diff --git a/src/libraries/sparql/sparqlresult.h b/src/libraries/sparql/sparqlresult.h
new file mode 100644
index 0000000..a6ce68e
--- /dev/null
+++ b/src/libraries/sparql/sparqlresult.h
@@ -0,0 +1,46 @@
+#ifndef SPARQLRESULT_H
+#define SPARQLRESULT_H
+
+#include <QVector>
+#include <QStringList>
+
+class SparqlQuery;
+
+/**
+ * @brief SparqlResult provides convenient way to fetch data from the executed query.
+ *
+ * To fetch data from already executed query you have to get instance of that class
+ * with SparqlQuery::result() method and call fetchRow() method till you reach the end().
+ *
+ * It is possible to enumerate result of the query using different instances of the
+ * SparqlResult class at the same time. But you have to know that data itself belongs
+ * to the query and you should not access any methods of this class in case of SparqlQuery
+ * was destroyed.
+ *
+ * @see SparqlQuery
+ */
+class SparqlResult
+{
+    friend class SparqlQuery;
+
+public:
+    /// Fetch the row with results of the query
+    const QStringList& fetchRow();
+
+    /// Does the result point to the beginig of data set
+    bool begin() const;
+
+    /// Does the result point to the end of the data set
+    bool end() const;
+
+    /// Reset result and make it points to the begining again
+    void reset();
+
+private:
+    SparqlResult(const SparqlQuery* query);
+    const SparqlQuery* _query;
+
+    int _current;
+};
+
+#endif // SPARQLRESULT_H
diff --git a/src/libraries/sparql/sparqluri.cpp b/src/libraries/sparql/sparqluri.cpp
new file mode 100644
index 0000000..2caa6d4
--- /dev/null
+++ b/src/libraries/sparql/sparqluri.cpp
@@ -0,0 +1,154 @@
+/**
+ * \brief SparqlUri provides automatic URI generation.
+ *
+ * URI is unique identifier in the SPARQL language, it is required
+ * to be able to generate unique identifiers fast and easy. SparqlUri class
+ * provides convenient way to generate such URI.
+ *
+ * Every URI has base part and autogenerated part. Base part can be defined by user.
+ * Autogenerated part will be changed with every increment operation.
+ *
+ * Autogenerate URI will look like http://base.part/is/fixed#nnnnnn, where nnnnnn is 64bit
+ * integer, No any prediction is made about order or number of digits in the nnnnnn.
+ *
+ * \see SparqlQuery
+ */
+
+#include "sparqluri.h"
+
+#include <QUuid>
+
+/**
+ * \brief Constructor of the URI
+ *
+ * Unique id will be autogenerated.
+ *
+ * \param base Fixed part of the URI.
+ */
+SparqlUri::SparqlUri(const QString& base) :
+        _id(generate())
+{
+    bool ret = setBase(base);
+    Q_ASSERT(ret);
+}
+
+/**
+ * \brief Constructor of the URI generator
+ *
+ * Value of id is passed as a parameter
+ *
+ * \param base Fixed part of the URI.
+ * \param id Pre-defined id is used in this case.
+ */
+SparqlUri::SparqlUri(const QString& base, quint64 id) :
+        _id(id)
+{
+    bool ret = setBase(base);
+    Q_ASSERT(ret);
+}
+
+/**
+ * \brief Set new fixed base of the URI
+ */
+bool SparqlUri::setBase(const QString& base)
+{
+    _base = base;
+    return true;
+}
+
+/**
+ * \brief Get fixed base part of the URI
+ */
+QString SparqlUri::base() const
+{
+    return _base;
+}
+
+/**
+ * \brief Get current URI as a string
+ */
+QString SparqlUri::uri() const
+{
+    return base() + QString::number(_id);
+}
+
+/**
+ * \brief Set current nnnnnn part as 64-bit integer
+ */
+void SparqlUri::setId(quint64 id)
+{
+    _id = id;
+}
+
+/**
+ * \brief Get current nnnnnn part as 64-bit integer
+ */
+quint64 SparqlUri::id() const
+{
+    return _id;
+}
+
+/**
+ * \brief Generates new nnnnnn.
+ *
+ * Current URI is not updated. To update current URI as well operator++ should be used.
+ *
+ * \return new nnnnnn part of the URI as 64-bit unsigned integer.
+ */
+quint64 SparqlUri::generate()
+{
+    /*
+     * BUG!BUG!BUG!
+     *
+     * We can't just generate UUID and do not make
+     * sure that it is unique.
+     *
+     * THIS CODE HAS TO BE REWRITTEN.
+     */
+    QUuid uuid = QUuid::createUuid();
+
+    quint64 data1 = uuid.data1;
+    quint64 data2 = uuid.data2;
+    quint64 data3 = uuid.data3;
+    quint64 data4 = *(quint64*)uuid.data4;
+
+    quint64 id = (data1 << 32) ^ (data2 << 16) ^ data3;
+    id |= data4;
+
+    return id;
+}
+
+/**
+ * \brief Convenience operator returns URI
+ */
+SparqlUri::operator QString () const
+{
+    return uri();
+}
+
+/**
+ * \brief Convenience operator returns nnnnnn part of the URI
+ */
+SparqlUri::operator quint64 () const
+{
+    return id();
+}
+
+/**
+ * \brief Generates new URI and returns new value
+ */
+QString SparqlUri::operator++ ()
+{
+    _id = generate();
+    return uri();
+}
+
+/**
+ * \brief Generates new URI and returns old value
+ */
+QString SparqlUri::operator++ (int)
+{
+    QString result(uri());
+    _id = generate();
+    return result;
+}
diff --git a/src/libraries/sparql/sparqluri.h b/src/libraries/sparql/sparqluri.h
new file mode 100644
index 0000000..21e0556
--- /dev/null
+++ b/src/libraries/sparql/sparqluri.h
@@ -0,0 +1,33 @@
+#ifndef SPARQLURI_H
+#define SPARQLURI_H
+
+#include "sparqldatabase.h"
+
+class SparqlUri
+{
+public:
+    SparqlUri(const QString& base);
+    SparqlUri(const QString& base, quint64 id);
+
+    bool setBase(const QString& base);
+    QString base() const;
+
+    void setId(quint64 id);
+    quint64 id() const;
+
+    QString uri() const;
+
+    quint64 generate();
+
+    operator QString () const;
+    operator quint64 () const;
+
+    QString operator++ ();
+    QString operator++ (int);
+
+private:
+    QString _base;
+    quint64 _id;
+};
+
+#endif // #ifndef SPARQLURI_H
diff --git a/src/libraries/sparql/tracker/README b/src/libraries/sparql/tracker/README
new file mode 100644
index 0000000..9b8b88a
--- /dev/null
+++ b/src/libraries/sparql/tracker/README
@@ -0,0 +1,20 @@
+
+HOWTO Generate proxy code from DBUSXML interface definition
+
+ Obtain latest version of the .xml files from the tracker repository
+   git://git.codethink.co.uk/git/tracker
+   
+   Backup existing .xml files and code of the DBUS proxy classes.
+   
+ Update XML interface description with correct annotations for all Qt types:
+  * For every type="aas" direction="out", add following annotation:
+    <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVector&lt;QStringList&gt;"/>
+
+  * For every type="a{sv}" direction="out", add following annotation:
+    <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVariantList"/>
+
+  * For every signal with type="aas", add following annotation:
+    <annotation name="com.trolltech.QtDBus.QtTypeName.In0" value="QVector&lt;QStringList&gt;"/>
+
+ Run genproxy.sh script
+ 
diff --git a/src/libraries/sparql/tracker/genproxy.sh b/src/libraries/sparql/tracker/genproxy.sh
new file mode 100755
index 0000000..73a960c
--- /dev/null
+++ b/src/libraries/sparql/tracker/genproxy.sh
@@ -0,0 +1,2 @@
+#!/bin/bash
+qdbusxml2cpp -c ResourcesProxy -p resourcesproxy -i registertypes.h tracker-resources.xml org.freedesktop.Tracker.Resources
diff --git a/src/libraries/sparql/tracker/registertypes.cpp b/src/libraries/sparql/tracker/registertypes.cpp
new file mode 100644
index 0000000..e8ce4ed
--- /dev/null
+++ b/src/libraries/sparql/tracker/registertypes.cpp
@@ -0,0 +1,10 @@
+#include <QDBusMetaType>
+#include <QtDebug>
+
+#include "registertypes.h"
+
+void registerTypes()
+{
+    qRegisterMetaType<QVector<QStringList> >();
+    qDBusRegisterMetaType<QVector<QStringList> >();
+}
diff --git a/src/libraries/sparql/tracker/registertypes.h b/src/libraries/sparql/tracker/registertypes.h
new file mode 100644
index 0000000..5c87c3f
--- /dev/null
+++ b/src/libraries/sparql/tracker/registertypes.h
@@ -0,0 +1,12 @@
+#ifndef __REGISTERTYPES_H__
+#define __REGISTERTYPES_H__
+
+#include <QMetaType>
+#include <QVector>
+#include <QStringList>
+
+Q_DECLARE_METATYPE(QVector<QStringList>)
+
+void registerTypes();
+
+#endif // #ifndef __REGISTERTYPES_H__
diff --git a/src/libraries/sparql/tracker/resourcesproxy.cpp b/src/libraries/sparql/tracker/resourcesproxy.cpp
new file mode 100644
index 0000000..96f5d46
--- /dev/null
+++ b/src/libraries/sparql/tracker/resourcesproxy.cpp
@@ -0,0 +1,26 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -c ResourcesProxy -p resourcesproxy -i registertypes.h tracker-resources.xml org.freedesktop.Tracker.Resources
+ *
+ * qdbusxml2cpp is Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "resourcesproxy.h"
+
+/*
+ * Implementation of interface class ResourcesProxy
+ */
+
+ResourcesProxy::ResourcesProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+ResourcesProxy::~ResourcesProxy()
+{
+}
+
diff --git a/src/libraries/sparql/tracker/resourcesproxy.h b/src/libraries/sparql/tracker/resourcesproxy.h
new file mode 100644
index 0000000..5dcee19
--- /dev/null
+++ b/src/libraries/sparql/tracker/resourcesproxy.h
@@ -0,0 +1,85 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -c ResourcesProxy -p resourcesproxy -i registertypes.h tracker-resources.xml org.freedesktop.Tracker.Resources
+ *
+ * qdbusxml2cpp is Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef RESOURCESPROXY_H_1238063483
+#define RESOURCESPROXY_H_1238063483
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+#include "registertypes.h"
+
+/*
+ * Proxy class for interface org.freedesktop.Tracker.Resources
+ */
+class ResourcesProxy: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.Tracker.Resources"; }
+
+public:
+    ResourcesProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~ResourcesProxy();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> Delete(const QString &subject, const QString &predicate, const QString &object)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(subject) << qVariantFromValue(predicate) << qVariantFromValue(object);
+        return asyncCallWithArgumentList(QLatin1String("Delete"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Insert(const QString &subject, const QString &predicate, const QString &object)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(subject) << qVariantFromValue(predicate) << qVariantFromValue(object);
+        return asyncCallWithArgumentList(QLatin1String("Insert"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Load(const QString &uri)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(uri);
+        return asyncCallWithArgumentList(QLatin1String("Load"), argumentList);
+    }
+
+    inline QDBusPendingReply<QVector<QStringList> > Query(const QString &query)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(query);
+        return asyncCallWithArgumentList(QLatin1String("Query"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SparqlUpdate(const QString &query)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(query);
+        return asyncCallWithArgumentList(QLatin1String("SparqlUpdate"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+namespace org {
+  namespace freedesktop {
+    namespace Tracker {
+      typedef ::ResourcesProxy Resources;
+    }
+  }
+}
+#endif
diff --git a/src/libraries/sparql/tracker/tracker-resources.xml b/src/libraries/sparql/tracker/tracker-resources.xml
new file mode 100644
index 0000000..9d8f79d
--- /dev/null
+++ b/src/libraries/sparql/tracker/tracker-resources.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<node name="/org/freedesktop/Tracker">
+  <interface name="org.freedesktop.Tracker.Resources">
+
+    <!-- Insert single statement -->
+    <method name="Insert">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/> 
+      <arg type="s" name="subject" direction="in" />
+      <arg type="s" name="predicate" direction="in" />
+      <arg type="s" name="object" direction="in" />
+    </method>
+
+    <!-- Delete single statement -->
+    <method name="Delete">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/> 
+      <arg type="s" name="subject" direction="in" />
+      <arg type="s" name="predicate" direction="in" />
+      <arg type="s" name="object" direction="in" />
+    </method>
+
+    <!-- Load statements from Turtle file -->
+    <method name="Load">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/> 
+      <arg type="s" name="uri" direction="in" />
+    </method>
+
+    <!-- SPARL Query without updates -->
+    <method name="Query">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/>
+      <arg type="s" name="query" direction="in" />
+      <arg type="aas" name="result" direction="out" />
+        <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVector&lt;QStringList&gt;"/>
+    </method>
+
+    <!-- SPARL Update extensions, allows bulk insert and delete -->
+    <method name="SparqlUpdate">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/>
+      <arg type="s" name="query" direction="in" />
+    </method>
+
+  </interface>
+</node>
diff --git a/tools/sparql-import/main.cpp b/tools/sparql-import/main.cpp
new file mode 100644
index 0000000..86153dd
--- /dev/null
+++ b/tools/sparql-import/main.cpp
@@ -0,0 +1,141 @@
+#include <QCoreApplication>
+
+#include "sparqluri.h"
+#include "sparqlquery.h"
+#include "sparqlresult.h"
+#include "sparqldatabase.h"
+#include "sparqlmailstore.h"
+
+#include <qmailstore.h>
+
+
+int main(int argc, char* argv[])
+{
+    QCoreApplication app(argc, argv);
+
+    SparqlDatabase database;
+    SparqlMailStore sparqlStore;
+
+    QMailStore* sqlStore = QMailStore::instance();
+
+/*
+    qDebug() << sqlStore->countAccounts();
+    qDebug() << sqlStore->countFolders();
+    qDebug() << sqlStore->countMessages();
+
+
+    qDebug() << "Number of accounts:" << sparqlStore.countAccounts();
+
+    QMailAccountIdList accountIdList = sparqlStore.queryAccounts();
+
+    foreach (QMailAccountId accountId, accountIdList)
+    {
+        QMailAccount account = sparqlStore.account(accountId);
+
+        QMailFolderKey folderKey = QMailFolderKey::parentAccountId(accountId);
+
+        qDebug() << "Number of Folders (" << account.name() << ")" << sparqlStore.countFolders(folderKey);
+
+        QMailFolderIdList folderIdList = sparqlStore.queryFolders(folderKey);
+
+        foreach (QMailFolderId folderId, folderIdList)
+        {
+            QMailFolder folder = sparqlStore.folder(folderId);
+
+            QMailMessageKey messageKey = QMailMessageKey::parentFolderId(folderId);
+
+            qDebug() << "Number of Messages (" << account.name() << "/" << folder.displayName() << ")" << sparqlStore.countMessages(messageKey);
+
+            QMailMessageIdList messageIdList = sparqlStore.queryMessages(messageKey);
+
+            foreach (QMailMessageId messageId, messageIdList)
+            {
+                QMailMessage message = sparqlStore.message(messageId);
+
+                qDebug() << message.subject();
+            }
+
+        }
+    }
+
+    */
+
+    // Add standard folders
+    sparqlStore.setupStandardFolder(QMailFolder::InboxFolder, "Inbox");
+    sparqlStore.setupStandardFolder(QMailFolder::OutboxFolder, "Outbox");
+    sparqlStore.setupStandardFolder(QMailFolder::DraftsFolder, "Drafts");
+    sparqlStore.setupStandardFolder(QMailFolder::SentFolder, "Sent");
+    sparqlStore.setupStandardFolder(QMailFolder::TrashFolder, "Trash");
+
+    QMailAccountIdList accountIdList = sqlStore->queryAccounts();
+
+    foreach (QMailAccountId accountId, accountIdList)
+    {
+        QMailAccount account(accountId);
+
+        sparqlStore.addAccount(&account);
+
+        QMailFolderKey folderKey = QMailFolderKey::parentAccountId(accountId);
+
+        QMailFolderIdList folderIdList = sqlStore->queryFolders(folderKey);
+
+        foreach (QMailFolderId folderId, folderIdList)
+        {
+            QMailFolder folder(folderId);
+
+            if (!(QMailFolder::InboxFolder <= folder.id().toULongLong()) ||
+                !(folder.id().toULongLong() <= QMailFolder::TrashFolder))
+            {
+                sparqlStore.addFolder(&folder);
+            }
+            folder.setParentAccountId(account.id());
+
+            QMailMessageKey messageKey = QMailMessageKey::parentFolderId(folderId);
+
+            QMailMessageIdList messageIdList = sqlStore->queryMessages(messageKey);
+
+            foreach (QMailMessageId messageId, messageIdList)
+            {
+                QMailMessage message(messageId);
+
+                message.setParentAccountId(account.id());
+                message.setParentFolderId(folder.id());
+
+                sparqlStore.addMessage(&message);
+            }
+        }
+    }
+
+    // Add all folders without any accounts
+    QMailFolderKey folderKey = QMailFolderKey::parentAccountId(QMailAccountId());
+    QMailFolderIdList folderIdList = sqlStore->queryFolders(folderKey);
+
+    foreach (QMailFolderId folderId, folderIdList)
+    {
+        QMailFolder folder(folderId);
+        
+        if (!(QMailFolder::InboxFolder <= folder.id().toULongLong()) ||
+            !(folder.id().toULongLong() <= QMailFolder::TrashFolder))
+        {
+            sparqlStore.addFolder(&folder);
+        }
+
+        QMailMessageKey messageKey = QMailMessageKey::parentFolderId(folderId);
+
+        QMailMessageIdList messageIdList = sqlStore->queryMessages(messageKey);
+
+        foreach (QMailMessageId messageId, messageIdList)
+        {
+            QMailMessage message(messageId);
+
+            message.setParentFolderId(folder.id());
+
+            sparqlStore.addMessage(&message);
+        }
+    }
+
+    //*/
+    return 0;
+}
+
+
diff --git a/tools/sparql-import/sparql-import.pro b/tools/sparql-import/sparql-import.pro
new file mode 100644
index 0000000..3429430
--- /dev/null
+++ b/tools/sparql-import/sparql-import.pro
@@ -0,0 +1,23 @@
+TEMPLATE = app
+
+TARGET = sparql-import
+
+QT += dbus
+
+DEPENDPATH += .
+
+INCLUDEPATH += . \
+    ../../src/libraries/qtopiamail \
+    ../../src/libraries/qtopiamail/support \
+    ../../src/libraries/sparql
+
+LIBS += -L../../src/libraries/qtopiamail -L../../src/libraries/sparql -lqtopiamail -lsparql
+
+QMAKE_LFLAGS += -Wl,-rpath,../../src/libraries/qtopiamail -Wl,-rpath,../../src/libraries/sparql
+
+# Input
+HEADERS += sparqlmailstore.h
+SOURCES += main.cpp sparqlmailstore.cpp
+
+target.path += $$QMF_INSTALL_ROOT/tests
+INSTALLS += target
diff --git a/tools/sparql-import/sparqlmailstore.cpp b/tools/sparql-import/sparqlmailstore.cpp
new file mode 100644
index 0000000..d1ad530
--- /dev/null
+++ b/tools/sparql-import/sparqlmailstore.cpp
@@ -0,0 +1,1371 @@
+#include "sparqlmailstore.h"
+
+#include "sparqluri.h"
+#include "sparqlquery.h"
+#include "sparqlresult.h"
+
+
+#include <QDebug>
+
+namespace {
+
+QString escape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(escapee, QString(escaper) + escapee);
+}
+
+QString contentUri(const QString &scheme, const QString &identifier)
+{
+    if (scheme.isEmpty())
+        return QString();
+
+    // Formulate a URI from the content scheme and identifier
+    return escape(scheme, ':') + ':' + escape(identifier, ':');
+}
+
+QString contentUri(const QMailMessageMetaData &message)
+{
+    return contentUri(message.contentScheme(), message.contentIdentifier());
+}
+
+QString unescape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(QString(escaper) + escapee, escapee);
+}
+
+QPair<QString, QString> uriElements(const QString &uri)
+{
+    int index = uri.indexOf(':');
+    while ((index != -1) && (uri.at(index - 1) == '\\'))
+        index = uri.indexOf(':', index + 1);
+
+    return qMakePair(unescape(uri.mid(0, index), ':'), unescape(uri.mid(index + 1), ':'));
+}
+
+namespace {
+
+using namespace QMailKey;
+
+QString combineOperatorString(QMailKey::Combiner op)
+{
+    switch (op)
+    {
+    case And:
+        return " && ";
+        break;
+
+    case Or:
+        return " || ";
+        break;
+
+    case None:
+        break;
+    }
+
+    return QString();
+}
+
+template <class Comparator>
+QString operatorString(Comparator op, int argsNumber = 1);
+
+QString operatorStringPattern(int argNumber, const QString& op, const QString& comp)
+{
+    QStringList pattern;
+    for (int i = 0; i<argNumber; i++)
+        pattern << "(%1 " + op + " \"%" + QString::number(i+2) + "\")";
+
+    if (argNumber > 1)
+        return "(" + pattern.join(comp) + ")";
+    else
+        return pattern.join(comp);
+}
+
+template <>
+QString operatorString<QMailKey::Comparator>(QMailKey::Comparator op, int argsNumber)
+{
+    switch (op)
+    {
+    case Equal:
+        //  "(%1 = \"%2\")" : "(%1 = \"%2\") || (%1 = \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "=", "") : operatorStringPattern(argsNumber, "=", " || "));
+        break;
+
+    case NotEqual:
+        // "(%1 != \"%2\")" : "(%1 != \"%2\") && (%1 != \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "!=", "") : operatorStringPattern(argsNumber, "!=", " && "));
+        break;
+
+    case LessThan:
+        return "(%1 < %2)";
+        break;
+
+    case LessThanEqual:
+        return "(%1 <= %2)";
+        break;
+
+    case GreaterThan:
+        return "(%1 > %2)";
+        break;
+
+    case GreaterThanEqual:
+        return "(%1 >= %2)";
+        break;
+
+    case Includes:
+    case Present:
+        // "(%1 & \"%2\")" : "(%1 = \"%2\") || (%1 = \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "&", "") : operatorStringPattern(argsNumber, "=", " || "));
+        break;
+
+    case Excludes:
+    case Absent:
+        // "!(%1 & \"%2\")" : "(%1 != \"%2\") && (%1 != \"%3\")"
+        return (argsNumber == 1 ? "(!" + operatorStringPattern(argsNumber, "&", "") + ")": operatorStringPattern(argsNumber, "!=", " && "));
+        break;
+    }
+
+    return QString();
+}
+
+template <class Property>
+QString propertyNameString(Property property);
+
+template <>
+QString propertyNameString<QMailMessageKey::Property>(QMailMessageKey::Property property)
+{
+    switch (property)
+    {
+        case QMailMessageKey::Id:
+            return "?id";
+
+        case QMailMessageKey::Type:
+            return "?type";
+
+        case QMailMessageKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailMessageKey::Sender:
+            return "?sender";
+
+        case QMailMessageKey::Recipients:
+            return "?recipients";
+
+        case QMailMessageKey::Subject:
+            return "?subject";
+
+        case QMailMessageKey::TimeStamp:
+            return "?timestamp";
+
+        case QMailMessageKey::Status:
+            return "?status";
+
+        case QMailMessageKey::Conversation:
+            return "?conversation";
+
+        case QMailMessageKey::ReceptionTimeStamp:
+            return "?receptionTimeStamp";
+
+        case QMailMessageKey::ServerUid:
+            return "?serverUid";
+
+        case QMailMessageKey::Size:
+            return "?size";
+
+        case QMailMessageKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailMessageKey::AncestorFolderIds:
+            return "?ancestorFolderIds";
+
+        case QMailMessageKey::ContentType:
+            return "?contentType";
+
+        case QMailMessageKey::PreviousParentFolderId:
+            return "?previousParentFolderId";
+
+        case QMailMessageKey::ContentScheme:
+            return "?contentScheme";
+
+        case QMailMessageKey::ContentIdentifier:
+            return "?contentIdentifier";
+
+        case QMailMessageKey::InResponseTo:
+            return "?inResponseTo";
+
+        case QMailMessageKey::ResponseType:
+            return "?responseType";
+
+        case QMailMessageKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailFolderKey::Property>(QMailFolderKey::Property property)
+{
+    switch (property)
+    {
+        case QMailFolderKey::Id:
+            return "?id";
+
+        case QMailFolderKey::Path:
+            return "?path";
+
+        case QMailFolderKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailFolderKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailFolderKey::DisplayName:
+            return "?displayName";
+
+        case QMailFolderKey::Status:
+            return "?status";
+
+        case QMailFolderKey::AncestorFolderIds:
+            return "?ancestorFolderIds";
+
+        case QMailFolderKey::ServerCount:
+            return "?serverCount";
+
+        case QMailFolderKey::ServerUnreadCount:
+            return "?serverUnreadCount";
+
+        case QMailFolderKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailAccountKey::Property>(QMailAccountKey::Property property)
+{
+    switch (property)
+    {
+        case QMailAccountKey::Id:
+            return "?id";
+
+        case QMailAccountKey::Name:
+            return "?name";
+
+        case QMailAccountKey::MessageType:
+            return "?messageType";
+
+        case QMailAccountKey::FromAddress:
+            return "?fromAddress";
+
+        case QMailAccountKey::Status:
+            return "?status";
+
+        case QMailAccountKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailMessageSortKey::Property>(QMailMessageSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailMessageSortKey::Id:
+            return "?id";
+
+        case QMailMessageSortKey::Type:
+            return "?type";
+
+        case QMailMessageSortKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailMessageSortKey::Sender:
+            return "?sender";
+
+        case QMailMessageSortKey::Recipients:
+            return "?recipients";
+
+        case QMailMessageSortKey::Subject:
+            return "?subject";
+
+        case QMailMessageSortKey::TimeStamp:
+            return "?timestamp";
+
+        case QMailMessageSortKey::Status:
+            return "?status";
+
+        case QMailMessageSortKey::ReceptionTimeStamp:
+            return "?receptionTimeStamp";
+
+        case QMailMessageSortKey::ServerUid:
+            return "?serverUid";
+
+        case QMailMessageSortKey::Size:
+            return "?size";
+
+        case QMailMessageSortKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailMessageSortKey::ContentType:
+            return "?contentType";
+
+        case QMailMessageSortKey::PreviousParentFolderId:
+            return "?previousParentFolderId";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailFolderSortKey::Property>(QMailFolderSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailFolderSortKey::Id:
+            return "?id";
+
+        case QMailFolderSortKey::Path:
+            return "?path";
+
+        case QMailFolderSortKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailFolderSortKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailFolderSortKey::DisplayName:
+            return "?displayName";
+
+        case QMailFolderSortKey::Status:
+            return "?status";
+
+        case QMailFolderSortKey::ServerCount:
+            return "?serverCount";
+
+        case QMailFolderSortKey::ServerUnreadCount:
+            return "?serverUnreadCount";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailAccountSortKey::Property>(QMailAccountSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailAccountSortKey::Id:
+            return "?id";
+
+        case QMailAccountSortKey::Name:
+            return "?name";
+
+        case QMailAccountSortKey::MessageType:
+            return "?messageType";
+
+        case QMailAccountSortKey::Status:
+            return "?status";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class Property>
+QString sparqlPropertyStatmentString(const QString& uri, Property property);
+
+template <>
+QString sparqlPropertyStatmentString<QMailMessageKey::Property>(const QString& uri, QMailMessageKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailMessageKey::Id:
+            return QString();
+
+        case QMailMessageKey::Type:
+            return QString();
+
+        case QMailMessageKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Sender:
+            return QString("%1 nmo:sender [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Recipients:
+            return QString("%1 nmo:recipient [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Subject:
+            return QString("%1 nmo:messageSubject %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::TimeStamp:
+            return QString("%1 nmo:sentDate %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Conversation:
+            return QString();
+
+        case QMailMessageKey::ReceptionTimeStamp:
+            return QString();
+
+        case QMailMessageKey::ServerUid:
+            return QString("%1 nmo:messageId %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Size:
+            return QString("%1 nie:contentSize %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::AncestorFolderIds:
+            return QString();
+
+        case QMailMessageKey::ContentType:
+            return QString();
+
+        case QMailMessageKey::PreviousParentFolderId:
+            return QString();
+
+        case QMailMessageKey::ContentScheme:
+            return QString();
+
+        case QMailMessageKey::ContentIdentifier:
+            return QString("%1 nie:isStoredAs [ rdf:type nie:DataObject ; nie:dataSource %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::InResponseTo:
+            return QString("%1 nmo:inReplyTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::ResponseType:
+            return QString();
+
+        case QMailMessageKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailFolderKey::Property>(const QString& uri, QMailFolderKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailFolderKey::Id:
+            return "id";
+
+        case QMailFolderKey::Path:
+            return QString("%1 nmo:folderName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::DisplayName:
+            return QString("%1 nmo:folderDisplayName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::AncestorFolderIds:
+            return QString();
+
+        case QMailFolderKey::ServerCount:
+            return QString("%1 nmo:serverCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ServerUnreadCount:
+            return QString("%1 nmo:serverUnreadCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailAccountKey::Property>(const QString& uri, QMailAccountKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailAccountKey::Id:
+            return QString();
+
+        case QMailAccountKey::Name:
+            return QString("%1 nmo:accountName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::MessageType:
+            return QString();
+
+        case QMailAccountKey::FromAddress:
+            return QString("%1 nmo:fromAddress [ rdf:type nco:EmailAddress ; nco:emailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailMessageSortKey::Property>(const QString& uri, QMailMessageSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailMessageSortKey::Id:
+            return QString();
+
+        case QMailMessageSortKey::Type:
+            return QString();
+
+        case QMailMessageSortKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Sender:
+            return QString("%1 nmo:sender [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Recipients:
+            return QString("%1 nmo:recipient [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Subject:
+            return QString("%1 nmo:messageSubject %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::TimeStamp:
+            return QString("%1 nmo:sentDate %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ReceptionTimeStamp:
+            return QString();
+
+        case QMailMessageSortKey::ServerUid:
+            return QString("%1 nmo:messageId %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Size:
+            return QString("%1 nie:contentSize %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ContentType:
+            return QString();
+
+        case QMailMessageSortKey::PreviousParentFolderId:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailFolderSortKey::Property>(const QString& uri, QMailFolderSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailFolderSortKey::Id:
+            return "id";
+
+        case QMailFolderSortKey::Path:
+            return QString("%1 nmo:folderName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::DisplayName:
+            return QString("%1 nmo:folderDisplayName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ServerCount:
+            return QString("%1 nmo:serverCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ServerUnreadCount:
+            return QString("%1 nmo:serverUnreadCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailAccountSortKey::Property>(const QString& uri, QMailAccountSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailAccountSortKey::Id:
+            return QString();
+
+        case QMailAccountSortKey::Name:
+            return QString("%1 nmo:accountName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountSortKey::MessageType:
+            return QString();
+
+        case QMailAccountSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class Key, class SortKey>
+QString keyStatment(const QString& uri, const Key& key, const SortKey& sort = SortKey())
+{
+    typedef typename Key::ArgumentType     ArgumentType;
+    typedef typename SortKey::ArgumentType SortArgumentType;
+
+    QStringList arguments;
+    foreach (SortArgumentType argument, sort.arguments())
+    {
+        QString statement = sparqlPropertyStatmentString(uri, argument.first);
+        if (!arguments.contains(statement))
+            arguments << statement;
+    }
+
+    foreach (ArgumentType argument, key.arguments())
+    {
+        QString statement = sparqlPropertyStatmentString(uri, argument.property);
+        if (!arguments.contains(statement))
+            arguments << statement;
+    }
+
+    foreach (const Key& subkey, key.subKeys())
+        arguments << keyStatment(uri, subkey, SortKey());
+
+    return arguments.join("\n");
+}
+
+QString argumentValue(const QVariant& value)
+{
+    if (qVariantCanConvert<QMailAccountId>(value))
+        return QString::number(qVariantValue<QMailAccountId>(value).toULongLong());
+    else if (qVariantCanConvert<QMailFolderId>(value))
+        return QString::number(qVariantValue<QMailFolderId>(value).toULongLong());
+    else if (qVariantCanConvert<QMailMessageId>(value))
+        return QString::number(qVariantValue<QMailMessageId>(value).toULongLong());
+    else if (qVariantCanConvert<QString>(value))
+        return qVariantValue<QString>(value);
+    else if (qVariantCanConvert<int>(value))
+        return QString::number(qVariantValue<int>(value));
+    else {
+        Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class ArgumentType>
+QString keyArgument(const ArgumentType& argument)
+{
+    typedef typename ArgumentType::Property Property;
+    typedef typename ArgumentType::Comparator Comparator;
+
+    QString pattern = operatorString(argument.op, argument.valueList.count());
+    pattern = pattern.arg(propertyNameString(argument.property));
+
+    foreach (QVariant value, argument.valueList)
+        pattern = pattern.arg(argumentValue(value));
+
+    return pattern;
+}
+
+template <class Key>
+QString keyFilter(const Key& key)
+{
+    typedef typename Key::ArgumentType ArgumentType;
+
+    QStringList arguments;
+    foreach (ArgumentType argument, key.arguments())
+        arguments << keyArgument<ArgumentType>(argument);
+
+    foreach (const Key& subkey, key.subKeys())
+        arguments << keyFilter<Key>(subkey);
+
+    QString filter = arguments.size() > 1 ? QString(key.isNegated() ? "!(%1)" : "(%1)") :
+                                            QString(key.isNegated() ? "!(%1)" : "%1");
+    return filter.arg(arguments.join(combineOperatorString(key.combiner())));
+}
+
+template <class SortKey>
+QString sortKey(const SortKey& sortKey)
+{
+    typedef typename SortKey::ArgumentType ArgumentType;
+
+    QString orderCondition;
+    foreach (ArgumentType argument, sortKey.arguments())
+        if (argument.second == Qt::AscendingOrder)
+            orderCondition += QString(" ASC(%1)").arg(propertyNameString(argument.first));
+        else
+            orderCondition += QString(" DESC(%1)").arg(propertyNameString(argument.first));
+
+    if (!orderCondition.isEmpty())
+        return QString("ORDER BY %1").arg(orderCondition);
+
+    return QString();
+}
+
+QString keyQuery(const QMailMessageKey& key, const QMailMessageSortKey& sort = QMailMessageSortKey())
+{
+    QString query("SELECT ?mail \n"
+                  "WHERE { \n"
+                  "?mail rdf:type nmo:Email . \n"
+                  "%1 \n"
+                  "FILTER %2 \n"
+                  "} %3\n");
+
+    return query.arg(keyStatment("?mail", key, sort), keyFilter(key), sortKey(sort));
+}
+
+QString keyQuery(const QMailFolderKey& key, const QMailFolderSortKey& sort = QMailFolderSortKey())
+{
+    QString query("SELECT ?folder \n"
+                  "WHERE { \n"
+                  "?folder rdf:type nmo:MailFolder . \n"
+                  "%1 \n"
+                  "FILTER %2 \n"
+                  "} %3\n");
+
+    return query.arg(keyStatment("?folder", key, sort), keyFilter(key), sortKey(sort));
+}
+
+QString keyQuery(const QMailAccountKey& key, const QMailAccountSortKey& sort = QMailAccountSortKey())
+{
+    QString query("SELECT ?account \n"
+                  "WHERE { \n"
+                  "?account rdf:type nmo:Mailbox . \n"
+                  "%1 \n"
+                  "FILTER %2 \n"
+                  "} %3\n");
+
+    return query.arg(keyStatment("?account", key, sort), keyFilter(key), sortKey(sort));
+}
+
+QString keyCount(const QMailMessageKey& key)
+{
+    QString query("SELECT COUNT(?mail) AS count \n"
+                  "WHERE { \n"
+                  "?mail rdf:type nmo:Email . \n"
+                  "%1 \n"
+                  "FILTER %2 \n"
+                  "}\n");
+
+    return query.arg(keyStatment("?mail", key, QMailMessageSortKey()), keyFilter(key));
+}
+
+QString keyCount(const QMailFolderKey& key)
+{
+    QString query("SELECT COUNT(?folder) AS count \n"
+                  "WHERE { \n"
+                  "?folder rdf:type nmo:MailFolder . \n"
+                  "%1 \n"
+                  "FILTER %2 \n"
+                  "}\n");
+
+    return query.arg(keyStatment("?folder", key, QMailFolderSortKey()), keyFilter(key));
+}
+
+QString keyCount(const QMailAccountKey& key)
+{
+    QString query("SELECT COUNT(?account) AS count \n"
+                  "WHERE { \n"
+                  "?account rdf:type nmo:Mailbox . \n"
+                  "%1 \n"
+                  "FILTER %2 \n"
+                  "}\n");
+
+    return query.arg(keyStatment("?account", key, QMailAccountSortKey()), keyFilter(key));
+}
+
+template <class Key>
+void debugKey(const Key& key)
+{
+    typedef typename Key::ArgumentType ArgumentType;
+
+    qDebug() << "Key Combiner:" << key.combiner();
+    qDebug() << "Key Is empty:" << key.isEmpty();
+    qDebug() << "Key Non Matching:" << key.isNonMatching();
+    qDebug() << "Key Is Negated:" << key.isNegated();
+
+    foreach (ArgumentType argument, key.arguments())
+    {
+        qDebug() << "Argument Property:" << argument.property;
+        qDebug() << "Argument Comparator:" << argument.op;
+        foreach (QVariant value, argument.valueList)
+            qDebug() << "Argument Value List:" << value;
+    }
+
+    foreach (const Key& subkey, key.subKeys())
+        debugKey(subkey);
+}
+
+} // End namespace
+
+
+QString nmoRecipients(const QList<QMailAddress>& recipients)
+{
+    QString result;
+    foreach (const QMailAddress& address, recipients)
+    {
+        QString triplet(QString(
+    "        nmo:recipient [\n"
+    "            rdf:type nco:Contact ;\n"
+    "            nco:fullname \"%1\" ; \n"
+    "            nco:hasEmailAddress <mailto:%2> ] ;\n")
+                .arg(address.name())
+                .arg(address.address()));
+        result.append(triplet);
+    }
+    return result;
+}
+
+template <class T>
+T IdFromUri(const QString& uri)
+{
+    int pos = uri.indexOf('#');
+    if (pos >= 0)
+    {
+        bool ok = false;
+        quint64 postfix = uri.right(uri.length() - pos-1).toULongLong(&ok);
+
+        if (ok)
+            return T(postfix);
+    }
+
+    return T();
+}
+
+} // End of namespace
+
+void SparqlMailStore::addMessage(QMailMessageMetaData* metaData)
+{
+    SparqlUri uri("qmf://groove.harmattan.com/email#");
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT {\n"
+    "   <%1> rdf:type nmo:Email ;\n"
+    "        nie:isLogicalPartOf <qmf://groove.nokia.com/folder#%2> ;\n"
+    "        nmo:sender [\n"
+    "            rdf:type nco:Contact ;\n"
+    "            nco:fullname \"%3\" ; \n"
+    "            nco:hasEmailAddress <mailto:%4> ] ;\n"
+
+    + nmoRecipients(metaData->to()) +
+
+    "        nmo:messageSubject \"%5\" ;\n"
+    "        nmo:sentDate \"%6\"^^xsd:dateTime ;\n"
+    "        nmo:status \"%7\"^^xsd:integer ;\n"
+    "        nie:relatedTo <qmf://groove.nokia.com/accounts#%8> ;\n"
+    "        nie:isStoredAs [\n"
+    "            rdf:type nie:DataObject ;\n"
+    "            nie:dataSource <%9> ] ;\n"
+    "        nmo:messageId <%10> ;\n"
+    "        nie:contentSize \"%11\"^^xsd:integer ;\n"
+    "        nie:mimeType \"%12\" ;\n"
+    "        nmo:inReplyTo <%13> ;\n"
+    "        nmo:messageHeader [\n"
+    "            rdf:type nmo:MessageHeader ;\n"
+    "            nmo:headerName \"responseType\" ;\n"
+    "            nmo:headerValue \"%14\" ] ;\n"
+    "        nmo:receivedDate \"%15\"^^xsd:dateTime .\n"
+    "}").arg(uri.uri())
+        .arg(metaData->parentFolderId().toULongLong())
+        .arg(metaData->from().name())
+        .arg(metaData->from().address())
+        .arg(metaData->subject())
+        .arg(QMailTimeStamp(metaData->date()).toLocalTime().toString())
+        .arg(static_cast<int>(metaData->status()))
+        .arg(metaData->parentAccountId().toULongLong())
+        .arg(::contentUri(*metaData))
+        .arg(metaData->serverUid())
+        .arg(metaData->size())
+        .arg(static_cast<int>(metaData->content()))
+        .arg(metaData->inResponseTo().toULongLong())
+        .arg(metaData->responseType())
+        .arg(QMailTimeStamp(metaData->receivedDate()).toLocalTime().toString()));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return;
+    }
+
+    qDebug() << "Query succeeded";
+    metaData->setId(QMailMessageId(uri.id()));
+}
+
+void SparqlMailStore::addFolder(QMailFolder* folder)
+{
+    SparqlUri uri("qmf://groove.nokia.com/folder#");
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "<%1> rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName \"%2\" ; \n"
+    "   nie:isLogicalPartOf <qmf://groove.nokia.com/folder#%3> ; \n"
+    "   nie:relatedTo <qmf://groove.nokia.com/accounts#%4> ; \n"
+    "   nmo:folderDisplayName \"%5\" ; \n"
+    "   nmo:status \"%6\"^^xsd:integer ; \n"
+    "   nmo:serverCount \"%7\"^^xsd:integer ; \n"
+    "   nmo:serverUnreadCount \"%8\"^^xsd:integet . \n"
+    "}").arg(uri.uri())
+        .arg(folder->path())
+        .arg(folder->parentFolderId().toULongLong())
+        .arg(folder->parentAccountId().toULongLong())
+        .arg(folder->displayName())
+        .arg(folder->status())
+        .arg(folder->serverCount())
+        .arg(folder->serverUnreadCount()));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return;
+    }
+
+    qDebug() << "Query succeeded";
+    folder->setId(QMailFolderId(uri.id()));
+
+    // TBD: Update folder links also
+}
+
+void SparqlMailStore::addAccount(QMailAccount* account)
+{
+    SparqlUri uri("qmf://groove.nokia.com/accounts#");
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "<%1> rdf:type nmo:Mailbox ; \n"
+    "   nmo:accountName \"%2\" ; \n"
+    "   nmo:status \"%3\"^^xsd:integer ; \n"
+    "   nmo:signature \"%4\" ; \n"
+    "   nmo:fromAddress [ \n"
+    "       rdf:type nco:EmailAddress ; \n"
+    "       nco:emailAddress \"%5\" ] . \n"
+    "}").arg(uri.uri())
+        .arg(account->name())
+        .arg(account->status())
+        .arg(account->signature())
+        .arg(account->fromAddress().toString(true)));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return;
+    }
+
+    qDebug() << "Query succeeded";
+    account->setId(QMailAccountId(uri.id()));
+}
+
+QMailAccount SparqlMailStore::account(const QMailAccountId& id) const
+{
+    QMailAccount account;
+
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?name ?signature ?fromAddress \n"
+    "WHERE { \n"
+    "<qmf://groove.nokia.com/accounts#%1> rdf:type nmo:Mailbox ; \n"
+    "   nmo:accountName ?name ; \n"
+//    "   nmo:status ?status ; \n"
+    "   nmo:signature ?signature ; \n"
+    "   nmo:fromAddress [ \n"
+    "       rdf:type nco:EmailAddress ; \n"
+    "       nco:emailAddress ?fromAddress ] . \n"
+    "}").arg(id.toULongLong()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return account;
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    QStringList list = result.fetchRow();
+
+    account.setId(id);
+    account.setName(list.at(0));
+//  account.setStatus(list.at(1).toULongLong());
+    account.setSignature(list.at(1));
+    account.setFromAddress(QMailAddress(list.at(2)));
+
+    return account;
+}
+
+QMailFolder SparqlMailStore::folder(const QMailFolderId& id) const
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?name ?parentFolder ?parentAccount ?displayName \n"
+    "WHERE { \n"
+    "<qmf://groove.nokia.com/folder#%1> rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName ?name ; \n"
+    "   nie:isLogicalPartOf ?parentFolder ; \n"
+    "   nie:relatedTo ?parentAccount ; \n"
+    "   nmo:folderDisplayName ?displayName ; \n"
+//    "   nmo:status ?status ; \n"
+//    "   nmo:serverCount ?serverCount ; \n"
+//    "   nmo:serverUnreadCount ?serverUnreadCount . \n"
+    "}").arg(id.toULongLong()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return QMailFolder();
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    QStringList list = result.fetchRow();
+
+    QMailFolder folder(list.at(0), IdFromUri<QMailFolderId>(list.at(1)), IdFromUri<QMailAccountId>(list.at(2)));
+    folder.setId(id);
+    folder.setDisplayName(list.at(3));
+//    folder.setStatus(list.at(4).toULongLong());
+//    folder.setServerCount(list.at(5).toUInt());
+//    folder.setServerUnreadCount(list.at(6).toUInt());
+
+    return folder;
+}
+
+QMailMessage SparqlMailStore::message(const QMailMessageId& id) const
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?fullName ?mailAddress \n"
+    "WHERE { \n"
+    "<qmf://groove.harmattan.com/email#%1> rdf:type nmo:Email ;\n"
+    "nmo:recipient [\n"
+    "    rdf:type nco:Contact ;\n"
+    "    nco:fullname ?fullName ; \n"
+    "    nco:hasEmailAddress ?mailAddress ] \n"
+    "}").arg(id.toULongLong()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return QMailMessage();
+    }
+
+    SparqlResult result = query.result();
+
+    QList<QMailAddress> recipients;
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        recipients.push_back(QMailAddress(row.at(0), row.at(1)));
+    }
+
+    query.prepare(QString(
+    "SELECT ?folderId ?senderFullName ?senderEmailAddress ?messageSubject ?sentDate ?status ?accountId ?dataSource ?uid ?contentSize ?mimeType ?inReplyTo ?headerValue ?receivedDate \n"
+    "WHERE { \n"
+    "   <qmf://groove.harmattan.com/email#%1> rdf:type nmo:Email ;\n"
+    "        nie:isLogicalPartOf ?folderId ;\n"
+    "        nmo:sender [\n"
+    "            rdf:type nco:Contact ;\n"
+    "            nco:fullname ?senderFullName ; \n"
+    "            nco:hasEmailAddress ?senderEmailAddress ] ;\n"
+    "        nmo:messageSubject ?messageSubject ;\n"
+    "        nmo:sentDate ?sentDate ;\n"
+    "        nmo:status ?status ;\n"
+    "        nie:relatedTo ?accountId ;\n"
+    "        nie:isStoredAs [\n"
+    "            rdf:type nie:DataObject ;\n"
+    "            nie:dataSource ?dataSource ] ;\n"
+    "        nmo:messageId ?uid ;\n"
+    "        nie:contentSize ?contentSize ;\n"
+    "        nie:mimeType ?mimeType ;\n"
+    "        nmo:inReplyTo ?inReplyTo ;\n"
+    "        nmo:messageHeader [\n"
+    "            rdf:type nmo:MessageHeader ;\n"
+    "            nmo:headerName \"responseType\" ;\n"
+    "            nmo:headerValue ?headerValue ] ;\n"
+    "        nmo:receivedDate ?receivedDate .\n"
+    "}").arg(id.toULongLong()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return QMailMessage();
+    }
+
+    result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    QStringList list = result.fetchRow();
+
+    QMailMessage message;
+    message.setId(id);
+    message.setParentFolderId(IdFromUri<QMailFolderId>(list.at(0)));
+    message.setFrom(QMailAddress(list.at(1), list.at(2)));
+    message.setSubject(list.at(3));
+    message.setDate(QMailTimeStamp(list.at(4)));
+    message.setStatus(list.at(5).toULongLong());
+    message.setParentAccountId(IdFromUri<QMailAccountId>(list.at(6)));
+    message.setServerUid(list.at(10));
+    message.setSize(list.at(9).toUInt());
+    message.setContent((QMailMessageMetaDataFwd::ContentType)list.at(10).toInt());
+    message.setInResponseTo(QMailMessageId(IdFromUri<QMailMessageId>(list.at(11))));
+    message.setResponseType((QMailMessageMetaDataFwd::ResponseType)list.at(12).toInt());
+    message.setReceivedDate(QMailTimeStamp(list.at(13)));
+
+    message.setTo(recipients);
+
+    return message;
+}
+
+int SparqlMailStore::countAccounts(const QMailAccountKey& key) const
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyCount(key));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return 0;
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    return result.fetchRow().first().toInt();
+}
+
+int SparqlMailStore::countFolders(const QMailFolderKey& key) const
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyCount(key));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return 0;
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    return result.fetchRow().first().toInt();
+}
+
+int SparqlMailStore::countMessages(const QMailMessageKey& key) const
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyCount(key));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return 0;
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    return result.fetchRow().first().toInt();
+}
+
+
+QMailAccountIdList SparqlMailStore::queryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey) const
+{
+    QMailAccountIdList accountIdList;
+
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyQuery(key, sortKey));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return accountIdList;
+    }
+
+    SparqlResult result = query.result();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        accountIdList << IdFromUri<QMailAccountId>(row.first());
+    }
+
+    return accountIdList;
+}
+
+QMailFolderIdList SparqlMailStore::queryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey) const
+{
+    QMailFolderIdList folderIdList;
+
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyQuery(key, sortKey));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return folderIdList;
+    }
+
+    SparqlResult result = query.result();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        folderIdList << IdFromUri<QMailFolderId>(row.first());
+    }
+
+    return folderIdList;
+}
+
+QMailMessageIdList SparqlMailStore::queryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey) const
+{
+    QMailMessageIdList messageIdList;
+
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyQuery(key, sortKey));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return messageIdList;
+    }
+
+    SparqlResult result = query.result();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        messageIdList << IdFromUri<QMailMessageId>(row.first());
+    }
+
+    return messageIdList;
+}
+
+void SparqlMailStore::updateMessage(const QMailMessageMetaData& metedata)
+{
+    Q_UNUSED(metedata);
+}
+
+void SparqlMailStore::updateFolder(const QMailFolder& folder)
+{
+    Q_UNUSED(folder);
+}
+
+void SparqlMailStore::updateAccount(const QMailAccount& account)
+{
+    Q_UNUSED(account);
+}
+
+void SparqlMailStore::removeMessage(const QMailMessageMetaData& metadata)
+{
+    Q_UNUSED(metadata);
+}
+
+void SparqlMailStore::removeFolder(const QMailFolder& folder)
+{
+    Q_UNUSED(folder);
+}
+
+void SparqlMailStore::removeAccount(const QMailAccount& account)
+{
+    Q_UNUSED(account);
+}
+
+void SparqlMailStore::setupStandardFolder(QMailFolder::StandardFolder folder, const QString& name)
+{
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "<%1> rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName \"%2\" ; \n"
+    "   nie:isLogicalPartOf <qmf://groove.nokia.com/folder#%3> ; \n"
+    "   nie:relatedTo <qmf://groove.nokia.com/accounts#%4> ; \n"
+    "   nmo:folderDisplayName \"%5\" ; \n"
+    "   nmo:status \"%6\"^^xsd:integer ; \n"
+    "   nmo:serverCount \"%7\"^^xsd:integer ; \n"
+    "   nmo:serverUnreadCount \"%8\"^^xsd:integet . \n"
+    "}").arg("qmf://groove.nokia.com/folder#" + QString::number(folder))
+        .arg(name)
+        .arg(0)
+        .arg(0)
+        .arg(name)
+        .arg(0)
+        .arg(0)
+        .arg(0));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return;
+    }
+
+    qDebug() << "Query succeeded";
+}
diff --git a/tools/sparql-import/sparqlmailstore.h b/tools/sparql-import/sparqlmailstore.h
new file mode 100644
index 0000000..60f8b20
--- /dev/null
+++ b/tools/sparql-import/sparqlmailstore.h
@@ -0,0 +1,45 @@
+#ifndef MAILSTORE_H
+#define MAILSTORE_H
+
+#include <qmailmessage.h>
+#include <qmailfolder.h>
+#include <qmailaccount.h>
+#include <qmailaccountkey.h>
+#include <qmailfolderkey.h>
+#include <qmailmessagekey.h>
+#include <qmailaccountsortkey.h>
+#include <qmailfoldersortkey.h>
+#include <qmailmessagesortkey.h>
+
+class SparqlMailStore
+{
+public:
+    void addMessage(QMailMessageMetaData* metaData);
+    void addFolder(QMailFolder* folder);
+    void addAccount(QMailAccount* account);
+
+    QMailAccount account(const QMailAccountId& id) const;
+    QMailFolder folder(const QMailFolderId& id) const;
+    QMailMessage message(const QMailMessageId& id) const;
+
+    int countAccounts(const QMailAccountKey& key = QMailAccountKey()) const;
+    int countFolders(const QMailFolderKey& key = QMailFolderKey()) const;
+    int countMessages(const QMailMessageKey& key = QMailMessageKey()) const;
+
+    QMailAccountIdList queryAccounts(const QMailAccountKey &key = QMailAccountKey(), const QMailAccountSortKey &sortKey = QMailAccountSortKey()) const;
+    QMailFolderIdList queryFolders(const QMailFolderKey &key = QMailFolderKey(), const QMailFolderSortKey &sortKey = QMailFolderSortKey()) const;
+    QMailMessageIdList queryMessages(const QMailMessageKey &key = QMailMessageKey(), const QMailMessageSortKey &sortKey = QMailMessageSortKey()) const;
+
+    void updateMessage(const QMailMessageMetaData& meteData);
+    void updateFolder(const QMailFolder& folder);
+    void updateAccount(const QMailAccount& account);
+
+    void removeMessage(const QMailMessageMetaData& metaData);
+    void removeFolder(const QMailFolder& folder);
+    void removeAccount(const QMailAccount& account);
+
+    void setupStandardFolder(QMailFolder::StandardFolder folder, const QString& name);
+
+};
+
+#endif // MAILSTORE_H
