diff --cc qmf.pro
index aaa9ee7,433465f..c7035b3
--- a/qmf.pro
+++ b/qmf.pro
@@ -2,6 +2,7 @@ TEMPLATE = subdirs
 SUBDIRS = src/libraries/qtopiamail \
           src/libraries/messageserver \
           src/libraries/qmfutil \
+          src/libraries/sparql \
           src/plugins/messageservices/imap \
           src/plugins/messageservices/pop \
           src/plugins/messageservices/smtp \
diff --cc src/libraries/qtopiamail/qtopiamail.pro
index 08344a9..3a82267 100644
--- a/src/libraries/qtopiamail/qtopiamail.pro
+++ b/src/libraries/qtopiamail/qtopiamail.pro
@@ -151,3 +151,23 @@ TRANSLATIONS += libqtopiamail-ar.ts \
 
 include(../../common.pri)
 
+sparql {
+
+DEFINES += SPARQL_STORE
+
+HEADERS += qmailstore_sparql.h \
+
+SOURCES += qmailstore_sparql.cpp \
+
+INCLUDEPATH += ../sparql ../sparql/tracker
+
+LIBS += -L../sparql -lsparql
+
+} else {
+
+HEADERS += qmailstore_p.h \
+
+SOURCES += qmailstore_p.cpp \
+
+}
+
diff --git a/src/libraries/qtopiamail/qmailstore_sparql.cpp b/src/libraries/qtopiamail/qmailstore_sparql.cpp
new file mode 100644
index 0000000..8fce7d2
--- /dev/null
+++ b/src/libraries/qtopiamail/qmailstore_sparql.cpp
@@ -0,0 +1,3953 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the either Technology Preview License Agreement or the
+** Beta Release License Agreement.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmailstore_sparql.h"
+#include "locks_p.h"
+#include "qmailcontentmanager.h"
+#include "qmailmessageremovalrecord.h"
+#include "qmailtimestamp.h"
+#include "qmailnamespace.h"
+#include "qmaillog.h"
+#include <QCoreApplication>
+#include <QDir>
+#include <QFile>
+
+#include <QTextCodec>
+
+#include "sparqlquery.h"
+#include "sparqlresult.h"
+#include "sparqluri.h"
+
+
+#define Q_USE_SQLITE
+
+// When using GCC 4.1.1 on ARM, TR1 functional cannot be included when RTTI
+// is disabled, since it automatically instantiates some code using typeid().
+//#include <tr1/functional>
+//using std::tr1::bind;
+//using std::tr1::cref;
+#include "bind_p.h"
+
+using nonstd::tr1::bind;
+using nonstd::tr1::cref;
+
+
+
+
+namespace { // none of this code is externally visible:
+
+//using namespace QMailDataComparator;
+using namespace QMailKey;
+
+// We allow queries to be specified by supplying a list of message IDs against
+// which candidates will be matched; this list can become too large to be
+// expressed directly in SQL.  Instead, we will build a temporary table to
+// match against when required...
+// The most IDs we can include in a query is currently 999; set an upper limit
+// below this to allow for other variables in the same query, bearing in mind
+// that there may be more than one clause containing this number of IDs in the
+// same query...
+const int IdLookupThreshold = 256;
+
+// Note on retry logic - it appears that SQLite3 will return a SQLITE_BUSY error (5)
+// whenever there is contention on file locks or mutexes, and that these occurrences
+// are not handled by the handler installed by either sqlite3_busy_timeout or
+// sqlite3_busy_handler.  Furthermore, the comments for sqlite3_step state that if
+// the SQLITE_BUSY error is returned whilst in a transaction, the transaction should
+// be rolled back.  Therefore, it appears that we must handle this error by retrying
+// at the QMailStore level, since this is the level where we perform transactions.
+const int Sqlite3BusyErrorNumber = 5;
+
+const int Sqlite3ConstraintErrorNumber = 19;
+
+const uint pid = static_cast<uint>(QCoreApplication::applicationPid() & 0xffffffff);
+
+// Helper class for automatic unlocking
+template<typename Mutex>
+class Guard
+{
+    Mutex &mutex;
+    bool locked;
+
+public:
+    enum { DefaultTimeout = 1000 };
+
+    Guard(Mutex& m)
+        : mutex(m),
+          locked(false) 
+    {
+    }
+
+    ~Guard()
+    {
+        unlock();
+    }
+
+    bool lock(int timeout = DefaultTimeout)
+    {
+        return (locked = mutex.lock(timeout));
+    }
+
+    void unlock()
+    {
+        if (locked) {
+            mutex.unlock();
+            locked = false; 
+        }
+    }
+};
+
+typedef Guard<ProcessMutex> MutexGuard;
+
+
+template <typename IdType>
+QVariantList idValueList(const QList<IdType>& ids)
+{
+    QVariantList values;
+
+    foreach (const IdType& id, ids)
+        values.append(QVariant(id.toULongLong()));
+
+    return values;
+}
+
+
+QString escape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(escapee, QString(escaper) + escapee);
+}
+
+QString unescape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(QString(escaper) + escapee, escapee);
+}
+
+QString contentUri(const QString &scheme, const QString &identifier)
+{
+    if (scheme.isEmpty())
+        return QString();
+
+    // Formulate a URI from the content scheme and identifier
+    return escape(scheme, ':') + ':' + escape(identifier, ':');
+}
+
+QString contentUri(const QMailMessageMetaData &message)
+{
+    return contentUri(message.contentScheme(), message.contentIdentifier());
+}
+
+QPair<QString, QString> extractUriElements(const QString &uri)
+{
+    int index = uri.indexOf(':');
+    while ((index != -1) && (uri.at(index - 1) == '\\'))
+        index = uri.indexOf(':', index + 1);
+
+    return qMakePair(unescape(uri.mid(0, index), ':'), unescape(uri.mid(index + 1), ':'));
+}
+
+
+QString identifierValue(const QString &str)
+{
+    QStringList identifiers(QMail::messageIdentifiers(str));
+    if (!identifiers.isEmpty()) {
+        return identifiers.first();
+    }
+
+    return QString();
+}
+
+QStringList identifierValues(const QString &str)
+{
+    return QMail::messageIdentifiers(str);
+}
+
+
+const char *WellKnownUris[] = {
+    "qmf://groove.harmattan.com/email#",
+    "qmf://groove.nokia.com/folder#",
+    "qmf://groove.nokia.com/accounts#" };
+
+template <class T, int INDEX>
+class WellKnownUri : public SparqlUri
+{
+public:
+    WellKnownUri() : SparqlUri(WellKnownUris[INDEX]) {}
+    WellKnownUri(const T& id) : SparqlUri(WellKnownUris[INDEX], id.toULongLong()) {}
+    T id() const { return T(id()); }
+    operator T () { return id(); }
+};
+
+typedef WellKnownUri<QMailMessageId, 0> MailMessageUri;
+typedef WellKnownUri<QMailFolderId,  1> MailFolderUri;
+typedef WellKnownUri<QMailAccountId, 2> MailAccountUri;
+
+QString combineOperatorString(QMailKey::Combiner op)
+{
+    switch (op)
+    {
+    case And:
+        return " && ";
+        break;
+
+    case Or:
+        return " || ";
+        break;
+
+    case None:
+        break;
+    }
+
+    return QString();
+}
+
+QString operatorStringPattern(int argNumber, const QString& op, const QString& comp)
+{
+    QStringList pattern;
+    for (int i = 0; i<argNumber; i++)
+        pattern << "(%1 " + op + " %" + QString::number(i+2) + ")";
+
+    if (argNumber > 1)
+        return "(" + pattern.join(comp) + ")";
+    else
+        return pattern.join(comp);
+}
+
+template <class Comparator>
+QString operatorString(Comparator op, int argsNumber = 1);
+
+template <>
+QString operatorString<QMailKey::Comparator>(QMailKey::Comparator op, int argsNumber)
+{
+    switch (op)
+    {
+    case Equal:
+        //  "(%1 = \"%2\")" : "(%1 = \"%2\") || (%1 = \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "=", "") : operatorStringPattern(argsNumber, "=", " || "));
+        break;
+
+    case NotEqual:
+        // "(%1 != \"%2\")" : "(%1 != \"%2\") && (%1 != \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "!=", "") : operatorStringPattern(argsNumber, "!=", " && "));
+        break;
+
+    case LessThan:
+        return "(%1 < %2)";
+        break;
+
+    case LessThanEqual:
+        return "(%1 <= %2)";
+        break;
+
+    case GreaterThan:
+        return "(%1 > %2)";
+        break;
+
+    case GreaterThanEqual:
+        return "(%1 >= %2)";
+        break;
+
+    case Includes:
+    case Present:
+        // "(%1 & \"%2\")" : "(%1 = \"%2\") || (%1 = \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "&", "") : operatorStringPattern(argsNumber, "=", " || "));
+        break;
+
+    case Excludes:
+    case Absent:
+        // "!(%1 & \"%2\")" : "(%1 != \"%2\") && (%1 != \"%3\")"
+        return (argsNumber == 1 ? "(!" + operatorStringPattern(argsNumber, "&", "") + ")": operatorStringPattern(argsNumber, "!=", " && "));
+        break;
+    }
+
+    return QString();
+}
+
+template <class Property>
+QString propertyNameString(Property property);
+
+template <>
+QString propertyNameString<QMailMessageKey::Property>(QMailMessageKey::Property property)
+{
+    switch (property)
+    {
+        case QMailMessageKey::Id:
+            return "?mail";
+
+        case QMailMessageKey::Type:
+            return "?type";
+
+        case QMailMessageKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailMessageKey::Sender:
+            return "?sender";
+
+        case QMailMessageKey::Recipients:
+            return "?recipients";
+
+        case QMailMessageKey::Subject:
+            return "?subject";
+
+        case QMailMessageKey::TimeStamp:
+            return "?timestamp";
+
+        case QMailMessageKey::Status:
+            return "?status";
+
+        case QMailMessageKey::Conversation:
+            return "?conversation";
+
+        case QMailMessageKey::ReceptionTimeStamp:
+            return "?receptionTimeStamp";
+
+        case QMailMessageKey::ServerUid:
+            return "?serverUid";
+
+        case QMailMessageKey::Size:
+            return "?size";
+
+        case QMailMessageKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailMessageKey::AncestorFolderIds:
+            return "?ancestorFolderIds";
+
+        case QMailMessageKey::ContentType:
+            return "?contentType";
+
+        case QMailMessageKey::PreviousParentFolderId:
+            return "?previousParentFolderId";
+
+        case QMailMessageKey::ContentScheme:
+            return "?contentScheme";
+
+        case QMailMessageKey::ContentIdentifier:
+            return "?contentIdentifier";
+
+        case QMailMessageKey::InResponseTo:
+            return "?inResponseTo";
+
+        case QMailMessageKey::ResponseType:
+            return "?responseType";
+
+        case QMailMessageKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailFolderKey::Property>(QMailFolderKey::Property property)
+{
+    switch (property)
+    {
+        case QMailFolderKey::Id:
+            return "?folder";
+
+        case QMailFolderKey::Path:
+            return "?path";
+
+        case QMailFolderKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailFolderKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailFolderKey::DisplayName:
+            return "?displayName";
+
+        case QMailFolderKey::Status:
+            return "?status";
+
+        case QMailFolderKey::AncestorFolderIds:
+            return "?ancestorFolderIds";
+
+        case QMailFolderKey::ServerCount:
+            return "?serverCount";
+
+        case QMailFolderKey::ServerUnreadCount:
+            return "?serverUnreadCount";
+
+        case QMailFolderKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailAccountKey::Property>(QMailAccountKey::Property property)
+{
+    switch (property)
+    {
+        case QMailAccountKey::Id:
+            return "?account";
+
+        case QMailAccountKey::Name:
+            return "?name";
+
+        case QMailAccountKey::MessageType:
+            return "?messageType";
+
+        case QMailAccountKey::FromAddress:
+            return "?fromAddress";
+
+        case QMailAccountKey::Status:
+            return "?status";
+
+        case QMailAccountKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailMessageSortKey::Property>(QMailMessageSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailMessageSortKey::Id:
+            return propertyNameString(QMailMessageKey::Id);
+
+        case QMailMessageSortKey::Type:
+            return propertyNameString(QMailMessageKey::Type);
+
+        case QMailMessageSortKey::ParentFolderId:
+            return propertyNameString(QMailMessageKey::ParentFolderId);
+
+        case QMailMessageSortKey::Sender:
+            return propertyNameString(QMailMessageKey::Sender);
+
+        case QMailMessageSortKey::Recipients:
+            return propertyNameString(QMailMessageKey::Recipients);
+
+        case QMailMessageSortKey::Subject:
+            return propertyNameString(QMailMessageKey::Subject);
+
+        case QMailMessageSortKey::TimeStamp:
+            return propertyNameString(QMailMessageKey::TimeStamp);
+
+        case QMailMessageSortKey::Status:
+            return propertyNameString(QMailMessageKey::Status);
+
+        case QMailMessageSortKey::ReceptionTimeStamp:
+            return propertyNameString(QMailMessageKey::ReceptionTimeStamp);
+
+        case QMailMessageSortKey::ServerUid:
+            return propertyNameString(QMailMessageKey::ServerUid);
+
+        case QMailMessageSortKey::Size:
+            return propertyNameString(QMailMessageKey::Size);
+
+        case QMailMessageSortKey::ParentAccountId:
+            return propertyNameString(QMailMessageKey::ParentAccountId);
+
+        case QMailMessageSortKey::ContentType:
+            return propertyNameString(QMailMessageKey::ContentType);
+
+        case QMailMessageSortKey::PreviousParentFolderId:
+            return propertyNameString(QMailMessageKey::PreviousParentFolderId);
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailFolderSortKey::Property>(QMailFolderSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailFolderSortKey::Id:
+            return propertyNameString(QMailFolderKey::Id);
+
+        case QMailFolderSortKey::Path:
+            return propertyNameString(QMailFolderKey::Path);
+
+        case QMailFolderSortKey::ParentFolderId:
+            return propertyNameString(QMailFolderKey::ParentFolderId);
+
+        case QMailFolderSortKey::ParentAccountId:
+            return propertyNameString(QMailFolderKey::ParentAccountId);
+
+        case QMailFolderSortKey::DisplayName:
+            return propertyNameString(QMailFolderKey::DisplayName);
+
+        case QMailFolderSortKey::Status:
+            return propertyNameString(QMailFolderKey::Status);
+
+        case QMailFolderSortKey::ServerCount:
+            return propertyNameString(QMailFolderKey::ServerCount);
+
+        case QMailFolderSortKey::ServerUnreadCount:
+            return propertyNameString(QMailFolderKey::ServerUnreadCount);
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailAccountSortKey::Property>(QMailAccountSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailAccountSortKey::Id:
+            return propertyNameString(QMailAccountKey::Id);
+
+        case QMailAccountSortKey::Name:
+            return propertyNameString(QMailAccountKey::Name);
+
+        case QMailAccountSortKey::MessageType:
+            return propertyNameString(QMailAccountKey::MessageType);
+
+        case QMailAccountSortKey::Status:
+            return propertyNameString(QMailAccountKey::Status);
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class Property>
+QString sparqlPropertyStatmentString(const QString& uri, Property property);
+
+template <>
+QString sparqlPropertyStatmentString<QMailMessageKey::Property>(const QString& uri, QMailMessageKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailMessageKey::Id:
+            return QString();
+
+        case QMailMessageKey::Type:
+            return QString();
+
+        case QMailMessageKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Sender:
+            return QString("%1 nmo:sender [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Recipients:
+            return QString("%1 nmo:recipient [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Subject:
+            return QString("%1 nmo:messageSubject %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::TimeStamp:
+            return QString("%1 nmo:sentDate %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Conversation:
+            return QString();
+
+        case QMailMessageKey::ReceptionTimeStamp:
+            return QString();
+
+        case QMailMessageKey::ServerUid:
+            return QString("%1 nmo:messageId %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Size:
+            return QString("%1 nie:contentSize %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::AncestorFolderIds:
+            return QString();
+
+        case QMailMessageKey::ContentType:
+            return QString();
+
+        case QMailMessageKey::PreviousParentFolderId:
+            return QString();
+
+        case QMailMessageKey::ContentScheme:
+            return QString();
+
+        case QMailMessageKey::ContentIdentifier:
+            return QString("%1 nie:isStoredAs [ rdf:type nie:DataObject ; nie:dataSource %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::InResponseTo:
+            return QString("%1 nmo:inReplyTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::ResponseType:
+            return QString();
+
+        case QMailMessageKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailFolderKey::Property>(const QString& uri, QMailFolderKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailFolderKey::Id:
+            return QString();
+
+        case QMailFolderKey::Path:
+            return QString("%1 nmo:folderName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::DisplayName:
+            return QString("%1 nmo:folderDisplayName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::AncestorFolderIds:
+            return QString();
+
+        case QMailFolderKey::ServerCount:
+            return QString("%1 nmo:serverCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ServerUnreadCount:
+            return QString("%1 nmo:serverUnreadCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailAccountKey::Property>(const QString& uri, QMailAccountKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailAccountKey::Id:
+            return QString("%1 rdf:type %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Name:
+            return QString("%1 nmo:accountName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::MessageType:
+            return QString();
+
+        case QMailAccountKey::FromAddress:
+            return QString("%1 nmo:fromAddress [ rdf:type nco:EmailAddress ; nco:emailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailMessageSortKey::Property>(const QString& uri, QMailMessageSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailMessageSortKey::Id:
+            return QString();
+
+        case QMailMessageSortKey::Type:
+            return QString();
+
+        case QMailMessageSortKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Sender:
+            return QString("%1 nmo:sender [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Recipients:
+            return QString("%1 nmo:recipient [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Subject:
+            return QString("%1 nmo:messageSubject %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::TimeStamp:
+            return QString("%1 nmo:sentDate %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ReceptionTimeStamp:
+            return QString();
+
+        case QMailMessageSortKey::ServerUid:
+            return QString("%1 nmo:messageId %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Size:
+            return QString("%1 nie:contentSize %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ContentType:
+            return QString();
+
+        case QMailMessageSortKey::PreviousParentFolderId:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailFolderSortKey::Property>(const QString& uri, QMailFolderSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailFolderSortKey::Id:
+            return "id";
+
+        case QMailFolderSortKey::Path:
+            return QString("%1 nmo:folderName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::DisplayName:
+            return QString("%1 nmo:folderDisplayName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ServerCount:
+            return QString("%1 nmo:serverCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ServerUnreadCount:
+            return QString("%1 nmo:serverUnreadCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailAccountSortKey::Property>(const QString& uri, QMailAccountSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailAccountSortKey::Id:
+            return QString();
+
+        case QMailAccountSortKey::Name:
+            return QString("%1 nmo:accountName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountSortKey::MessageType:
+            return QString();
+
+        case QMailAccountSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class Key, class SortKey>
+QString keyStatment(const QString& uri, const Key& key, const SortKey& sort = SortKey())
+{
+    typedef typename Key::ArgumentType     ArgumentType;
+    typedef typename SortKey::ArgumentType SortArgumentType;
+
+    QStringList arguments;
+    foreach (SortArgumentType argument, sort.arguments())
+    {
+        QString statement = sparqlPropertyStatmentString(uri, argument.property /*argument.first*/);
+        if (!statement.isEmpty() && !arguments.contains(statement))
+            arguments << statement;
+    }
+
+    foreach (ArgumentType argument, key.arguments())
+    {
+        QString statement = sparqlPropertyStatmentString(uri, argument.property);
+        if (!statement.isEmpty() && !arguments.contains(statement))
+            arguments << statement;
+    }
+
+    foreach (const Key& subkey, key.subKeys())
+        arguments << keyStatment(uri, subkey, SortKey());
+
+    return arguments.join("\n");
+}
+
+QString argumentValue(const QVariant& value)
+{
+    if (qVariantCanConvert<QMailAccountId>(value))
+        return MailAccountUri(qVariantValue<QMailAccountId>(value));
+    else if (qVariantCanConvert<QMailFolderId>(value))
+        return MailFolderUri(qVariantValue<QMailFolderId>(value));
+    else if (qVariantCanConvert<QMailMessageId>(value))
+        return MailMessageUri(qVariantValue<QMailMessageId>(value));
+    else if (qVariantCanConvert<QString>(value))
+        return qVariantValue<QString>(value);
+    else if (qVariantCanConvert<int>(value))
+        return QString::number(qVariantValue<int>(value));
+    else {
+        Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class ArgumentType>
+QString keyArgument(const ArgumentType& argument)
+{
+    typedef typename ArgumentType::Property Property;
+    typedef typename ArgumentType::Comparator Comparator;
+
+    QString pattern = operatorString(argument.op, argument.valueList.count());
+    pattern = pattern.arg(propertyNameString(argument.property));
+
+    foreach (QVariant value, argument.valueList)
+        pattern = pattern.arg(argumentValue(value));
+
+    return pattern;
+}
+
+template <class Key>
+QString keyFilter(const Key& key)
+{
+    typedef typename Key::ArgumentType ArgumentType;
+
+    QStringList arguments;
+    foreach (ArgumentType argument, key.arguments())
+        arguments << keyArgument<ArgumentType>(argument);
+
+    foreach (const Key& subkey, key.subKeys())
+        arguments << keyFilter<Key>(subkey);
+
+    QString filter = arguments.size() > 1 ? QString(key.isNegated() ? "!(%1)" : "(%1)") :
+                                            QString(key.isNegated() ? "!(%1)" : "%1");
+    return filter.arg(arguments.join(combineOperatorString(key.combiner())));
+}
+
+template <class SortKey>
+QString sortKey(const SortKey& sortKey)
+{
+    typedef typename SortKey::ArgumentType ArgumentType;
+
+    QString orderCondition;
+    foreach (ArgumentType argument, sortKey.arguments())
+        if (argument.order == Qt::AscendingOrder)
+            orderCondition += QString(" ASC(%1)").arg(propertyNameString(/*argument.first*/ argument.property ));
+        else
+            orderCondition += QString(" DESC(%1)").arg(propertyNameString(/*argument.first*/ argument.property ));
+
+    if (!orderCondition.isEmpty())
+        return QString("ORDER BY %1").arg(orderCondition);
+
+    return QString();
+}
+
+QString keyQuery(const QMailMessageKey& key, const QMailMessageSortKey& sort = QMailMessageSortKey())
+{
+    QString query = QString("SELECT %1 \n"
+                            "WHERE { \n"
+                            "%1 rdf:type nmo:Email . \n"
+                            "%2"
+                            "%3"
+                            "} %4\n").arg(propertyNameString(QMailMessageKey::Id));
+
+    QString statement = keyStatment(propertyNameString(QMailMessageKey::Id), key, sort);
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter).arg(sortKey(sort));
+}
+
+QString keyQuery(const QMailFolderKey& key, const QMailFolderSortKey& sort = QMailFolderSortKey())
+{
+    QString query = QString("SELECT %1 \n"
+                            "WHERE { \n"
+                            "%1 rdf:type nmo:MailFolder . \n"
+                            "%2"
+                            "%3"
+                            "} %4\n").arg(propertyNameString(QMailFolderKey::Id));
+
+    QString statement = keyStatment(propertyNameString(QMailFolderKey::Id), key, sort);
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter).arg(sortKey(sort));
+}
+
+QString keyQuery(const QMailAccountKey& key, const QMailAccountSortKey& sort = QMailAccountSortKey())
+{
+    QString query = QString("SELECT %1 \n"
+                            "WHERE { \n"
+                            "%1 rdf:type nmo:Mailbox . \n"
+                            "%2"
+                            "%3"
+                            "} %4\n").arg(propertyNameString(QMailAccountKey::Id));
+
+    QString statement = keyStatment(propertyNameString(QMailAccountKey::Id), key, sort);
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter).arg(sortKey(sort));
+}
+
+QString keyCount(const QMailMessageKey& key)
+{
+    QString query("SELECT COUNT(?mail) AS count \n"
+                  "WHERE { \n"
+                  "?mail rdf:type nmo:Email . \n"
+                  "%1"
+                  "%2"
+                  "}\n");
+
+    QString statement = keyStatment("?mail", key, QMailAccountSortKey());
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter);
+}
+
+QString keyCount(const QMailFolderKey& key)
+{
+    QString query("SELECT COUNT(?folder) AS count \n"
+                  "WHERE { \n"
+                  "?folder rdf:type nmo:MailFolder . \n"
+                  "%1"
+                  "%2"
+                  "}\n");
+
+    QString statement = keyStatment("?folder", key, QMailAccountSortKey());
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter);
+}
+
+QString keyCount(const QMailAccountKey& key)
+{
+    QString query("SELECT COUNT(?account) AS count \n"
+                  "WHERE { \n"
+                  "?account rdf:type nmo:Mailbox . \n"
+                  "%1"
+                  "%2"
+                  "}\n");
+
+    QString statement = keyStatment("?account", key, QMailAccountSortKey());
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter);
+}
+
+template <class Key>
+void debugKey(const Key& key)
+{
+    typedef typename Key::ArgumentType ArgumentType;
+
+    qDebug() << "Key Combiner:" << key.combiner();
+    qDebug() << "Key Is empty:" << key.isEmpty();
+    qDebug() << "Key Non Matching:" << key.isNonMatching();
+    qDebug() << "Key Is Negated:" << key.isNegated();
+
+    foreach (ArgumentType argument, key.arguments())
+    {
+        qDebug() << "Argument Property:" << argument.property;
+        qDebug() << "Argument Comparator:" << argument.op;
+        foreach (QVariant value, argument.valueList)
+            qDebug() << "Argument Value List:" << value;
+    }
+
+    foreach (const Key& subkey, key.subKeys())
+        debugKey(subkey);
+}
+
+QString nmoRecipients(const QList<QMailAddress>& recipients)
+{
+    QString result;
+    foreach (const QMailAddress& address, recipients)
+    {
+        QString triplet(QString(
+    "        nmo:recipient [\n"
+    "            rdf:type nco:Contact ;\n"
+    "            nco:fullname \"%1\" ; \n"
+    "            nco:hasEmailAddress <mailto:%2> ] ;\n")
+                .arg(address.name())
+                .arg(address.address()));
+        result.append(triplet);
+    }
+    return result;
+}
+
+template <class T>
+T IdFromUri(const QString& uri)
+{
+    int pos = uri.indexOf('#');
+    if (pos >= 0)
+    {
+        bool ok = false;
+        quint64 postfix = uri.right(uri.length() - pos-1).toULongLong(&ok);
+
+        if (ok)
+            return T(postfix);
+    }
+
+    return T();
+}
+
+
+QMailContentManager::DurabilityRequirement durability(bool commitOnSuccess)
+{
+    return (commitOnSuccess ? QMailContentManager::EnsureDurability : QMailContentManager::DeferDurability);
+}
+
+} // namespace
+
+
+// We need to support recursive locking, per-process
+static volatile int mutexLockCount = 0;
+static volatile int readLockCount = 0;
+
+class QMailStorePrivate::Transaction
+{
+    QMailStorePrivate *m_d;
+    bool m_initted;
+    bool m_committed;
+
+public:
+    Transaction(QMailStorePrivate *);
+    ~Transaction();
+
+    bool commit();
+
+    bool committed() const;
+};
+
+QMailStorePrivate::Transaction::Transaction(QMailStorePrivate* d)
+    : m_d(d), 
+      m_initted(false),
+      m_committed(false)
+{
+    if (mutexLockCount > 0) {
+        // Increase lock recursion depth
+        ++mutexLockCount;
+        m_initted = true;
+    } else {
+        // This process does not yet have a mutex lock
+        if (m_d->databaseMutex().lock(10000)) {
+            // Wait for any readers to complete
+            if (m_d->databaseReadLock().wait(10000)) {
+
+                    ++mutexLockCount;
+                    m_initted = true;
+
+            } else {
+                qWarning() << "Unable to wait for database read lock to reach zero!";
+            }
+
+            if (!m_initted) {
+                m_d->databaseMutex().unlock();
+            }
+        } else {
+            qWarning() << "Unable to lock database mutex for transaction!";
+        }
+    }
+}
+
+QMailStorePrivate::Transaction::~Transaction()
+{
+    if (m_initted && !m_committed) {
+
+        --mutexLockCount;
+        if (mutexLockCount == 0)
+            m_d->databaseMutex().unlock();
+    }
+}
+
+bool QMailStorePrivate::Transaction::commit()
+{
+    if (m_initted && !m_committed) {
+
+            // TBD: Pretend that we've
+            // commited that already.
+            m_committed = true;
+
+            --mutexLockCount;
+            if (mutexLockCount == 0)
+                m_d->databaseMutex().unlock();
+        }
+
+
+    return m_committed;
+}
+
+bool QMailStorePrivate::Transaction::committed() const
+{
+    return m_committed;
+}
+
+
+class QMailStorePrivate::ReadLock
+{
+    QMailStorePrivate *m_d;
+    bool m_locked;
+
+public:
+    ReadLock(QMailStorePrivate *);
+    ~ReadLock();
+};
+
+QMailStorePrivate::ReadLock::ReadLock(QMailStorePrivate* d)
+    : m_d(d),
+      m_locked(false)
+{
+    if (readLockCount > 0) {
+        // Increase lock recursion depth
+        ++readLockCount;
+        m_locked = true;
+    } else {
+        // This process does not yet have a read lock
+        // Lock the mutex to ensure no writers are active or waiting (unless we have already locked it)
+        if ((mutexLockCount > 0) || m_d->databaseMutex().lock(10000)) {
+            m_d->databaseReadLock().lock();
+            ++readLockCount;
+            m_locked = true;
+
+            if (mutexLockCount == 0)
+                m_d->databaseMutex().unlock();
+        } else {
+            qWarning() << "Unable to lock database mutex for read lock!";
+        }
+    }
+}
+
+QMailStorePrivate::ReadLock::~ReadLock()
+{
+    if (m_locked) {
+        --readLockCount;
+        if (readLockCount == 0)
+            m_d->databaseReadLock().unlock();
+    }
+}
+
+
+template<typename FunctionType>
+QMailStorePrivate::AttemptResult evaluate(QMailStorePrivate::WriteAccess, FunctionType func, QMailStorePrivate::Transaction &t)
+{
+    // Use the supplied transaction, and do not commit
+    return func(t, false);
+}
+
+template<typename FunctionType>
+QMailStorePrivate::AttemptResult evaluate(QMailStorePrivate::ReadAccess, FunctionType, QMailStorePrivate::Transaction &)
+{
+    return QMailStorePrivate::Failure;
+}
+
+template<typename FunctionType>
+QMailStorePrivate::AttemptResult evaluate(QMailStorePrivate::WriteAccess, FunctionType func, const QString& description, QMailStorePrivate* d)
+{
+    QMailStorePrivate::Transaction t(d);
+
+    // Perform the task and commit the transaction
+    QMailStorePrivate::AttemptResult result = func(t, true);
+
+    // Ensure that the transaction was committed
+    if ((result == QMailStorePrivate::Success) && !t.committed()) {
+        qMailLog(Messaging) << pid << "Failed to commit successful" << qPrintable(description) << "!";
+    }
+
+    return result;
+}
+
+template<typename FunctionType>
+QMailStorePrivate::AttemptResult evaluate(QMailStorePrivate::ReadAccess, FunctionType func, const QString&, QMailStorePrivate* d)
+{
+    QMailStorePrivate::ReadLock l(d);
+
+    return func(l);
+}
+
+
+QMailStore::ErrorCode errorType(QMailStorePrivate::ReadAccess)
+{
+    return QMailStore::InvalidId;
+}
+
+QMailStore::ErrorCode errorType(QMailStorePrivate::WriteAccess)
+{
+    return QMailStore::ConstraintFailure;
+}
+
+// Properties of the mailmessages table
+static QMailStorePrivate::MessagePropertyMap messagePropertyMap()
+{
+    QMailStorePrivate::MessagePropertyMap map;
+
+    map.insert(QMailMessageKey::Id,"id");
+    map.insert(QMailMessageKey::Type,"type");
+    map.insert(QMailMessageKey::ParentFolderId,"parentfolderid");
+    map.insert(QMailMessageKey::Sender,"sender");
+    map.insert(QMailMessageKey::Recipients,"recipients");
+    map.insert(QMailMessageKey::Subject,"subject");
+    map.insert(QMailMessageKey::TimeStamp,"stamp");
+    map.insert(QMailMessageKey::ReceptionTimeStamp,"receivedstamp");
+    map.insert(QMailMessageKey::Status,"status");
+    map.insert(QMailMessageKey::ParentAccountId,"parentaccountid");
+    map.insert(QMailMessageKey::ServerUid,"serveruid");
+    map.insert(QMailMessageKey::Size,"size");
+    map.insert(QMailMessageKey::ContentType,"contenttype");
+    map.insert(QMailMessageKey::PreviousParentFolderId,"previousparentfolderid");
+    map.insert(QMailMessageKey::ContentScheme,"mailfile");
+    map.insert(QMailMessageKey::ContentIdentifier,"mailfile");
+    map.insert(QMailMessageKey::InResponseTo,"responseid");
+    map.insert(QMailMessageKey::ResponseType,"responsetype");
+
+    return map;
+}
+
+
+const QMailMessageKey::Properties &QMailStorePrivate::updatableMessageProperties()
+{
+    static QMailMessageKey::Properties p = QMailMessageKey::ParentFolderId |
+                                           QMailMessageKey::Type |
+                                           QMailMessageKey::Sender |
+                                           QMailMessageKey::Recipients |
+                                           QMailMessageKey::Subject |
+                                           QMailMessageKey::TimeStamp |
+                                           QMailMessageKey::ReceptionTimeStamp |
+                                           QMailMessageKey::Status |
+                                           QMailMessageKey::ParentAccountId |
+                                           QMailMessageKey::ServerUid |
+                                           QMailMessageKey::Size |
+                                           QMailMessageKey::ContentType |
+                                           QMailMessageKey::PreviousParentFolderId |
+                                           QMailMessageKey::ContentScheme |
+                                           QMailMessageKey::ContentIdentifier |
+                                           QMailMessageKey::InResponseTo |
+                                           QMailMessageKey::ResponseType;
+    return p;
+}
+
+const QMailMessageKey::Properties &QMailStorePrivate::allMessageProperties()
+{
+    static QMailMessageKey::Properties p = QMailMessageKey::Id | updatableMessageProperties();
+    return p;
+}
+
+const QMailStorePrivate::MessagePropertyMap& QMailStorePrivate::messagePropertyMap() 
+{
+    static const MessagePropertyMap map(::messagePropertyMap());
+    return map;
+}
+
+const QMailStorePrivate::MessagePropertyList& QMailStorePrivate::messagePropertyList() 
+{
+    static const MessagePropertyList list(messagePropertyMap().keys());
+    return list;
+}
+
+const QString &QMailStorePrivate::defaultContentScheme() 
+{
+    static QString scheme(QMailContentManagerFactory::defaultScheme());
+    return scheme;
+}
+
+QString QMailStorePrivate::databaseIdentifier() const
+{
+     // TBD: Find good file name for the SPARQL database
+    QString databasePath = QDir::homePath() + "/.cache/tracker/contents.db";
+    //int result = static_cast<int>(::ftok(databasePath.toAscii(), n));
+
+    return databasePath;
+}
+
+
+ProcessMutex* QMailStorePrivate::contentMutex = 0;
+
+QMailStorePrivate::QMailStorePrivate(QMailStore* parent)
+    : QMailStoreImplementation(parent),
+       headerCache(headerCacheSize),
+      folderCache(folderCacheSize),
+      accountCache(accountCacheSize),
+      inTransaction(false),
+      lastQueryError(0),
+      mutex(0),
+      readLock(0)
+{
+    qDebug() << "QMailStorePrivate::QMailStorePrivate";
+    ProcessMutex creationMutex(QDir::rootPath());
+    MutexGuard guard(creationMutex);
+
+    mutex = new ProcessMutex(databaseIdentifier(), 1);
+    readLock = new ProcessReadLock(databaseIdentifier(), 2);
+    if (contentMutex == 0) {
+        contentMutex = new ProcessMutex(databaseIdentifier(), 3);
+    }
+}
+
+QMailStorePrivate::~QMailStorePrivate()
+{
+    delete mutex;
+    delete readLock;
+}
+
+ProcessMutex& QMailStorePrivate::databaseMutex(void) const
+{
+    return *mutex;
+}
+
+ProcessReadLock& QMailStorePrivate::databaseReadLock(void) const
+{
+    return *readLock;
+}
+
+ProcessMutex& QMailStorePrivate::contentManagerMutex(void)
+{
+    return *contentMutex;
+}
+
+bool QMailStorePrivate::initStore()
+{
+    ProcessMutex creationMutex(QDir::rootPath());
+    MutexGuard guard(creationMutex);
+    if (!guard.lock(1000)) {
+        return false;
+    }
+
+    if (sparqlDatabase.isOpenError()) {
+        qMailLog(Messaging) << "Unable to open database in initStore!";
+        return false;
+    }
+
+
+     if (!setupStandardFolder(QMailFolder::InboxFolder,  tr("Inbox"))     ||
+        !setupStandardFolder(QMailFolder::OutboxFolder, tr("Outbox"))    ||
+        !setupStandardFolder(QMailFolder::DraftsFolder, tr("Drafts"))    ||
+        !setupStandardFolder(QMailFolder::SentFolder,   tr("Sent"))      ||
+        !setupStandardFolder(QMailFolder::TrashFolder,  tr("Trash"))) {
+            return false;
+        }
+
+
+        QMailAccount::initStore();
+        QMailFolder::initStore();
+        QMailMessage::initStore();
+
+
+
+    if (!QMailContentManagerFactory::init()) {
+        qMailLog(Messaging) << "Could not initialize content manager factory";
+        return false;
+    }
+    /*
+
+      TBD: Should we handle the sparql maintenance similar fassion to the sqlite one
+
+    if (!performMaintenance()) {
+        return false;
+    }
+
+    */
+    // We are now correctly initialized
+    return true;
+}
+
+void QMailStorePrivate::clearContent()
+{
+    // Clear all caches
+    accountCache.clear();
+    folderCache.clear();
+    headerCache.clear();
+
+
+  
+   
+    // Remove all content
+    QMailContentManagerFactory::clearContent();
+}
+
+
+
+void QMailStorePrivate::setQueryError(const SparqlQuery &query, const QString &description, const QString &statement)
+{
+    QString s;
+    QTextStream ts(&s);
+
+    lastQueryError = query.error();
+
+    ts << qPrintable(description) << "; error:\"" << query.query() << '"' << qPrintable(statement) << ";";
+    qMailLog(Messaging) << "(" << ::getpid() << ")" << qPrintable(s);
+    qWarning() << qPrintable(s);
+
+}
+
+void QMailStorePrivate::clearQueryError(void) 
+{
+    lastQueryError.clear();
+}
+
+bool QMailStorePrivate::uriExists(const QString& uri)
+{
+    // TBD: Check whether value exists already
+    Q_UNUSED(uri);
+    return false;
+}
+
+bool QMailStorePrivate::setupStandardFolder(enum QMailFolder::StandardFolder folder, const QString& name)
+{
+    MailFolderUri  folderUri(QMailFolderId((int)folder));
+    MailFolderUri  parentFolderUri(QMailFolderId(0));
+    MailAccountUri parentAccountUri(QMailAccountId(0));
+
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "%1 rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName \"%2\" ; \n"
+    "   nie:isLogicalPartOf %3 ; \n"
+    "   nie:relatedTo %4 ; \n"
+    "   nmo:folderDisplayName \"%5\" ; \n"
+    "   nmo:status \"%6\"^^xsd:integer ; \n"
+    "   nmo:serverCount \"%7\"^^xsd:integer ; \n"
+    "   nmo:serverUnreadCount \"%8\"^^xsd:integet . \n"
+    "}").arg(folderUri.uri())
+        .arg(name)
+        .arg(parentFolderUri.uri())
+        .arg(parentAccountUri.uri())
+        .arg(0)
+        .arg(0)
+        .arg(0)
+        .arg(0));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return false;
+    }
+
+qDebug() << "Query succeeded";
+
+    // TBD: Update folder links also
+    return true;
+}
+
+QMailAccount QMailStorePrivate::extractAccount(const QMailAccountId& id, const QStringList& list)
+{
+    QMailAccount account;
+
+    // Load account data
+    account.setId(id);
+    account.setName(list.at(0));
+    /* account.setStatus(list.at(1).toULongLong()); */
+    account.setSignature(list.at(1));
+    account.setFromAddress(QMailAddress(list.at(2)));
+
+    return account;
+}
+
+QMailFolder QMailStorePrivate::extractFolder(const QMailFolderId& id, const QStringList& list)
+{
+    // Load folder data
+    QMailFolder folder(list.at(0), IdFromUri<QMailFolderId>(list.at(1)), IdFromUri<QMailAccountId>(list.at(2)));
+
+    folder.setId(id);
+    folder.setDisplayName(list.at(3));
+//    folder.setStatus(list.at(4).toULongLong());
+//    folder.setServerCount(list.at(5).toUInt());
+//    folder.setServerUnreadCount(list.at(6).toUInt());
+
+    return folder;
+}
+
+void QMailStorePrivate::extractMessageMetaData(const QStringList& list, QMailMessageMetaData* metaData)
+{
+    // Load message properties
+
+    metaData->setParentFolderId(IdFromUri<QMailFolderId>(list.at(0)));
+    metaData->setFrom(QMailAddress(list.at(1), list.at(2)));
+    metaData->setSubject(list.at(3));
+    metaData->setDate(QMailTimeStamp(list.at(4)));
+    metaData->setStatus(list.at(5).toULongLong());
+    metaData->setParentAccountId(IdFromUri<QMailAccountId>(list.at(6)));
+    metaData->setServerUid(list.at(10));
+    metaData->setSize(list.at(9).toUInt());
+    metaData->setContent((QMailMessageMetaDataFwd::ContentType)list.at(10).toInt());
+    metaData->setInResponseTo(QMailMessageId(IdFromUri<QMailMessageId>(list.at(11))));
+    metaData->setResponseType((QMailMessageMetaDataFwd::ResponseType)list.at(12).toInt());
+    metaData->setReceivedDate(QMailTimeStamp(list.at(13)));
+
+    metaData->setUnmodified();
+}
+
+
+
+bool QMailStorePrivate::addAccount(QMailAccount *account, QMailAccountConfiguration *config,
+                                   QMailAccountIdList *addedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptAddAccount, this, 
+                                        account, config, 
+                                        addedAccountIds), 
+                                   "addAccount");
+}
+
+bool QMailStorePrivate::addFolder(QMailFolder *folder,
+                                  QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{   
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptAddFolder, this, 
+                                        folder, 
+                                        addedFolderIds, modifiedAccountIds), 
+                                   "addFolder");
+}
+
+bool QMailStorePrivate::addMessages(const QList<QMailMessage *> &messages,
+                                    QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    // Resolve from overloaded member functions:
+    AttemptResult (QMailStorePrivate::*func)(QMailMessage*, const QString&, const QStringList&, QMailMessageIdList*, QMailMessageIdList*, QMailFolderIdList*, QMailAccountIdList*, Transaction&, bool) = &QMailStorePrivate::attemptAddMessage;
+    QSet<QString> contentSchemes;
+
+    Transaction t(this);
+
+    foreach (QMailMessage *message, messages) {
+        // Find the message identifier and references from the header
+        QString identifier(identifierValue(message->headerFieldText("Message-ID")));
+        QStringList references(identifierValues(message->headerFieldText("References")));
+        QString predecessor(identifierValue(message->headerFieldText("In-Reply-To")));
+        if (!predecessor.isEmpty()) {
+            if (references.isEmpty() || (references.last() != predecessor)) {
+                references.append(predecessor);
+            }
+        }
+
+        if (!repeatedly<WriteAccess>(bind(func, this, 
+                                          message, cref(identifier), cref(references),
+                                          addedMessageIds, updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                     "addMessages",
+                                     &t)) {
+            return false;
+        }
+
+        contentSchemes.insert(message->contentScheme());
+    }
+
+    // Ensure that the content manager makes the changes durable before we return
+    foreach (const QString &scheme, contentSchemes) {
+        if (QMailContentManager *contentManager = QMailContentManagerFactory::create(scheme)) {
+            QMailStore::ErrorCode code = contentManager->ensureDurability();
+            if (code != QMailStore::NoError) {
+                setLastError(code);
+                qMailLog(Messaging) << "Unable to ensure message content durability for scheme:" << scheme;
+                return false;
+            }
+        } else {
+            setLastError(QMailStore::FrameworkFault);
+            qMailLog(Messaging) << "Unable to create content manager for scheme:" << scheme;
+            return false;
+        }
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Unable to commit successful addMessages!";
+        return false;
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::addMessages(const QList<QMailMessageMetaData *> &messages,
+                                    QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    // Resolve from overloaded member functions:
+    AttemptResult (QMailStorePrivate::*func)(QMailMessageMetaData*, const QString&, const QStringList&, QMailMessageIdList*, QMailMessageIdList*, QMailFolderIdList*, QMailAccountIdList*, Transaction&, bool) = &QMailStorePrivate::attemptAddMessage;
+
+    Transaction t(this);
+
+    foreach (QMailMessageMetaData *metaData, messages) {
+        QString identifier;
+        QStringList references;
+
+        if (!repeatedly<WriteAccess>(bind(func, this, 
+                                          metaData, cref(identifier), cref(references),
+                                          addedMessageIds, updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                     "addMessages",
+                                     &t)) {
+            return false;
+        }
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Unable to commit successful addMessages!";
+        return false;
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::removeAccounts(const QMailAccountKey &key,
+                                       QMailAccountIdList *deletedAccountIds, QMailFolderIdList *deletedFolderIds, QMailMessageIdList *deletedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRemoveAccounts, this, 
+                                        cref(key), 
+                                        deletedAccountIds, deletedFolderIds, deletedMessageIds, updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "removeAccounts");
+}
+
+bool QMailStorePrivate::removeFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option,
+                                      QMailFolderIdList *deletedFolderIds, QMailMessageIdList *deletedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRemoveFolders, this, 
+                                        cref(key), option, 
+                                        deletedFolderIds, deletedMessageIds, updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "removeFolders");
+}
+
+bool QMailStorePrivate::removeMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option,
+                                       QMailMessageIdList *deletedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRemoveMessages, this, 
+                                        cref(key), option, 
+                                        deletedMessageIds, updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "removeMessages");
+}
+
+bool QMailStorePrivate::updateAccount(QMailAccount *account, QMailAccountConfiguration *config,
+                                      QMailAccountIdList *updatedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateAccount, this, 
+                                        account, config, 
+                                        updatedAccountIds), 
+                                   "updateAccount");
+}
+
+bool QMailStorePrivate::updateAccountConfiguration(QMailAccountConfiguration *config,
+                                                   QMailAccountIdList *updatedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateAccount, this, 
+                                        reinterpret_cast<QMailAccount*>(0), config, 
+                                        updatedAccountIds), 
+                                   "updateAccount");
+}
+
+bool QMailStorePrivate::updateFolder(QMailFolder *folder,
+                                     QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateFolder, this, 
+                                        folder, 
+                                        updatedFolderIds, modifiedAccountIds), 
+                                   "updateFolder");
+}
+
+bool QMailStorePrivate::updateMessages(const QList<QPair<QMailMessageMetaData*, QMailMessage*> > &messages,
+                                       QMailMessageIdList *updatedMessageIds, QMailMessageIdList *modifiedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    QSet<QString> contentSchemes;
+
+    Transaction t(this);
+
+    typedef QPair<QMailMessageMetaData*, QMailMessage*> PairType;
+
+    foreach (const PairType &pair, messages) {
+        if (!repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateMessage, this, 
+                                          pair.first, pair.second,
+                                          updatedMessageIds, modifiedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                     "updateMessages",
+                                     &t)) {
+            return false;
+        }
+
+        contentSchemes.insert(pair.first->contentScheme());
+    }
+
+    // Ensure that the content manager makes the changes durable before we return
+    foreach (const QString &scheme, contentSchemes) {
+        if (QMailContentManager *contentManager = QMailContentManagerFactory::create(scheme)) {
+            QMailStore::ErrorCode code = contentManager->ensureDurability();
+            if (code != QMailStore::NoError) {
+                setLastError(code);
+                qMailLog(Messaging) << "Unable to ensure message content durability for scheme:" << scheme;
+                return false;
+            }
+        } else {
+            setLastError(QMailStore::FrameworkFault);
+            qMailLog(Messaging) << "Unable to create content manager for scheme:" << scheme;
+            return false;
+        }
+    }
+
+    if (!t.commit()) {
+        qMailLog(Messaging) << "Unable to commit successful updateMessages!";
+        return false;
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::updateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, const QMailMessageMetaData &data,
+                                               QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateMessagesMetaData, this, 
+                                        cref(key), cref(properties), cref(data), 
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "updateMessagesMetaData");
+}
+
+bool QMailStorePrivate::updateMessagesMetaData(const QMailMessageKey &key, quint64 status, bool set,
+                                               QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateMessagesStatus, this, 
+                                        cref(key), status, set,
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "updateMessagesMetaData"); // not 'updateMessagesStatus', due to function name exported by QMailStore
+}
+
+bool QMailStorePrivate::restoreToPreviousFolder(const QMailMessageKey &key,
+                                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRestoreToPreviousFolder, this, 
+                                        cref(key), 
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "restoreToPreviousFolder");
+}
+
+bool QMailStorePrivate::purgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptPurgeMessageRemovalRecords, this, 
+                                        cref(accountId), cref(serverUids)), 
+                                   "purgeMessageRemovalRecords");
+}
+
+int QMailStorePrivate::countAccounts(const QMailAccountKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptCountAccounts, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "countAccounts");
+    return result;
+}
+
+int QMailStorePrivate::countFolders(const QMailFolderKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptCountFolders, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "countFolders");
+    return result;
+}
+
+int QMailStorePrivate::countMessages(const QMailMessageKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptCountMessages, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "countMessages");
+    return result;
+}
+
+int QMailStorePrivate::sizeOfMessages(const QMailMessageKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptSizeOfMessages, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "sizeOfMessages");
+    return result;
+}
+
+QMailAccountIdList QMailStorePrivate::queryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey, uint limit, uint offset) const
+{
+    QMailAccountIdList ids;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptQueryAccounts, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(sortKey), limit, offset, &ids), 
+                           "queryAccounts");
+    return ids;
+}
+
+QMailFolderIdList QMailStorePrivate::queryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey, uint limit, uint offset) const
+{
+    QMailFolderIdList ids;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptQueryFolders, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(sortKey), limit, offset, &ids), 
+                           "queryFolders");
+    return ids;
+}
+
+QMailMessageIdList QMailStorePrivate::queryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey, uint limit, uint offset) const
+{
+    QMailMessageIdList ids;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptQueryMessages, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(sortKey), limit, offset, &ids), 
+                           "queryMessages");
+    return ids;
+}
+
+QMailAccount QMailStorePrivate::account(const QMailAccountId &id) const
+{
+    if (accountCache.contains(id))
+        return accountCache.lookup(id);
+
+    QMailAccount account;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptAccount, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &account), 
+                           "account");
+    return account;
+}
+
+QMailAccountConfiguration QMailStorePrivate::accountConfiguration(const QMailAccountId &id) const
+{
+    QMailAccountConfiguration config;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptAccountConfiguration, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &config), 
+                           "accountConfiguration");
+    return config;
+}
+
+QMailFolder QMailStorePrivate::folder(const QMailFolderId &id) const
+{
+    if (folderCache.contains(id))
+        return folderCache.lookup(id);
+
+    QMailFolder folder;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptFolder, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &folder), 
+                           "folder");
+    return folder;
+}
+
+QMailMessage QMailStorePrivate::message(const QMailMessageId &id) const
+{
+    // Resolve from overloaded member functions:
+    AttemptResult (QMailStorePrivate::*func)(const QMailMessageId&, QMailMessage*, ReadLock&) = &QMailStorePrivate::attemptMessage;
+
+    QMailMessage msg;
+    repeatedly<ReadAccess>(bind(func, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &msg), 
+                           "message(id)");
+    return msg;
+}
+
+QMailMessage QMailStorePrivate::message(const QString &uid, const QMailAccountId &accountId) const
+{
+    // Resolve from overloaded member functions:
+    AttemptResult (QMailStorePrivate::*func)(const QString&, const QMailAccountId&, QMailMessage*, ReadLock&) = &QMailStorePrivate::attemptMessage;
+
+    QMailMessage msg;
+    repeatedly<ReadAccess>(bind(func, const_cast<QMailStorePrivate*>(this), 
+                                cref(uid), cref(accountId), &msg), 
+                           "message(uid, accountId)");
+    return msg;
+}
+
+QMailMessageMetaData QMailStorePrivate::messageMetaData(const QMailMessageId &id) const
+{
+    if (headerCache.contains(id))
+        return headerCache.lookup(id);
+
+    //if not in the cache, then preload the cache with the id and its most likely requested siblings
+    preloadHeaderCache(id);
+
+    return headerCache.lookup(id);
+}
+
+QMailMessageMetaData QMailStorePrivate::messageMetaData(const QString &uid, const QMailAccountId &accountId) const
+{
+   QMailMessageKey uidKey(QMailMessageKey::serverUid(uid));
+    QMailMessageKey accountKey(QMailMessageKey::parentAccountId(accountId));
+
+    QMailMessageMetaDataList results = messagesMetaData(uidKey & accountKey, allMessageProperties(), QMailStore::ReturnAll);
+    if (!results.isEmpty()) {
+        if (results.count() > 1){
+            qMailLog(Messaging) << "Warning, messageMetaData by uid returned more than 1 result";
+        }
+
+        headerCache.insert(results.first());
+        return results.first();
+    }
+
+    return QMailMessageMetaData();
+}
+
+
+QMailMessageMetaDataList QMailStorePrivate::messagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option) const
+{
+    QMailMessageMetaDataList metaData;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptMessagesMetaData, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(properties), option, &metaData), 
+                           "messagesMetaData");
+    return metaData;
+}
+
+QMailMessageRemovalRecordList QMailStorePrivate::messageRemovalRecords(const QMailAccountId &accountId, const QMailFolderId &folderId) const
+{
+    QMailMessageRemovalRecordList removalRecords;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptMessageRemovalRecords, const_cast<QMailStorePrivate*>(this), 
+                                cref(accountId), cref(folderId), &removalRecords), 
+                           "messageRemovalRecords(accountId, folderId)");
+    return removalRecords;
+}
+
+bool QMailStorePrivate::registerAccountStatusFlag(const QString &name)
+{
+    if (accountStatusMask(name) != 0)
+        return true;
+
+    static const QString context("accountstatus");
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRegisterStatusBit, this,
+                                        cref(name), cref(context), 64), 
+                                   "registerAccountStatusBit");
+}
+
+quint64 QMailStorePrivate::accountStatusMask(const QString &name) const
+{
+    static QMap<QString, quint64> statusMap;
+    static const QString context("accountstatus");
+
+    return queryStatusMap(name, context, statusMap);
+}
+
+bool QMailStorePrivate::registerFolderStatusFlag(const QString &name)
+{
+    if (folderStatusMask(name) != 0)
+        return true;
+
+    static const QString context("folderstatus");
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRegisterStatusBit, this,
+                                        cref(name), cref(context), 64), 
+                                   "registerFolderStatusBit");
+}
+
+quint64 QMailStorePrivate::folderStatusMask(const QString &name) const
+{
+    static QMap<QString, quint64> statusMap;
+    static const QString context("folderstatus");
+
+    return queryStatusMap(name, context, statusMap);
+}
+
+bool QMailStorePrivate::registerMessageStatusFlag(const QString &name)
+{
+    if (messageStatusMask(name) != 0)
+        return true;
+
+    static const QString context("messagestatus");
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRegisterStatusBit, this,
+                                        cref(name), cref(context), 64), 
+                                   "registerMessageStatusBit");
+}
+
+quint64 QMailStorePrivate::messageStatusMask(const QString &name) const
+{
+    static QMap<QString, quint64> statusMap;
+    static const QString context("messagestatus");
+
+    return queryStatusMap(name, context, statusMap);
+}
+
+quint64 QMailStorePrivate::queryStatusMap(const QString &name, const QString &context, QMap<QString, quint64> &map) const
+{
+    QMap<QString, quint64>::const_iterator it = map.find(name);
+    if (it != map.end())
+        return it.value();
+
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptStatusBit, const_cast<QMailStorePrivate*>(this), 
+                                cref(name), cref(context), &result), 
+                           "folderStatusMask");
+    if (result == 0)
+        return 0;
+
+    quint64 maskValue = (1 << (result - 1));
+    map[name] = maskValue;
+    return maskValue;
+}
+
+QMailFolderIdList QMailStorePrivate::folderAncestorIds(const QMailFolderIdList& ids, bool inTransaction, AttemptResult *result) const
+{
+    QMailFolderIdList ancestorIds;
+
+    QMailStorePrivate *self(const_cast<QMailStorePrivate*>(this));
+    if (inTransaction) {
+        // We can't retry this query after a busy error if we're in a transaction
+        ReadLock l(self);
+        *result = self->attemptFolderAncestorIds(ids, &ancestorIds, l);
+    } else {
+        bool ok = repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptFolderAncestorIds, self,
+                                              cref(ids), &ancestorIds), 
+                                         "folderAncestorIds");
+        if (result)
+            *result = ok ? Success : Failure;
+    }
+
+    return ancestorIds;
+}
+
+void QMailStorePrivate::removeExpiredData(const QMailMessageIdList& messageIds, const QStringList& contentUris, const QMailFolderIdList& folderIds, const QMailAccountIdList& accountIds)
+{
+    foreach (const QMailMessageId& id, messageIds) {
+        headerCache.remove(id);
+    }
+
+    {
+        MutexGuard lock(contentManagerMutex());
+        if (!lock.lock(1000)) {
+            qMailLog(Messaging) << "Unable to acquire message body mutex in removeExpiredData!";
+        } else {
+            foreach (const QString& contentUri, contentUris) {
+                QPair<QString, QString> elements(extractUriElements(contentUri));
+
+                if (QMailContentManager *contentManager = QMailContentManagerFactory::create(elements.first)) {
+                    QMailStore::ErrorCode code = contentManager->remove(elements.second);
+                    if (code != QMailStore::NoError) {
+                        qMailLog(Messaging) << "Unable to remove expired message content:" << contentUri;
+                        if (code == QMailStore::ContentNotRemoved) {
+                            // The existing content could not be removed - try again later
+                            obsoleteContent(contentUri);
+                        }
+                    }
+                } else {
+                    qMailLog(Messaging) << "Unable to create content manager for scheme:" << elements.first;
+                }
+            }
+        }
+    }
+
+    foreach (const QMailFolderId& id, folderIds) {
+        folderCache.remove(id);
+    }
+
+    foreach (const QMailAccountId& id, accountIds) {
+        accountCache.remove(id);
+    }
+}
+
+template<typename AccessType, typename FunctionType>
+bool QMailStorePrivate::repeatedly(FunctionType func, const QString &description, Transaction *t) const
+{
+    static const unsigned int MinRetryDelay = 64;
+    static const unsigned int MaxRetryDelay = 2048;
+    static const unsigned int MaxAttempts = 10;
+
+    // This function calls the supplied function repeatedly, retrying whenever it
+    // returns the DatabaseFailure result and the database's last error is SQLITE_BUSY.
+    // It sleeps between repeated attempts, for increasing amounts of time.
+    // The argument should be an object allowing nullary invocation returning an
+    // AttemptResult value, created with tr1::bind if necessary.
+
+    unsigned int attemptCount = 0;
+    unsigned int delay = MinRetryDelay;
+
+     while (true) {
+        AttemptResult result;
+        if (t) {
+            result = evaluate(AccessType(), func, *t);
+        } else {
+            result = evaluate(AccessType(), func, description, const_cast<QMailStorePrivate*>(this));
+        }
+
+        if (result == Success) {
+            if (attemptCount > 0) {
+                qMailLog(Messaging) << pid << "Able to" << qPrintable(description) << "after" << attemptCount << "failed attempts";
+            }
+            return true;
+        } else if (result == Failure) {
+            qMailLog(Messaging) << pid << "Unable to" << qPrintable(description);
+            if (lastError() == QMailStore::NoError) {
+                setLastError(errorType(AccessType()));
+            }
+            return false;
+        } else { 
+            // result == DatabaseFailure
+            if (queryError() == "Sqlite3BusyErrorNumber") {
+                if (attemptCount < MaxAttempts) {
+                    qMailLog(Messaging) << pid << "Failed to" << qPrintable(description) << "- busy, pausing to retry";
+
+                    // Pause before we retry
+                    QMail::usleep(delay * 1000);
+                    if (delay < MaxRetryDelay)
+                        delay *= 2;
+
+                    ++attemptCount;
+                } else {
+                    qMailLog(Messaging) << pid << "Retry count exceeded - failed to" << qPrintable(description);
+                    break;
+                }
+            } else if (queryError() == "Sqlite3ConstraintErrorNumber") {
+                qMailLog(Messaging) << pid << "Unable to" << qPrintable(description) << "- constraint failure";
+                setLastError(QMailStore::ConstraintFailure);
+                break;
+            } else {
+                qMailLog(Messaging) << pid << "Unable to" << qPrintable(description) << "- code:" << queryError();
+                break;
+            }
+        }
+    }
+
+    // We experienced a database-related failure
+    if (lastError() == QMailStore::NoError) {
+        setLastError(QMailStore::FrameworkFault);
+    }
+    return false;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::addCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName)
+{
+    if (!fields.isEmpty()) {
+        QVariantList customFields;
+        QVariantList customValues;
+
+        // Insert any custom fields belonging to this account
+        QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+        for ( ; it != end; ++it) {
+            customFields.append(QVariant(it.key()));
+            customValues.append(QVariant(it.value()));
+        }
+
+         // TBD: Add custom fields
+        Q_UNUSED(id);
+
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::updateCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName)
+{
+    QMap<QString, QString> existing;
+
+    {
+        // Find the existing fields
+        // TBD: Put actual code here
+        Q_UNUSED(id);
+    }
+
+    QVariantList obsoleteFields;
+    QVariantList modifiedFields;
+    QVariantList modifiedValues;
+    QVariantList addedFields;
+    QVariantList addedValues;
+
+    // Compare the sets
+    QMap<QString, QString>::const_iterator fend = fields.end(), eend = existing.end();
+    QMap<QString, QString>::const_iterator it = existing.begin();
+    for ( ; it != eend; ++it) {
+        QMap<QString, QString>::const_iterator current = fields.find(it.key());
+        if (current == fend) {
+            obsoleteFields.append(QVariant(it.key()));
+        } else if (*current != *it) {
+            modifiedFields.append(QVariant(current.key()));
+            modifiedValues.append(QVariant(current.value()));
+        }
+    }
+
+    for (it = fields.begin(); it != fend; ++it) {
+        if (existing.find(it.key()) == eend) {
+            addedFields.append(QVariant(it.key()));
+            addedValues.append(QVariant(it.value()));
+        }
+    }
+
+
+    // TBD: Update custom fields
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName)
+{
+   // TBD: Load information about custom fields
+    Q_UNUSED(id);
+    Q_UNUSED(fields);
+
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRemoveAccounts(const QMailAccountKey &key, 
+                                                                          QMailAccountIdList *deletedAccountIds, QMailFolderIdList *deletedFolderIds, QMailMessageIdList *deletedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                          Transaction &t, bool commitOnSuccess)
+{
+    // TBD: Delete accounts
+    Q_UNUSED(key);
+    Q_UNUSED(deletedAccountIds);
+    Q_UNUSED(deletedFolderIds);
+    Q_UNUSED(deletedMessageIds);
+    Q_UNUSED(t);
+
+    return DatabaseFailure;
+
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRemoveFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option, 
+                                                                         QMailFolderIdList *deletedFolderIds, QMailMessageIdList *deletedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                         Transaction &t, bool commitOnSuccess)
+{
+       // TBD: Remove folders
+    Q_UNUSED(key);
+    Q_UNUSED(option);
+    Q_UNUSED(deletedFolderIds);
+    Q_UNUSED(deletedMessageIds);
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(updatedMessageIds);
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(t);
+
+
+
+    return DatabaseFailure;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRemoveMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option, 
+                                                                          QMailMessageIdList *deletedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                          Transaction &t, bool commitOnSuccess)
+{
+     // TBD: Remove messages
+    Q_UNUSED(key);
+    Q_UNUSED(option);
+    Q_UNUSED(deletedMessageIds);
+    Q_UNUSED(updatedMessageIds);
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(t);
+
+
+    return DatabaseFailure;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAccount *account, QMailAccountConfiguration *config, 
+                                                                         QMailAccountIdList *updatedAccountIds,
+                                                                         Transaction &t, bool commitOnSuccess)
+{
+    Q_UNUSED(t);
+
+    QMailAccountId id(account ? account->id() : config ? config->id() : QMailAccountId());
+    if (!id.isValid())
+        return Failure;
+
+    if (account) {
+        // Update the account cache
+        if (accountCache.contains(id))
+            accountCache.insert(*account);
+    }
+
+    updatedAccountIds->append(id);
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateFolder(QMailFolder *folder, 
+                                                                        QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                        Transaction &t, bool commitOnSuccess)
+{
+    //check that the parent folder actually exists
+    if(!checkPreconditions(*folder, true))
+        return Failure;
+
+    QMailFolderId parentFolderId;
+    QMailAccountId parentAccountId;
+
+    //update the folder cache
+    if (folderCache.contains(folder->id()))
+        folderCache.insert(*folder);
+
+    updatedFolderIds->append(folder->id());
+    return Success;
+}
+
+struct ReferenceStorer
+{
+    QMailMessage *message;
+
+    ReferenceStorer(QMailMessage *m) : message(m) {}
+
+    bool operator()(const QMailMessagePart &part)
+    {
+        QString value;
+
+        if (part.referenceType() == QMailMessagePart::MessageReference) {
+            value = "message:" + QString::number(part.messageReference().toULongLong());
+        } else if (part.referenceType() == QMailMessagePart::PartReference) {
+            value = "part:" + part.partReference().toString(true);
+        }
+
+        if (!value.isEmpty()) {
+            QString loc(part.location().toString(false));
+
+            // Store the reference location into the message
+            QString key("qtopiamail-reference-location-" + loc);
+            if (message->customField(key) != value) {
+                message->setCustomField(key, value);
+            }
+
+            // Store the reference resolution into the message
+            key = "qtopiamail-reference-resolution-" + loc;
+            value = part.referenceResolution();
+            if (message->customField(key) != value) {
+                message->setCustomField(key, value);
+            }
+        }
+
+        return true;
+    }
+};
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateMessage(QMailMessageMetaData *metaData, QMailMessage *message, 
+                                                                         QMailMessageIdList *updatedMessageIds, QMailMessageIdList *modifiedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                         Transaction &t, bool commitOnSuccess)
+{
+    if (!metaData->id().isValid())
+        return Failure;
+
+    quint64 updateId = metaData->id().toULongLong();
+
+    QMailAccountId parentAccountId;
+    QMailFolderId parentFolderId;
+    QMailMessageId responseId;
+    QString contentUri;
+    QMailFolderIdList folderIds;
+
+    QMailMessageKey::Properties updateProperties;
+    QVariantList extractedValues;
+
+    if (message) {
+        // Ensure the part reference info is stored into the message
+        ReferenceStorer refStorer(message);
+        const_cast<const QMailMessage*>(message)->foreachPart<ReferenceStorer&>(refStorer);
+    }
+
+    if (metaData->dataModified()) {
+        // Assume all the meta data fields have been updated
+        updateProperties = QMailStorePrivate::updatableMessageProperties();
+    }
+
+    // Do we actually have an update to perform?
+    bool updateContent(message && message->contentModified());
+    if (metaData->dataModified() || updateContent) {
+        // Find the existing properties 
+        {
+           // TBD: Query database
+           Q_UNUSED(t);
+        }
+
+        bool replyOrForward(false);
+        QString baseSubject(QMail::baseSubject(metaData->subject(), &replyOrForward));
+        QStringList missingReferences;
+        bool missingAncestor(false);
+
+        if (updateContent || (message && (!metaData->inResponseTo().isValid() || (metaData->inResponseTo() != responseId)))) {
+            // Does this message have any references to resolve?
+            QStringList references(identifierValues(message->headerFieldText("References")));
+            QString predecessor(identifierValue(message->headerFieldText("In-Reply-To")));
+            if (!predecessor.isEmpty()) {
+                if (references.isEmpty() || (references.last() != predecessor)) {
+                    references.append(predecessor);
+                }
+            }
+
+            AttemptResult result = messagePredecessor(metaData, references, baseSubject, replyOrForward, &missingReferences, &missingAncestor);
+            if (result != Success)
+                return result;
+        }
+
+        if (updateContent) {
+            updateProperties |= QMailMessageKey::ContentIdentifier;
+
+            bool addContent(updateContent && contentUri.isEmpty());
+            if (addContent)
+                updateProperties |= QMailMessageKey::ContentScheme;
+
+            // We need to update the content for this message
+            if (metaData->contentScheme().isEmpty()) {
+                // Use the default storage scheme
+                metaData->setContentScheme(defaultContentScheme());
+            }
+
+            MutexGuard lock(contentManagerMutex());
+            if (!lock.lock(1000)) {
+                qMailLog(Messaging) << "Unable to acquire message body mutex in updateMessage!";
+                return Failure;
+            } 
+
+            if (QMailContentManager *contentManager = QMailContentManagerFactory::create(metaData->contentScheme())) {
+                QString contentUri(::contentUri(*metaData));
+
+                if (addContent) {
+                    // We need to add this content to the message
+                    QMailStore::ErrorCode code = contentManager->add(message, durability(commitOnSuccess));
+                    if (code != QMailStore::NoError) {
+                        setLastError(code);
+                        qMailLog(Messaging) << "Unable to add message content to URI:" << contentUri;
+                        return Failure;
+                    }
+                } else {
+                    QMailStore::ErrorCode code = contentManager->update(message, durability(commitOnSuccess));
+                    if (code != QMailStore::NoError) {
+                        qMailLog(Messaging) << "Unable to update message content:" << contentUri;
+                        if (code == QMailStore::ContentNotRemoved) {
+                            // The existing content could not be removed - try again later
+                            if (!obsoleteContent(contentUri)) {
+                                setLastError(QMailStore::FrameworkFault);
+                                return Failure;
+                            }
+                        } else {
+                            setLastError(code);
+                            return Failure;
+                        }
+                    }
+                }
+
+                metaData->setContentIdentifier(message->contentIdentifier());
+            } else {
+                qMailLog(Messaging) << "Unable to create content manager for scheme:" << metaData->contentScheme();
+                return Failure;
+            }
+        }
+
+        if (metaData->inResponseTo() != responseId) {
+            // We need to record this change
+            updateProperties |= QMailMessageKey::InResponseTo;
+            updateProperties |= QMailMessageKey::ResponseType;
+
+            // Join this message's thread to the predecessor's thread
+            quint64 threadId;
+
+            if (metaData->inResponseTo().isValid()) {
+                {
+
+                    //TBD:Handle threads with sparql
+
+                    /*
+                    QSqlQuery query(simpleQuery("SELECT threadid FROM mailthreadmessages WHERE messageid=?",
+                                                QVariantList() << updateId,
+                                                "updateMessage mailthreadmessages query"));
+                    if (query.lastError().type() != QSqlError::NoError)
+                        return DatabaseFailure;
+
+                    if (query.first()) {
+                        threadId = extractValue<quint64>(query.value(0));
+                        */
+                    }
+                }
+
+                {
+                    //TBD:Handle threads with sparql
+                    /*
+                    QSqlQuery query(simpleQuery("UPDATE mailthreadmessages SET threadid=(SELECT threadid FROM mailthreadmessages WHERE messageid=?) WHERE threadid=?",
+                                                QVariantList() << metaData->inResponseTo().toULongLong() << threadId,
+                                                "updateMessage mailthreadmessages update query"));
+                    if (query.lastError().type() != QSqlError::NoError)
+                        return DatabaseFailure;
+                        */
+                }
+
+                {
+                    //TBD:Handle threads with sparql
+                    /*
+                    QSqlQuery query(simpleQuery("DELETE FROM mailthreads WHERE id=?",
+                                                QVariantList() << threadId,
+                                                "updateMessage mailthreads delete query"));
+                    if (query.lastError().type() != QSqlError::NoError)
+                        return DatabaseFailure;
+                     */
+                }
+            } else {
+                // This message is no longer associated with the thread of the former predecessor
+                QMailMessageIdList descendantIds;
+
+                {
+                    QMailMessageIdList parentIds;
+
+                    parentIds.append(QMailMessageId(updateId));
+
+                    // Find all descendants of this message
+                    while (!parentIds.isEmpty()) {
+                        //TBD: Handle threads with sparQl
+                        /*
+                        QSqlQuery query(simpleQuery("SELECT id FROM mailmessages",
+                                                    Key("responseid", QMailMessageKey::id(parentIds)),
+                                                    "updateMessage mailmessages responseid query"));
+
+                        if (query.lastError().type() != QSqlError::NoError)
+                            return DatabaseFailure;
+
+
+                        while (!parentIds.isEmpty()) {
+                            descendantIds.append(parentIds.takeFirst());
+                        }
+
+                        while (query.next()) {
+                            parentIds.append(QMailMessageId(extractValue<quint64>(query.value(0))));
+                        }
+                        */
+                    }
+                }
+
+                {
+                    //TBD: handle threads with sparQl
+                    /*
+                    // Allocate a new thread for this message
+                    QSqlQuery query(simpleQuery("INSERT INTO mailthreads (id) SELECT COALESCE(MAX(id),0) + 1 FROM mailthreads",
+                                                "updateMessage mailthreads insert query"));
+                    if (query.lastError().type() != QSqlError::NoError)
+                        return DatabaseFailure;
+
+                    threadId = extractValue<quint64>(query.lastInsertId());
+                    */
+                }
+
+                {
+                    //TBD:Handle threads with sparql
+                    /*
+                    // Migrate descendants to the new thread
+                    QSqlQuery query(simpleQuery("UPDATE mailthreadmessages SET threadid=?",
+                                                QVariantList() << threadId,
+                                                Key("messageid", QMailMessageKey::id(descendantIds)),
+                                                "updateMessage mailthreadmessages update query"));
+                    if (query.lastError().type() != QSqlError::NoError)
+                        return DatabaseFailure;
+                        */
+                }
+            }
+            
+            // Remove any missing message/ancestor references associated with this message
+
+            {
+                //TBD: Handle threads with sparql
+                /*
+                QSqlQuery query(simpleQuery("DELETE FROM missingmessages WHERE id=?",
+                                            QVariantList() << updateId,
+                                            "updateMessage missingmessages delete query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+                    */
+            }
+
+            {
+                /*
+
+                QSqlQuery query(simpleQuery("DELETE FROM missingancestors WHERE messageid=?",
+                                            QVariantList() << updateId,
+                                            "updateMessage missingancestors delete query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+                    */
+            }
+        }
+
+        // Don't update the previous parent folder if it isn't set
+        if (!metaData->previousParentFolderId().isValid())
+            updateProperties &= ~QMailMessageKey::PreviousParentFolderId;
+
+        if (updateProperties != QMailMessageKey::Properties()) {
+            extractedValues = messageValues(updateProperties, *metaData);
+
+            // TBD: update extracted values
+        }
+
+        if (metaData->customFieldsModified()) {
+            AttemptResult result = updateCustomFields(updateId, metaData->customFields(), "mailmessagecustom");
+            if (result != Success)
+                return result;
+
+            updateProperties |= QMailMessageKey::Custom;
+        }
+
+        /*
+          TBD: add this functionality to sparql
+        if (updateProperties & QMailMessageKey::Subject) {
+            if (!baseSubject.isEmpty()) {
+                // Ensure that this subject is in the subjects table
+                AttemptResult result = registerSubject(baseSubject, updateId, metaData->inResponseTo(), missingAncestor);
+                if (result != Success)
+                    return result;
+            }
+        }
+        */
+
+        bool updatedIdentifier(false);
+        QString messageIdentifier;
+
+        if (updateContent) {
+            // We may have a change in the message identifier
+            QString existingIdentifier;
+
+            {
+                /*
+                QSqlQuery query(simpleQuery("SELECT identifier FROM mailmessageidentifiers WHERE id=?",
+                                            QVariantList() << updateId,
+                                            "updateMessage existing identifier query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+
+                if (query.first()) {
+                    existingIdentifier = extractValue<QString>(query.value(0));
+                }
+                */
+            }
+
+            messageIdentifier = identifierValue(message->headerFieldText("Message-ID"));
+
+            if (messageIdentifier != existingIdentifier) {
+                if (!messageIdentifier.isEmpty()) {
+                    updatedIdentifier = true;
+
+                    if (!existingIdentifier.isEmpty()) {
+                        /*
+                        QSqlQuery query(simpleQuery("UPDATE mailmessageidentifiers SET identifier=? WHERE id=?",
+                                                    QVariantList() << messageIdentifier << updateId,
+                                                    "updateMessage mailmessageidentifiers update query"));
+                        if (query.lastError().type() != QSqlError::NoError)
+                            return DatabaseFailure;
+                            */
+                    } else {
+                        /*
+                        // Add the new value
+                        QSqlQuery query(simpleQuery("INSERT INTO mailmessageidentifiers (id,identifier) VALUES (?,?)",
+                                                    QVariantList() << updateId << messageIdentifier,
+                                                    "updateMessage mailmessageidentifiers insert query"));
+                        if (query.lastError().type() != QSqlError::NoError)
+                            return DatabaseFailure;
+                            */
+                    }
+                } else {
+                    if (!existingIdentifier.isEmpty()) {
+                        /*
+                        // Remove any existing value
+                        QSqlQuery query(simpleQuery("DELETE FROM mailmessageidentifiers WHERE id=?",
+                                                    QVariantList() << updateId,
+                                                    "updateMessage mailmessageidentifiers delete query"));
+                        if (query.lastError().type() != QSqlError::NoError)
+                            return DatabaseFailure;
+                            */
+                    }
+                }
+            }
+
+
+            /*if (!missingReferences.isEmpty()) {
+                // Add the missing references to the missing messages table
+                QVariantList refs;
+                QVariantList levels;
+
+                int level = missingReferences.count();
+                foreach (const QString &ref, missingReferences) {
+                    refs.append(QVariant(ref));
+                    levels.append(QVariant(--level));
+                }
+
+                {
+
+                    QSqlQuery query(simpleQuery("DELETE FROM missingmessages WHERE id=?",
+                                                QVariantList() << updateId,
+                                                "addMessage missingmessages delete query"));
+                    if (query.lastError().type() != QSqlError::NoError)
+                        return DatabaseFailure;
+
+                }
+
+                {
+
+                    QString sql("INSERT INTO missingmessages (id,identifier,level) VALUES (%1,?,?)");
+                    QSqlQuery query(batchQuery(sql.arg(QString::number(updateId)),
+                                               QVariantList() << QVariant(refs) << QVariant(levels),
+                                               "addMessage missingmessages insert query"));
+                    if (query.lastError().type() != QSqlError::NoError)
+                        return DatabaseFailure;
+
+                }
+            }*/
+        }
+
+    /*
+        if (updatedIdentifier || (updateProperties & QMailMessageKey::InResponseTo)) {
+            // See if this message resolves any missing message items
+            AttemptResult result = resolveMissingMessages(messageIdentifier, metaData->inResponseTo(), baseSubject, updateId, updatedMessageIds);
+            if (result != Success)
+                return result;
+
+            if (!updatedMessageIds->isEmpty()) {
+                // Find the set of folders and accounts whose contents are modified by these messages
+                QMailMessageKey modifiedMessageKey(QMailMessageKey::id(*updatedMessageIds));
+                result = affectedByMessageIds(*updatedMessageIds, modifiedFolderIds, modifiedAccountIds);
+                if (result != Success)
+                    return result;
+            }
+        }
+
+    }
+
+
+    if (commitOnSuccess && !t.commit()) {
+        qMailLog(Messaging) << "Could not commit message update to database";
+        return DatabaseFailure;
+    }
+    */
+
+    if (parentAccountId.isValid()) {
+        // The message is now up-to-date with data store
+        metaData->setUnmodified();
+
+        if (headerCache.contains(metaData->id())) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(metaData->id());
+            if (!extractedValues.isEmpty()) {
+                // Update the cache with the modifications we recorded
+                updateMessageValues(updateProperties, extractedValues, metaData->customFields(), cachedMetaData);
+                cachedMetaData.setUnmodified();
+                headerCache.insert(cachedMetaData);
+            }
+            //uidCache.insert(qMakePair(cachedMetaData.parentAccountId(), cachedMetaData.serverUid()), cachedMetaData.id());
+        }
+
+        updatedMessageIds->append(metaData->id());
+        *modifiedFolderIds = folderIds;
+
+        if (metaData->parentAccountId().isValid())
+            modifiedAccountIds->append(metaData->parentAccountId());
+        if (parentAccountId.isValid()) {
+            if (parentAccountId != metaData->parentAccountId())
+                modifiedAccountIds->append(parentAccountId);
+        }
+    }
+
+    if (updateContent) {
+        modifiedMessageIds->append(metaData->id());
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &props, const QMailMessageMetaData &data, 
+                                                                                  QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                                  Transaction &t, bool commitOnSuccess) 
+{
+    //do some checks first
+    if (props & QMailMessageKey::Id) {
+        qMailLog(Messaging) << "Updating of messages IDs is not supported";
+        return Failure;
+    }
+    
+    QMailMessageKey::Properties properties(props);
+
+    if (properties & QMailMessageKey::ParentFolderId) {
+          MailFolderUri folderUri(data.parentFolderId());
+        if (!uriExists(folderUri)) {
+
+            qMailLog(Messaging) << "Update of messages failed. Parent folder does not exist";
+            return Failure;
+        }
+    }
+    
+     // TBD: Update message metadata
+    Q_UNUSED(key);
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(t);
+
+
+    QVariantList extractedValues;
+    
+
+    // Update the header cache
+    foreach (const QMailMessageId& id, *updatedMessageIds) {
+        if (headerCache.contains(id)) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(id);
+            updateMessageValues(properties, extractedValues, data.customFields(), cachedMetaData);
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateMessagesStatus(const QMailMessageKey &key, quint64 status, bool set, 
+                                                                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                                                Transaction &t, bool commitOnSuccess)
+{
+    //get the valid ids
+    *updatedMessageIds = queryMessages(key, QMailMessageSortKey(), 0, 0);
+
+    // TBD: Update status
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(t)
+
+    // Update the header cache
+    foreach (const QMailMessageId& id, *updatedMessageIds) {
+        if (headerCache.contains(id)) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(id);
+            quint64 newStatus = cachedMetaData.status();
+            newStatus = set ? (newStatus | status) : (newStatus & ~status);
+            cachedMetaData.setStatus(newStatus);
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRestoreToPreviousFolder(const QMailMessageKey &key, 
+                                                                                   QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                                                   Transaction &t, bool commitOnSuccess)
+{
+
+     // TBD: Restore messages to previous folder
+    Q_UNUSED(key);
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(t);
+
+
+
+    // Update the header cache
+    foreach (const QMailMessageId &id, *updatedMessageIds) {
+        if (headerCache.contains(id)) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(id);
+            cachedMetaData.setParentFolderId(cachedMetaData.previousParentFolderId());
+            cachedMetaData.setPreviousParentFolderId(QMailFolderId());
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptPurgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids,
+                                                                                      Transaction &t, bool commitOnSuccess)
+{
+    QMailMessageIdList removalIds;
+
+     // TBD: Purge remove records
+    Q_UNUSED(accountId);
+    Q_UNUSED(serverUids);
+    Q_UNUSED(t);
+
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptSizeOfMessages(const QMailMessageKey &key, 
+                                                                          int *result, 
+                                                                          ReadLock &)
+{
+    // TBD: Count overal size of the messages
+    Q_UNUSED(key);
+    Q_UNUSED(result);
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(const QMailAccountId &id, 
+                                                                                QMailAccountConfiguration *result, 
+                                                                                ReadLock &)
+{
+    // TBD: Find any configuration fields for this account
+
+    // TBD: Fill account configuration with information
+
+
+    result->setId(id);
+    result->setModified(false);
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessage(const QString &uid, const QMailAccountId &accountId, 
+                                                                   QMailMessage *result, 
+                                                                   ReadLock &lock)
+{
+      quint64 id(0);
+
+    {
+        // TBD: Search for the message with particular server UID
+        Q_UNUSED(uid);
+        Q_UNUSED(accountId);
+    }
+
+    if (id == 0) {
+        return Failure;
+    }
+
+    return attemptMessage(QMailMessageId(id), result, lock);
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessagesMetaData(const QMailMessageKey& key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option, 
+                                                                            QMailMessageMetaDataList *result, 
+                                                                            ReadLock &)
+{
+      if (properties == QMailMessageKey::Custom) {
+        // We're only selecting custom fields
+
+        // TBD: Search by custom fields
+        QMap<QString, QStringList> fields;
+        int maxLen = 0;
+        Q_UNUSED(key);
+
+        for (int i = 0; i < maxLen; ++i)
+            result->append(QMailMessageMetaData());
+
+        // Add all pairs to the results
+        foreach (const QString &name, fields.keys()) {
+            QMailMessageMetaDataList::iterator it = result->begin();
+            foreach (const QString &value, fields[name]) {
+                (*it).setCustomField(name, value);
+                ++it;
+            }
+        }
+
+        QMailMessageMetaDataList::iterator it = result->begin(), end = result->end();
+        for ( ; it != end; ++it)
+            (*it).setCustomFieldsModified(false);
+    } else {
+        bool includeCustom(properties & QMailMessageKey::Custom);
+        if (includeCustom && (option == QMailStore::ReturnDistinct)) {
+            qWarning() << "Warning: Distinct-ness is not supported with custom fields!";
+        }
+
+        QMailMessageKey::Properties props(properties);
+
+        bool removeId(false);
+        if (includeCustom && !(props & QMailMessageKey::Id)) {
+            // We need the ID to match against the custom table
+            props |= QMailMessageKey::Id;
+            removeId = true;
+        }
+
+        {
+            // TBD: Search messages by fields
+        }
+
+        if (includeCustom) {
+            QMailMessageMetaDataList::iterator it = result->begin(), end = result->end();
+            for ( ; it != end; ++it) {
+                // Add the custom fields to the record
+                QMap<QString, QString> fields;
+                AttemptResult attemptResult = customFields((*it).id().toULongLong(), &fields);
+                if (attemptResult != Success)
+                    return attemptResult;
+
+                QMailMessageMetaData &metaData(*it);
+                metaData.setCustomFields(fields);
+                metaData.setCustomFieldsModified(false);
+
+                if (removeId)
+                    metaData.setId(QMailMessageId());
+            }
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessageRemovalRecords(const QMailAccountId &accountId, const QMailFolderId &folderId, 
+                                                                                 QMailMessageRemovalRecordList *result, 
+                                                                                 ReadLock &)
+{
+   // TBD: Search for deleted messages
+    Q_UNUSED(accountId);
+    Q_UNUSED(folderId);
+    Q_UNUSED(result);
+
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessageFolderIds(const QMailMessageKey &key, 
+                                                                            QMailFolderIdList *result, 
+                                                                            ReadLock &)
+{
+    // TBD: Look for message ID
+    Q_UNUSED(key);
+    Q_UNUSED(result);
+
+    return Success;
+}
+
+
+
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptFolderAccountIds(const QMailFolderKey &key, 
+                                                                            QMailAccountIdList *result, 
+                                                                            ReadLock &)
+{
+  // TBD: Look for message folder ID
+    Q_UNUSED(key);
+    Q_UNUSED(result);
+
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptFolderAncestorIds(const QMailFolderIdList &ids, 
+                                                                             QMailFolderIdList *result, 
+                                                                             ReadLock &)
+{
+    // TBD: Look for ancestor message folder ID
+    Q_UNUSED(ids);
+    Q_UNUSED(result);
+
+    return Success;
+}
+
+void QMailStorePrivate::preloadHeaderCache(const QMailMessageId& id) const
+{
+    QMailMessageIdList idBatch;
+    idBatch.append(id);
+
+    int index = lastQueryMessageResult.indexOf(id);
+    if (index != -1) {
+        // Preload based on result of last call to queryMessages
+        int count = 1;
+
+        QMailMessageIdList::const_iterator begin = lastQueryMessageResult.begin();
+        QMailMessageIdList::const_iterator end = lastQueryMessageResult.end();
+        QMailMessageIdList::const_iterator lowIt = begin + index;
+        QMailMessageIdList::const_iterator highIt = lowIt;
+
+        bool ascend(true);
+        bool descend(lowIt != begin);
+
+        while ((count < (QMailStorePrivate::lookAhead * 2)) && (ascend || descend)) {
+            if (ascend) {
+                ++highIt;
+                if (highIt == end) {
+                    ascend = false;
+                } else  {
+                    if (!headerCache.contains(*highIt)) {
+                        idBatch.append(*highIt);
+                        ++count;
+                    } else {
+                        // Most likely, a sequence in the other direction will be more useful
+                        ascend = false;
+                    }
+                }
+            }
+
+            if (descend) {
+                --lowIt;
+                if (!headerCache.contains(*lowIt)) {
+                    idBatch.prepend(*lowIt);
+                    ++count;
+
+                    if (lowIt == begin) {
+                        descend = false;
+                    }
+                } else {
+                    // Most likely, a sequence in the other direction will be more useful
+                    descend = false;
+                }
+            }
+        }
+    } else {
+        // Don't bother preloading - if there is a query result, we have now searched outside it;
+        // we should consider it to have outlived its usefulness
+        if (!lastQueryMessageResult.isEmpty())
+            lastQueryMessageResult = QMailMessageIdList();
+    }
+
+    QMailMessageMetaData result;
+    QMailMessageKey key(QMailMessageKey::id(idBatch));
+    foreach (const QMailMessageMetaData& metaData, messagesMetaData(key, allMessageProperties(), QMailStore::ReturnAll)) {
+        if (metaData.id().isValid()) {
+            headerCache.insert(metaData);
+            if (metaData.id() == id)
+                result = metaData;
+        }
+    }
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptStatusBit(const QString &name, const QString &context, 
+                                                                     int *result, 
+                                                                     ReadLock &)
+{
+     // TBD: Find out wheither this status bit is present
+    Q_UNUSED(name);
+    Q_UNUSED(context);
+    Q_UNUSED(result);
+
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRegisterStatusBit(const QString &name, const QString &context, int maximum, 
+                                                                             Transaction &t, bool commitOnSuccess)
+{
+     int highest = 0;
+
+    // TBD: Find out the highest bit
+    Q_UNUSED(name);
+    Q_UNUSED(context);
+    Q_UNUSED(t);
+
+    if (highest == maximum) {
+        return Failure;
+    } else {
+        // TBD: Add new status bit
+    }
+
+    t.commit();
+
+    return Success;
+
+}
+
+
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::affectedByMessageIds(const QMailMessageIdList &messages, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const
+{
+    AttemptResult result;
+
+    // Find the set of folders whose contents are modified by this update
+    QMailFolderIdList messageFolderIds;
+
+    QMailStorePrivate *self(const_cast<QMailStorePrivate*>(this));
+    {
+        ReadLock l(self);
+        result = self->attemptMessageFolderIds(QMailMessageKey::id(messages), &messageFolderIds, l);
+    }
+
+    if (result != Success)
+        return result;
+
+    return affectedByFolderIds(messageFolderIds, folderIds, accountIds);
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::affectedByFolderIds(const QMailFolderIdList &folders, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const
+{
+    AttemptResult result;
+
+    // Any ancestor folders are also modified
+    QMailFolderIdList ancestorIds;
+
+    QMailStorePrivate *self(const_cast<QMailStorePrivate*>(this));
+    {
+        ReadLock l(self);
+        result = self->attemptFolderAncestorIds(folders, &ancestorIds, l);
+    }
+
+    if (result != Success)
+        return result;
+
+    *folderIds = folders + ancestorIds;
+
+    // Find the set of accounts whose contents are modified by this update
+    ReadLock l(self);
+    result = self->attemptFolderAccountIds(QMailFolderKey::id(*folderIds), accountIds, l);
+    return result;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::messagePredecessor(QMailMessageMetaData *metaData, const QStringList &references, const QString &baseSubject, bool replyOrForward,
+                                                                       QStringList *missingReferences, bool *missingAncestor)
+{/*
+   TBD: Implement queries in sparql (thread handling)
+
+    QList<quint64> potentialPredecessors;
+
+    if (!references.isEmpty()) {
+        // Find any messages that correspond to these references
+        QMap<QString, QList<quint64> > referencedMessages;
+
+        QVariantList refs;
+        foreach (const QString &ref, references) {
+            refs.append(QVariant(ref));
+        }
+
+        {
+            QString sql("SELECT id,identifier FROM mailmessageidentifiers WHERE identifier IN %1");
+            QSqlQuery query(simpleQuery(sql.arg(expandValueList(refs)),
+                                        refs,
+                                        "messagePredecessor mailmessageidentifiers select query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            while (query.next()) {
+                referencedMessages[extractValue<QString>(query.value(1))].append(extractValue<quint64>(query.value(0).toInt()));
+            }
+        }
+
+        if (referencedMessages.isEmpty()) {
+            // All the references are missing
+            *missingReferences = references;
+        } else {
+            for (int i = references.count() - 1; i >= 0; --i) {
+                const QString &refId(references.at(i));
+
+                QMap<QString, QList<quint64> >::const_iterator it = referencedMessages.find(refId);
+                if (it != referencedMessages.end()) {
+                    const QList<quint64> &messageIds(it.value());
+
+                    if (messageIds.count() == 1) {
+                        // This is the best parent message choice
+                        potentialPredecessors.append(messageIds.first());
+                        break;
+                    } else {
+                        // TODO: We need to choose a best selection from amongst these messages
+                        // For now, just process the order the DB gave us
+                        potentialPredecessors = messageIds;
+                        break;
+                    }
+                } else {
+                    missingReferences->append(refId);
+                }
+            }
+        }
+    } else if (!baseSubject.isEmpty() && replyOrForward) {
+        // This message has a thread ancestor, but we can only estimate which is the best choice
+        *missingAncestor = true;
+
+        // Find the preceding messages of all thread matching this base subject
+        QSqlQuery query(simpleQuery("SELECT id FROM mailmessages "
+                                    "WHERE id!=? "
+                                    "AND parentaccountid=? "
+                                    "AND stamp<? "
+                                    "AND id IN ("
+                                        "SELECT messageid FROM mailthreadmessages mtm WHERE threadid IN ("
+                                            "SELECT threadid FROM mailthreadsubjects WHERE subjectid = ("
+                                                "SELECT id FROM mailsubjects WHERE basesubject=?"
+                                            ")"
+                                        ")"
+                                    ") "
+                                    "ORDER BY stamp DESC",
+                                    QVariantList() << metaData->id().toULongLong() 
+                                                    << metaData->parentAccountId().toULongLong() 
+                                                    << metaData->date().toLocalTime() 
+                                                    << baseSubject,
+                                    "messagePredecessor mailmessages select query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        while (query.next()) {
+            potentialPredecessors.append(extractValue<quint64>(query.value(0)));
+        }
+    }
+
+    if (!potentialPredecessors.isEmpty()) {
+        quint64 predecessorId(0);
+        quint64 messageId(metaData->id().toULongLong());
+
+        if (messageId != 0) {
+            // We already exist - therefore we must ensure that we do not create a response ID cycle
+            QMap<quint64, quint64> predecessor;
+
+            {
+
+                // Find the predecessor message for every message in the same thread as us
+                QSqlQuery query(simpleQuery("SELECT id,responseid FROM mailmessages WHERE id IN ("
+                                                "SELECT messageid FROM mailthreadmessages WHERE threadid = ("
+                                                    "SELECT threadid FROM mailthreadmessages WHERE messageid=?"
+                                                ")"
+                                            ")",
+                                            QVariantList() << metaData->id().toULongLong(),
+                                            "identifyAncestors mailmessages query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+
+                while (query.next())
+                    predecessor.insert(extractValue<quint64>(query.value(0)), extractValue<quint64>(query.value(1)));
+            }
+
+            // Choose the best predecessor, ensuring that we don't pick a message whose own ancestors include us
+            while (!potentialPredecessors.isEmpty()) {
+                quint64 ancestorId = potentialPredecessors.first();
+
+                bool descendant(false);
+                while (ancestorId) {
+                    if (ancestorId == messageId) {
+                        // This message is a descendant of ourself
+                        descendant = true;
+                        break;
+                    } else {
+                        ancestorId = predecessor[ancestorId];
+                    }
+                }
+
+                if (!descendant) {
+                    // This message can become our predecessor
+                    predecessorId = potentialPredecessors.first();
+                    break;
+                } else {
+                    // Try the next option, if any
+                    potentialPredecessors.takeFirst();
+                }
+            }
+        } else {
+            // Just take the first selection
+            predecessorId = potentialPredecessors.first();
+        }
+
+        if (predecessorId) {
+            metaData->setInResponseTo(QMailMessageId(predecessorId));
+
+            // TODO: What kind of response is this?  If the predecessor is from the same
+            // account as the new message then it is probably a reply.  Otherwise, forward?
+            metaData->setResponseType(QMailMessage::Reply);
+        }
+    }
+    */
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::identifyAncestors(const QMailMessageId &predecessorId, const QMailMessageIdList &childIds, QMailMessageIdList *ancestorIds)
+{
+    /*
+      TBD: implement SparQl queries for this (thread handling)
+    if (!childIds.isEmpty() && predecessorId.isValid()) {
+        QMap<quint64, quint64> predecessor;
+
+        {
+            // Find the predecessor message for every message in the same thread as the predecessor
+            QSqlQuery query(simpleQuery("SELECT id,responseid FROM mailmessages WHERE id IN ("
+                                            "SELECT messageid FROM mailthreadmessages WHERE threadid = ("
+                                                "SELECT threadid FROM mailthreadmessages WHERE messageid=?"
+                                            ")"
+                                        ")",
+                                        QVariantList() << predecessorId.toULongLong(),
+                                        "identifyAncestors mailmessages query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            while (query.next())
+                predecessor.insert(extractValue<quint64>(query.value(0)), extractValue<quint64>(query.value(1)));
+        }
+
+        // Ensure that none of the prospective children are predecessors of this message
+        quint64 messageId = predecessorId.toULongLong();
+        while (messageId) {
+            if (childIds.contains(QMailMessageId(messageId))) {
+                ancestorIds->append(QMailMessageId(messageId));
+            }
+
+            messageId = predecessor[messageId];
+        }
+    }
+    */
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::resolveMissingMessages(const QString &identifier, const QMailMessageId &predecessorId, const QString &baseSubject, quint64 messageId, QMailMessageIdList *updatedMessageIds)
+{
+
+    /*
+
+      TBD: create sparql queries for this threading functionality
+
+    QMap<QMailMessageId, quint64> descendants;
+
+    if (!identifier.isEmpty()) {
+        QSqlQuery query(simpleQuery("SELECT DISTINCT id,level FROM missingmessages WHERE identifier=?",
+                                    QVariantList() << identifier,
+                                    "resolveMissingMessages missingmessages query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        while (query.next())
+            descendants.insert(QMailMessageId(extractValue<quint64>(query.value(0))), extractValue<quint64>(query.value(1)));
+    }
+
+    if (!descendants.isEmpty() && predecessorId.isValid()) {
+        QMailMessageIdList ancestorIds;
+
+        // Do not create a cycle - ensure that none of these messages is an ancestor of the new message
+        AttemptResult result = identifyAncestors(predecessorId, descendants.keys(), &ancestorIds);
+        if (result != Success)
+            return result;
+
+        // Ensure that none of the ancestors become descendants of this message
+        foreach (const QMailMessageId &id, ancestorIds) {
+            descendants.remove(id);
+        }
+    }
+
+    if (!descendants.isEmpty()) {
+        QVariantList descendantIds;
+        QVariantList descendantLevels;
+
+        QMap<QMailMessageId, quint64>::const_iterator it = descendants.begin(), end = descendants.end();
+        for ( ; it != end; ++it) {
+            updatedMessageIds->append(it.key());
+
+            descendantIds.append(QVariant(it.key().toULongLong()));
+            descendantLevels.append(QVariant(it.value()));
+        }
+
+        {
+            // Update these descendant messages to have the new message as their predecessor
+            QSqlQuery query(simpleQuery("UPDATE mailmessages SET responseid=?",
+                                        QVariantList() << messageId,
+                                        Key(QMailMessageKey::id(*updatedMessageIds)),
+                                        "resolveMissingMessages mailmessages update query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        {
+            // Truncate the missingmessages entries for each updated messages
+            QSqlQuery query(batchQuery("DELETE FROM missingmessages WHERE id=? AND level>=?",
+                                       QVariantList() << QVariant(descendantIds) << QVariant(descendantLevels),
+                                       "resolveMissingMessages missingmessages delete query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        QVariantList obsoleteThreadIds;
+
+        {
+            // Find the threads that the descendants currently belong to
+            QSqlQuery query(simpleQuery("SELECT DISTINCT threadid FROM mailthreadmessages",
+                                        Key("messageid", QMailMessageKey::id(*updatedMessageIds)),
+                                        "resolveMissingMessages mailthreadmessages query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            while (query.next())
+                obsoleteThreadIds.append(QVariant(extractValue<quint64>(query.value(0))));
+        }
+
+        {
+            // Attach the descendants to the thread of their new predecessor
+            QSqlQuery query(simpleQuery("UPDATE mailthreadmessages SET threadid=(SELECT threadid FROM mailthreadmessages WHERE messageid=?)",
+                                        QVariantList() << messageId,
+                                        Key("messageid", QMailMessageKey::id(*updatedMessageIds)),
+                                        "resolveMissingMessages mailthreadmessages update query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+
+        if (!obsoleteThreadIds.isEmpty()) {
+            // Delete the obsolete threads
+            QString sql("DELETE FROM mailthreads WHERE id IN %1");
+            QSqlQuery query(simpleQuery(sql.arg(expandValueList(obsoleteThreadIds)),
+                                        obsoleteThreadIds,
+                                        "resolveMissingMessages mailthreads delete query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+    }
+
+    if (!baseSubject.isEmpty()) {
+        QMailMessageIdList ids;
+
+        {
+            // See if there are any messages waiting for a thread ancestor message with this subject
+            // (or who have one that is older than this message)
+            QSqlQuery query(simpleQuery("SELECT id FROM mailmessages mm "
+                                        "WHERE id IN ("
+                                            "SELECT messageid FROM missingancestors WHERE subjectid=(SELECT id FROM mailsubjects WHERE basesubject=?) "
+                                        ") AND "
+                                            "stamp > (SELECT stamp FROM mailmessages WHERE id=?) "
+                                        "AND ("
+                                            "mm.responseid=0 "
+                                        "OR "
+                                            "(SELECT stamp FROM mailmessages WHERE id=?) > (SELECT stamp FROM mailmessages WHERE id=mm.responseid)"
+                                        ")",
+                                        QVariantList() << baseSubject << messageId << messageId,
+                                        "resolveMissingMessages missingancestors query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            while (query.next())
+                ids.append(QMailMessageId(extractValue<quint64>(query.value(0))));
+        }
+
+        if (!ids.isEmpty() && predecessorId.isValid()) {
+            QMailMessageIdList ancestorIds;
+
+            // Do not create a cycle - ensure that none of these messages is an ancestor of the new message
+            AttemptResult result = identifyAncestors(predecessorId, ids, &ancestorIds);
+            if (result != Success)
+                return result;
+
+            // Ensure that none of the ancestors become descendants of this message
+            foreach (const QMailMessageId &id, ancestorIds) {
+                ids.removeAll(id);
+            }
+        }
+
+        if (!ids.isEmpty()) {
+            {
+                // Update these descendant messages to have the new message as their predecessor
+                QSqlQuery query(simpleQuery("UPDATE mailmessages SET responseid=?",
+                                            QVariantList() << messageId,
+                                            Key(QMailMessageKey::id(ids)),
+                                            "resolveMissingMessages mailmessages update root query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+            }
+
+            {
+                // Remove the missing ancestor records
+                QSqlQuery query(simpleQuery("UPDATE missingancestors SET state=1",
+                                            Key("messageid", QMailMessageKey::id(ids)),
+                                            "resolveMissingMessages missingancestors delete query"));
+                if (query.lastError().type() != QSqlError::NoError)
+                    return DatabaseFailure;
+            }
+
+            *updatedMessageIds += ids;
+        }
+    }
+    */
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::registerSubject(const QString &baseSubject, quint64 messageId, const QMailMessageId &predecessorId, bool missingAncestor)
+{
+    /*
+     TBD: Add sparql queries for this threading handling
+
+    int subjectId = 0;
+
+    {
+        QSqlQuery query(simpleQuery("SELECT id FROM mailsubjects WHERE basesubject=?",
+                                    QVariantList() << baseSubject,
+                                    "registerSubject mailsubjects query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        if (query.next())
+            subjectId = extractValue<quint64>(query.value(0));
+    }
+    
+    if (subjectId == 0) {
+        QSqlQuery query(simpleQuery("INSERT INTO mailsubjects (basesubject) VALUES (?)",
+                                    QVariantList() << baseSubject,
+                                    "registerSubject mailsubjects insert query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        // Retrieve the insert id
+        subjectId = extractValue<quint64>(query.lastInsertId());
+    }
+
+    // Ensure that this thread is linked to the base subject of this message
+    int count = 0;
+    {
+        QSqlQuery query(simpleQuery("SELECT COUNT(*) FROM mailthreadsubjects "
+                                    "WHERE subjectid=? AND threadid = (SELECT threadid FROM mailthreadmessages WHERE messageid=?)",
+                                    QVariantList() << subjectId << messageId,
+                                    "registerSubject mailthreadsubjects query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        if (query.next())
+            count = extractValue<int>(query.value(0));
+    }
+    
+    if (count == 0) {
+        QSqlQuery query(simpleQuery("INSERT INTO mailthreadsubjects (threadid,subjectid) SELECT threadid,? FROM mailthreadmessages WHERE messageid=?",
+                                    QVariantList() << subjectId << messageId,
+                                    "registerSubject mailthreadsubjects insert query"));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+    }
+
+    if (missingAncestor) {
+        count = 0;
+
+        {
+            // We need to record that this message's ancestor is currently missing
+            QSqlQuery query(simpleQuery("SELECT COUNT(*) FROM missingancestors WHERE messageid=?",
+                                        QVariantList() << messageId,
+                                        "registerSubject missingancestors query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+
+            if (query.next())
+                count = extractValue<int>(query.value(0));
+        }
+
+        if (count == 0) {
+            quint64 state(predecessorId.isValid() ? 1 : 0);
+            QSqlQuery query(simpleQuery("INSERT INTO missingancestors (messageid,subjectid,state) VALUES(?,?,?)",
+                                        QVariantList() << messageId << subjectId << state,
+                                        "registerSubject missingancestors insert query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        } else {
+            QSqlQuery query(simpleQuery("UPDATE missingancestors SET subjectid=? WHERE messageid=?",
+                                        QVariantList() << subjectId << messageId,
+                                        "registerSubject missingancestors update query"));
+            if (query.lastError().type() != QSqlError::NoError)
+                return DatabaseFailure;
+        }
+    }
+    */
+
+
+    return Success;
+}
+
+bool QMailStorePrivate::checkPreconditions(const QMailFolder& folder, bool update)
+{
+    //if the parent is valid, check that it exists 
+    //if the account is valid, check that is exists 
+
+    if(!update)
+    {
+        if(folder.id().isValid())
+        {
+            qMailLog(Messaging) << "Folder exists, use update instead of add.";
+            return false;
+        }
+    }
+    else 
+    {
+        if(!folder.id().isValid())
+        {
+            qMailLog(Messaging) << "Folder does not exist, use add instead of update.";
+            return false;
+        }
+
+        if(folder.parentFolderId().isValid() && folder.parentFolderId() == folder.id())
+        {
+            qMailLog(Messaging) << "A folder cannot be a child to itself";
+            return false;
+        }
+    }
+
+    if(folder.parentFolderId().isValid())
+    {
+        MailFolderUri folderUri(folder.parentFolderId());
+        if(!uriExists(folderUri))
+        {
+            qMailLog(Messaging) << "Parent folder does not exist!";
+            return false;
+        }
+    }
+
+    if(folder.parentAccountId().isValid())
+    {
+        MailAccountUri accountUri(folder.parentAccountId());
+        if(!uriExists(accountUri))
+        {
+            qMailLog(Messaging) << "Parent account does not exist!";
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::deleteMessages(const QMailMessageKey& key, 
+                                       QMailStore::MessageRemovalOption option, 
+                                       QMailMessageIdList& deletedMessageIds, 
+                                       QStringList& expiredContent, 
+                                       QMailMessageIdList& updatedMessageIds, 
+                                       QMailFolderIdList& modifiedFolderIds,
+                                       QMailAccountIdList& modifiedAccountIds)
+{
+    // TBD: Delete messages
+    Q_UNUSED(key);
+    Q_UNUSED(option);
+    Q_UNUSED(deletedMessageIds);
+    Q_UNUSED(expiredContent);
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(updatedMessageIds);
+
+    return true;
+}
+
+bool QMailStorePrivate::deleteFolders(const QMailFolderKey& key, 
+                                      QMailStore::MessageRemovalOption option, 
+                                      QMailFolderIdList& deletedFolderIds, 
+                                      QMailMessageIdList& deletedMessageIds, 
+                                      QStringList& expiredContent, 
+                                      QMailMessageIdList& updatedMessageIds, 
+                                      QMailFolderIdList& modifiedFolderIds, 
+                                      QMailAccountIdList& modifiedAccountIds)
+{
+       // TBD: Delete folders, subfolders and all messages
+    Q_UNUSED(key);
+    Q_UNUSED(option);
+    Q_UNUSED(deletedFolderIds);
+    Q_UNUSED(deletedMessageIds);
+    Q_UNUSED(expiredContent);
+    Q_UNUSED(modifiedAccountIds);
+
+    return true;
+}
+
+bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key, 
+                                       QMailAccountIdList& deletedAccountIds, 
+                                       QMailFolderIdList& deletedFolderIds, 
+                                       QMailMessageIdList& deletedMessageIds, 
+                                       QStringList& expiredContent, 
+                                       QMailMessageIdList& updatedMessageIds, 
+                                       QMailFolderIdList& modifiedFolderIds, 
+                                       QMailAccountIdList& modifiedAccountIds)
+{
+   // TBD: Delete accounts, folders, subfolders and all messages
+    Q_UNUSED(key);
+    Q_UNUSED(deletedAccountIds);
+    Q_UNUSED(deletedFolderIds);
+    Q_UNUSED(deletedMessageIds);
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(updatedMessageIds);
+    Q_UNUSED(expiredContent);
+
+    return true;
+
+}
+bool QMailStorePrivate::obsoleteContent(const QString& identifier)
+{
+
+    /*
+      TBD: add this handling to the sparQL
+    QSqlQuery query(simpleQuery("INSERT INTO obsoletefiles (mailfile) VALUES (?)",
+                                QVariantList() << QVariant(identifier),
+                                "obsoleteContent files insert query"));
+    if (query.lastError().type() != QSqlError::NoError) {
+        qWarning() << "Unable to record obsolete content:" << identifier;
+        return false;
+    }
+    */
+
+    return true;
+}
+/*
+
+  TBD: Replace these with SparQL queries
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const QString& descriptor)
+{
+    return performQuery(statement, false, QVariantList(), QList<Key>(), qMakePair(0u, 0u), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const QVariantList& bindValues, const QString& descriptor)
+{
+    return performQuery(statement, false, bindValues, QList<Key>(), qMakePair(0u, 0u), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const Key& key, const QString& descriptor)
+{
+    return performQuery(statement, false, QVariantList(), QList<Key>() << key, qMakePair(0u, 0u), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const QVariantList& bindValues, const Key& key, const QString& descriptor)
+{
+    return performQuery(statement, false, bindValues, QList<Key>() << key, qMakePair(0u, 0u), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor)
+{
+    return performQuery(statement, false, bindValues, keys, qMakePair(0u, 0u), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::simpleQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QPair<uint, uint> &constraint, const QString& descriptor)
+{
+    return performQuery(statement, false, bindValues, keys, constraint, descriptor);
+}
+
+QSqlQuery QMailStorePrivate::batchQuery(const QString& statement, const QVariantList& bindValues, const QString& descriptor)
+{
+    return performQuery(statement, true, bindValues, QList<Key>(), qMakePair(0u, 0u), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::batchQuery(const QString& statement, const QVariantList& bindValues, const Key& key, const QString& descriptor)
+{
+    return performQuery(statement, true, bindValues, QList<Key>() << key, qMakePair(0u, 0u), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::batchQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor)
+{
+    return performQuery(statement, true, bindValues, keys, qMakePair(0u, 0u), descriptor);
+}
+
+QSqlQuery QMailStorePrivate::performQuery(const QString& statement, bool batch, const QVariantList& bindValues, const QList<Key>& keys, const QPair<uint, uint> &constraint, const QString& descriptor)
+{
+    QString keyStatements;
+    QVariantList keyValues;
+
+    bool firstClause(true);
+    foreach (const Key &key, keys) {
+        if (key.isType<QMailMessageKey>() || key.isType<QMailFolderKey>() || key.isType<QMailAccountKey>()) {
+            keyStatements.append(buildWhereClause(key, false, firstClause));
+            keyValues << whereClauseValues(key);
+        } else if (key.isType<QMailMessageSortKey>() || key.isType<QMailFolderSortKey>() || key.isType<QMailAccountSortKey>()) {
+            keyStatements.append(buildOrderClause(key));
+        } else if (key.isType<QString>()) {
+            keyStatements.append(key.key<QString>());
+        }
+
+        firstClause = false;
+    }
+
+    QString constraintStatements;
+    if ((constraint.first > 0) || (constraint.second > 0)) {
+        if (constraint.first > 0) {
+            constraintStatements.append(QString(" LIMIT %1").arg(constraint.first));
+        }
+        if (constraint.second > 0) {
+            constraintStatements.append(QString(" OFFSET %1").arg(constraint.second));
+        }
+    }
+
+    QSqlQuery query(prepare(statement + keyStatements + constraintStatements));
+    if (queryError() != QSqlError::NoError) {
+        qMailLog(Messaging) << "Could not prepare query" << descriptor;
+    } else {
+        foreach (const QVariant& value, bindValues)
+            query.addBindValue(value);
+        foreach (const QVariant& value, keyValues)
+            query.addBindValue(value);
+
+        if (!execute(query, batch)){
+            qMailLog(Messaging) << "Could not execute query" << descriptor;
+        }
+    }
+
+    return query;
+}
+
+*/
+
+void QMailStorePrivate::emitIpcNotification(QMailStoreImplementation::AccountUpdateSignal signal, const QMailAccountIdList &ids)
+{
+    if ((signal == &QMailStore::accountsUpdated) || (signal == &QMailStore::accountsRemoved)) {
+        foreach (const QMailAccountId &id, ids)
+            accountCache.remove(id);
+    }
+
+    QMailStoreImplementation::emitIpcNotification(signal, ids);
+}
+
+void QMailStorePrivate::emitIpcNotification(QMailStoreImplementation::FolderUpdateSignal signal, const QMailFolderIdList &ids)
+{
+    if ((signal == &QMailStore::foldersUpdated) || (signal == &QMailStore::foldersRemoved)) {
+        foreach (const QMailFolderId &id, ids)
+            folderCache.remove(id);
+    }
+
+    QMailStoreImplementation::emitIpcNotification(signal, ids);
+}
+
+void QMailStorePrivate::emitIpcNotification(QMailStoreImplementation::MessageUpdateSignal signal, const QMailMessageIdList &ids)
+{
+    if ((signal == &QMailStore::messagesUpdated) || (signal == &QMailStore::messagesRemoved)) {
+        foreach (const QMailMessageId &id, ids)
+            headerCache.remove(id);
+    }
+
+    QMailStoreImplementation::emitIpcNotification(signal, ids);
+}
+
+
diff --git a/src/libraries/qtopiamail/qmailstore_sparql.h b/src/libraries/qtopiamail/qmailstore_sparql.h
new file mode 100644
index 0000000..9286c86
--- /dev/null
+++ b/src/libraries/qtopiamail/qmailstore_sparql.h
@@ -0,0 +1,537 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the Qt Messaging Framework.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the either Technology Preview License Agreement or the
+** Beta Release License Agreement.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMAILSTORE_P_H
+#define QMAILSTORE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt Extended API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qmailstoreimplementation_p.h"
+#include "sparqldatabase.h"
+#include <QCache>
+
+//#define QMAILSTORE_LOG_SQL //define to enable SQL query logging
+//#define QMAILSTORE_USE_RTTI //define if RTTI is available to assist debugging
+
+#ifdef QMAILSTORE_USE_RTTI
+#include <typeinfo>
+#endif
+
+class ProcessMutex;
+class ProcessReadLock;
+class SparqlResult;
+class SparqlQuery;
+
+
+
+
+
+class QMailStorePrivate : public QMailStoreImplementation
+{
+    Q_OBJECT
+
+public:
+    typedef QMap<QMailMessageKey::Property, QString> MessagePropertyMap;
+    typedef QList<QMailMessageKey::Property> MessagePropertyList;
+
+    class Transaction;
+    class ReadLock;
+    class Key;
+
+    struct ReadAccess {};
+    struct WriteAccess {};
+
+    QMailStorePrivate(QMailStore* parent);
+    ~QMailStorePrivate();
+
+    virtual bool initStore();
+    void clearContent();
+
+    bool addAccount(QMailAccount *account, QMailAccountConfiguration *config,
+                    QMailAccountIdList *addedAccountIds);
+
+    bool addFolder(QMailFolder *f,
+                   QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool addMessages(const QList<QMailMessage *> &m,
+                     QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool addMessages(const QList<QMailMessageMetaData *> &m,
+                     QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool removeAccounts(const QMailAccountKey &key,
+                        QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool removeFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option,
+                       QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool removeMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option,
+                        QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool updateAccount(QMailAccount *account, QMailAccountConfiguration* config,
+                       QMailAccountIdList *updatedAccountIds);
+
+    bool updateAccountConfiguration(QMailAccountConfiguration* config,
+                                    QMailAccountIdList *updatedAccountIds);
+
+    bool updateFolder(QMailFolder* f,
+                      QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool updateMessages(const QList<QPair<QMailMessageMetaData *, QMailMessage *> > &m,
+                        QMailMessageIdList *updatedMessageIds, QMailMessageIdList *modifiedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool updateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, const QMailMessageMetaData &data,
+                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool updateMessagesMetaData(const QMailMessageKey &key, quint64 messageStatus, bool set,
+                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool restoreToPreviousFolder(const QMailMessageKey &key,
+                                 QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool purgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids);
+
+    int countAccounts(const QMailAccountKey &key) const;
+    int countFolders(const QMailFolderKey &key) const;
+    int countMessages(const QMailMessageKey &key) const;
+
+    int sizeOfMessages(const QMailMessageKey &key) const;
+
+    QMailAccountIdList queryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey, uint limit, uint offset) const;
+    QMailFolderIdList queryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey, uint limit, uint offset) const;
+    QMailMessageIdList queryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey, uint limit, uint offset) const;
+
+    QMailAccount account(const QMailAccountId &id) const;
+    QMailAccountConfiguration accountConfiguration(const QMailAccountId &id) const;
+
+    QMailFolder folder(const QMailFolderId &id) const;
+
+    QMailMessage message(const QMailMessageId &id) const;
+    QMailMessage message(const QString &uid, const QMailAccountId &accountId) const;
+
+    QMailMessageMetaData messageMetaData(const QMailMessageId &id) const;
+    QMailMessageMetaData messageMetaData(const QString &uid, const QMailAccountId &accountId) const;
+    QMailMessageMetaDataList messagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option) const;
+
+    QMailMessageRemovalRecordList messageRemovalRecords(const QMailAccountId &parentAccountId, const QMailFolderId &parentFolderId) const;
+
+    bool registerAccountStatusFlag(const QString &name);
+    quint64 accountStatusMask(const QString &name) const;
+
+    bool registerFolderStatusFlag(const QString &name);
+    quint64 folderStatusMask(const QString &name) const;
+
+    bool registerMessageStatusFlag(const QString &name);
+    quint64 messageStatusMask(const QString &name) const;
+
+    static QString expandValueList(const QVariantList& valueList);
+    static QString expandValueList(int valueCount);
+
+
+    template<typename ValueType>
+    static ValueType extractValue(const QVariant& var, const ValueType &defaultValue = ValueType());
+
+    enum AttemptResult { Success = 0, Failure, DatabaseFailure };
+    
+private:
+
+    friend class ReadLock;
+    friend class Transaction;
+
+    static ProcessMutex& contentManagerMutex(void);
+
+    ProcessMutex& databaseMutex(void) const;
+    ProcessReadLock& databaseReadLock(void) const;
+
+    static const MessagePropertyMap& messagePropertyMap();
+    static const MessagePropertyList& messagePropertyList();
+
+    static const QMailMessageKey::Properties &updatableMessageProperties();
+    static const QMailMessageKey::Properties &allMessageProperties();
+
+
+    QString databaseIdentifier() const;
+
+    bool setupStandardFolder(QMailFolder::StandardFolder folder, const QString& name);
+
+    void setQueryError(const SparqlQuery &error, const QString &description = QString(), const QString &statement = QString());
+    QString queryError() const;
+    void clearQueryError(void);
+
+    bool uriExists(const QString& uri);
+
+
+    bool checkPreconditions(const QMailFolder& folder, bool update = false);
+
+    void preloadHeaderCache(const QMailMessageId& id) const;
+
+    QMailFolderIdList folderAncestorIds(const QMailFolderIdList& ids, bool inTransaction, AttemptResult *result) const;
+
+    quint64 queryStatusMap(const QString &name, const QString &context, QMap<QString, quint64> &map) const;
+
+    bool deleteMessages(const QMailMessageKey& key,
+                        QMailStore::MessageRemovalOption option,
+                        QMailMessageIdList& deletedMessageIds,
+                        QStringList& expiredMailfiles,
+                        QMailMessageIdList& updatedMessageIds,
+                        QMailFolderIdList& modifiedFolders,
+                        QMailAccountIdList& modifiedAccounts);
+
+    bool deleteFolders(const QMailFolderKey& key,
+                       QMailStore::MessageRemovalOption option,
+                       QMailFolderIdList& deletedFolderIds,
+                       QMailMessageIdList& deletedMessageIds,
+                       QStringList& expiredMailfiles,
+                       QMailMessageIdList& updatedMessageIds,
+                       QMailFolderIdList& modifiedFolderIds,
+                       QMailAccountIdList& modifiedAccountIds);
+
+    bool deleteAccounts(const QMailAccountKey& key,
+                        QMailAccountIdList& deletedAccountIds,
+                        QMailFolderIdList& deletedFolderIds,
+                        QMailMessageIdList& deletedMessageIds,
+                        QStringList& expiredMailfiles,
+                        QMailMessageIdList& updatedMessageIds,
+                        QMailFolderIdList& modifiedFolderIds,
+                        QMailAccountIdList& modifiedAccountIds);
+
+    void removeExpiredData(const QMailMessageIdList& messageIds,
+                           const QStringList& mailfiles,
+                           const QMailFolderIdList& folderIds = QMailFolderIdList(),
+                           const QMailAccountIdList& accountIds = QMailAccountIdList());
+
+    bool obsoleteContent(const QString& identifier);
+
+    template<typename AccessType, typename FunctionType>
+    bool repeatedly(FunctionType func, const QString &description, Transaction *t = 0) const;
+
+    AttemptResult addCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
+    AttemptResult updateCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
+    AttemptResult customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName = QString() );
+
+    AttemptResult attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config, 
+                                    QMailAccountIdList *addedAccountIds, 
+                                    Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptAddFolder(QMailFolder *folder, 
+                                   QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                   Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptAddMessage(QMailMessage *message, const QString &identifier, const QStringList &references,
+                                    QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                    Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptAddMessage(QMailMessageMetaData *metaData, const QString &identifier, const QStringList &references,
+                                    QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                    Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptRemoveAccounts(const QMailAccountKey &key, 
+                                        QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                        Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptRemoveFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option, 
+                                       QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                       Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptRemoveMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option, 
+                                        QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                        Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptUpdateAccount(QMailAccount *account, QMailAccountConfiguration *config, 
+                                       QMailAccountIdList *updatedAccountIds,
+                                       Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptUpdateAccountConfiguration(QMailAccountConfiguration *config, 
+                                                    QMailAccountIdList *updatedAccountIds,
+                                                    Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptUpdateFolder(QMailFolder *folder, 
+                                      QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                      Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptUpdateMessage(QMailMessageMetaData *metaData, QMailMessage *mail, 
+                                       QMailMessageIdList *updatedMessageIds, QMailMessageIdList *modifiedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                       Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptUpdateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &props, const QMailMessageMetaData &data, 
+                                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                Transaction &t, bool commitOnSuccess); 
+
+    AttemptResult attemptUpdateMessagesStatus(const QMailMessageKey &key, quint64 status, bool set, 
+                                              QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                              Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptRestoreToPreviousFolder(const QMailMessageKey &key, 
+                                                 QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                 Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptPurgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids,
+                                                    Transaction &t, bool commitOnSuccess);
+
+    AttemptResult attemptCountAccounts(const QMailAccountKey &key, int *result, 
+                                       ReadLock &);
+
+    AttemptResult attemptCountFolders(const QMailFolderKey &key, int *result, 
+                                      ReadLock &);
+
+    AttemptResult attemptCountMessages(const QMailMessageKey &key, 
+                                       int *result, 
+                                       ReadLock &);
+
+    AttemptResult attemptSizeOfMessages(const QMailMessageKey &key, 
+                                        int *result, 
+                                        ReadLock &);
+
+    AttemptResult attemptQueryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey, uint limit, uint offset,
+                                       QMailAccountIdList *ids, 
+                                       ReadLock &);
+
+    AttemptResult attemptQueryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey, uint limit, uint offset,
+                                      QMailFolderIdList *ids, 
+                                      ReadLock &);
+
+    AttemptResult attemptQueryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey, uint limit, uint offset,
+                                       QMailMessageIdList *ids, 
+                                       ReadLock &);
+
+    AttemptResult attemptAccount(const QMailAccountId &id, 
+                                 QMailAccount *result, 
+                                 ReadLock &);
+
+    AttemptResult attemptAccountConfiguration(const QMailAccountId &id, 
+                                              QMailAccountConfiguration *result, 
+                                              ReadLock &);
+
+    AttemptResult attemptFolder(const QMailFolderId &id, 
+                                QMailFolder *result, 
+                                ReadLock &);
+
+    AttemptResult attemptMessage(const QMailMessageId &id, 
+                                 QMailMessage *result, 
+                                 ReadLock &);
+
+    AttemptResult attemptMessage(const QString &uid, const QMailAccountId &accountId, 
+                                 QMailMessage *result, 
+                                 ReadLock &);
+
+
+    AttemptResult attemptMessagesMetaData(const QMailMessageKey& key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option, 
+                                          QMailMessageMetaDataList *result, 
+                                          ReadLock &);
+
+    AttemptResult attemptMessageRemovalRecords(const QMailAccountId &accountId, const QMailFolderId &parentFolderId, 
+                                               QMailMessageRemovalRecordList *result,
+                                               ReadLock &);
+
+    AttemptResult attemptMessageFolderIds(const QMailMessageKey &key, 
+                                          QMailFolderIdList *result, 
+                                          ReadLock &);
+
+    AttemptResult attemptFolderAccountIds(const QMailFolderKey &key, 
+                                          QMailAccountIdList *result, 
+                                          ReadLock &);
+
+    AttemptResult attemptFolderAncestorIds(const QMailFolderIdList &ids, 
+                                           QMailFolderIdList *result, 
+                                           ReadLock &);
+
+    AttemptResult attemptStatusBit(const QString &name, const QString &context, 
+                                   int *result, 
+                                   ReadLock &);
+
+    AttemptResult attemptRegisterStatusBit(const QString &name, const QString &context, int maximum, 
+                                           Transaction &t, bool commitOnSuccess);
+
+
+
+    AttemptResult affectedByMessageIds(const QMailMessageIdList &messages, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const;
+
+    AttemptResult affectedByFolderIds(const QMailFolderIdList &folders, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const;
+
+    AttemptResult messagePredecessor(QMailMessageMetaData *metaData, const QStringList &references, const QString &baseSubject, bool sameSubject, QStringList *missingReferences, bool *missingAncestor);
+
+    AttemptResult identifyAncestors(const QMailMessageId &predecessorId, const QMailMessageIdList &childIds, QMailMessageIdList *ancestorIds);
+
+    AttemptResult resolveMissingMessages(const QString &identifier, const QMailMessageId &predecessorId, const QString &baseSubject, quint64 messageId, QMailMessageIdList *updatedMessageIds);
+
+    AttemptResult registerSubject(const QString &baseSubject, quint64 messageId, const QMailMessageId &predecessorId, bool missingAncestor);
+
+    QMailAccount extractAccount(const QMailAccountId& id, const QStringList& list);
+    QMailFolder extractFolder(const QMailFolderId& id, const QStringList& list);
+    void extractMessageMetaData(const QStringList& list, QMailMessageMetaData* metaData);
+    QMailMessageRemovalRecord extractMessageRemovalRecord(const QStringList& r);
+
+    virtual void emitIpcNotification(QMailStoreImplementation::AccountUpdateSignal signal, const QMailAccountIdList &ids);
+    virtual void emitIpcNotification(QMailStoreImplementation::FolderUpdateSignal signal, const QMailFolderIdList &ids);
+    virtual void emitIpcNotification(QMailStoreImplementation::MessageUpdateSignal signal, const QMailMessageIdList &ids);
+
+    static const int headerCacheSize = 100;
+
+    static const int folderCacheSize = 10;
+    static const int accountCacheSize = 10;
+    static const int lookAhead = 5;
+
+
+    static QVariantList messageValues(const QMailMessageKey::Properties& properties, const QMailMessageMetaData& data);
+    static void updateMessageValues(const QMailMessageKey::Properties& properties, const QVariantList& values, const QMap<QString, QString>& customFields, QMailMessageMetaData& metaData);
+
+    static const QString &defaultContentScheme();
+    static const QString &messagesBodyPath();
+    static QString messageFilePath(const QString &fileName);
+    static int pathIdentifier(const QString &filePath);
+
+
+private:
+    template <typename T, typename ID>
+    class Cache
+    {
+    public:
+        Cache(unsigned int size = 10);
+        ~Cache();
+
+        T lookup(const ID& id) const;
+        void insert(const T& item);
+        bool contains(const ID& id) const;
+        void remove(const ID& id);
+        void clear();
+
+    private:
+        QCache<quint64,T> mCache;
+
+    };
+
+
+    
+    mutable QMailMessageIdList lastQueryMessageResult;
+
+    mutable Cache<QMailMessageMetaData, QMailMessageId> headerCache;
+    mutable Cache<QMailFolder, QMailFolderId> folderCache;
+    mutable Cache<QMailAccount, QMailAccountId> accountCache;
+
+
+    mutable QList<const QMailMessageKey*>  requiredTableKeys;
+    mutable QList<const QMailMessageKey*> temporaryTableKeys;
+    QList<const QMailMessageKey*> expiredTableKeys;
+
+    bool inTransaction;
+    mutable QString lastQueryError;
+
+    ProcessMutex *mutex;
+    ProcessReadLock *readLock;
+
+    static ProcessMutex *contentMutex;
+
+     SparqlDatabase sparqlDatabase;
+};
+
+template <typename ValueType>
+ValueType QMailStorePrivate::extractValue(const QVariant &var, const ValueType &defaultValue)
+{
+    if (!qVariantCanConvert<ValueType>(var)) {
+        qWarning() << "QMailStorePrivate::extractValue - Cannot convert variant to:"
+#ifdef QMAILSTORE_USE_RTTI
+                   << typeid(ValueType).name();
+#else
+                   << "requested type";
+#endif
+        return defaultValue;
+    }
+
+    return qVariantValue<ValueType>(var);
+}
+
+
+
+template <typename T, typename ID>
+QMailStorePrivate::Cache<T, ID>::Cache(unsigned int cacheSize)
+    : mCache(cacheSize)
+{
+}
+
+template <typename T, typename ID>
+QMailStorePrivate::Cache<T, ID>::~Cache()
+{
+}
+
+template <typename T, typename ID>
+T QMailStorePrivate::Cache<T, ID>::lookup(const ID& id) const
+{
+    if (id.isValid())
+        if (T* cachedItem = mCache.object(id.toULongLong()))
+            return *cachedItem;
+
+    return T();
+}
+template <typename T, typename ID>
+void QMailStorePrivate::Cache<T, ID>::insert(const T& item)
+{
+    if (item.id().isValid())
+        mCache.insert(item.id().toULongLong(),new T(item));
+}
+
+template <typename T, typename ID>
+bool QMailStorePrivate::Cache<T, ID>::contains(const ID& id) const
+{
+    return mCache.contains(id.toULongLong());
+}
+
+template <typename T, typename ID>
+void QMailStorePrivate::Cache<T, ID>::remove(const ID& id)
+{
+    mCache.remove(id.toULongLong());
+}
+
+template <typename T, typename ID>
+void QMailStorePrivate::Cache<T, ID>::clear()
+{
+    mCache.clear();
+}
+
+#endif
diff --git a/src/libraries/sparql/include/SparqlDatabase b/src/libraries/sparql/include/SparqlDatabase
new file mode 100644
index 0000000..ac92cb7
--- /dev/null
+++ b/src/libraries/sparql/include/SparqlDatabase
@@ -0,0 +1 @@
+#include "sparqldatabase.h"
diff --git a/src/libraries/sparql/include/SparqlQuery b/src/libraries/sparql/include/SparqlQuery
new file mode 100644
index 0000000..bf9b61e
--- /dev/null
+++ b/src/libraries/sparql/include/SparqlQuery
@@ -0,0 +1 @@
+#include "sparqlquery.h"
diff --git a/src/libraries/sparql/include/SparqlResult b/src/libraries/sparql/include/SparqlResult
new file mode 100644
index 0000000..8e66d59
--- /dev/null
+++ b/src/libraries/sparql/include/SparqlResult
@@ -0,0 +1 @@
+#include "sparqlresult.h"
diff --git a/src/libraries/sparql/include/SparqlUri b/src/libraries/sparql/include/SparqlUri
new file mode 100644
index 0000000..52d7ed8
--- /dev/null
+++ b/src/libraries/sparql/include/SparqlUri
@@ -0,0 +1 @@
+#include "sparqluri.h"
diff --git a/src/libraries/sparql/sparql.pro b/src/libraries/sparql/sparql.pro
new file mode 100644
index 0000000..b323449
--- /dev/null
+++ b/src/libraries/sparql/sparql.pro
@@ -0,0 +1,39 @@
+TEMPLATE = lib
+
+TARGET = sparql
+
+INCLUDEPATH += . tracker
+
+QT *= dbus
+
+# Input
+DBUS_HEADERS += tracker/registertypes.h \
+                tracker/resourcesproxy.h
+
+SPARQL_HEADERS += sparqldatabase.h \
+                  sparqlquery.h \
+                  sparqlresult.h \
+                  sparqluri.h
+
+HEADERS += $$DBUS_HEADERS $$SPARQL_HEADERS
+
+SOURCES += \
+    sparqldatabase.cpp \
+    sparqlquery.cpp \
+    sparqlresult.cpp \
+    tracker/registertypes.cpp \
+    tracker/resourcesproxy.cpp \
+    sparqluri.cpp
+
+# Install headers
+sparql_headers.files = $$SPARQL_HEADERS include/*
+sparql_headers.path  = $$QMF_INSTALL_ROOT/include/qmf
+
+dbus_headers.files = $$DBUS_HEADERS
+dbus_headers.path  = $$QMF_INSTALL_ROOT/include/qmf/tracker
+
+INSTALLS += sparql_headers dbus_headers
+
+target.path += $$QMF_INSTALL_ROOT/lib
+
+INSTALLS += target
diff --git a/src/libraries/sparql/sparqldatabase.cpp b/src/libraries/sparql/sparqldatabase.cpp
new file mode 100644
index 0000000..7568a09
--- /dev/null
+++ b/src/libraries/sparql/sparqldatabase.cpp
@@ -0,0 +1,44 @@
+#include "sparqldatabase.h"
+
+#include <QDBusConnection>
+
+// Pointer to the default database
+SparqlDatabase* SparqlDatabase::_defaultDatabase = NULL;
+
+
+SparqlDatabase::SparqlDatabase(const QString& databaseName) :
+        _proxy(databaseName, "/org/freedesktop/Tracker/Resources", QDBusConnection::sessionBus()),
+        _databaseName(databaseName)
+{
+    qDebug() << "SparqlDatabase::SparqlDatabase";
+    if (!_defaultDatabase)
+    {
+        // Register Qt types
+        registerTypes();
+
+        _defaultDatabase = this;
+    }
+}
+
+SparqlDatabase::~SparqlDatabase()
+{
+    if (_defaultDatabase == this)
+        _defaultDatabase = NULL;
+}
+
+SparqlDatabase* SparqlDatabase::defaultDatabase()
+{
+    return _defaultDatabase;
+}
+
+QString SparqlDatabase::databaseName() const
+{
+    return _databaseName;
+}
+
+bool SparqlDatabase::isOpenError() const
+{
+    // Check wheither we are connected
+    bool isConnected = _proxy.connection().isConnected();
+    return !isConnected;
+}
diff --git a/src/libraries/sparql/sparqldatabase.h b/src/libraries/sparql/sparqldatabase.h
new file mode 100644
index 0000000..ab1d6b5
--- /dev/null
+++ b/src/libraries/sparql/sparqldatabase.h
@@ -0,0 +1,59 @@
+#ifndef SPARQLDATABASE_H
+#define SPARQLDATABASE_H
+
+#include "tracker/resourcesproxy.h"
+
+/**
+ * \brief SparqlDatabase represents connection to the SPARQL data base.
+ *
+ * SparqlDatabase represents connection to the SPARQL data base. It relies on the
+ * proxy implementation. It is possible to keep several databases opened at the same
+ * time, but only one of them will be default. All queries without exact database
+ * specification will be performed with default database.
+ *
+ * \see SparqlQuery
+ */
+class SparqlDatabase
+{
+    friend class SparqlQuery;
+
+public:
+    /**
+     * \brief Creates new database
+     *
+     * \param databaseName Name of the data base.
+     */
+    SparqlDatabase(const QString& databaseName = "org.freedesktop.Tracker");
+
+    /**
+     * \brief Default destructor
+     */
+    ~SparqlDatabase();
+
+    /**
+     * \brief Returns default database
+     *
+     * First created database will become default one.
+     *
+     * \return Pointer to the default database.
+     */
+    static SparqlDatabase* defaultDatabase();
+
+    /**
+     * \brief Returns name of the database
+     */
+    QString databaseName() const;
+
+    /**
+     * \brief Returns true wheither there was an error during opening database.
+     */
+    bool isOpenError() const;
+
+private:
+    static SparqlDatabase* _defaultDatabase;
+
+    ResourcesProxy _proxy;
+    QString        _databaseName;
+};
+
+#endif // SPARQLDATABASE_H
diff --git a/src/libraries/sparql/sparqlquery.cpp b/src/libraries/sparql/sparqlquery.cpp
new file mode 100644
index 0000000..8801b79
--- /dev/null
+++ b/src/libraries/sparql/sparqlquery.cpp
@@ -0,0 +1,86 @@
+#include "sparqlquery.h"
+#include "sparqldatabase.h"
+#include "sparqlresult.h"
+
+#include <QDBusPendingReply>
+
+SparqlQuery::SparqlQuery(SparqlQuery::QueryType type, const QString& query,  SparqlDatabase* database) :
+        _type(type),
+        _query(query),
+        _database(database),
+        _result(NULL)
+{
+    if (!_database)
+        _database = SparqlDatabase::defaultDatabase();
+
+    Q_ASSERT(_database);
+}
+
+SparqlQuery::~SparqlQuery()
+{
+}
+
+bool SparqlQuery::prepare(const QString query)
+{
+    _query = query;
+
+    return true;
+}
+
+bool SparqlQuery::exec()
+{
+    Q_ASSERT(_database);
+
+    // Clear last error status and query result
+    _result.clear();
+    _error.clear();
+
+    qDebug() << _query;
+
+    bool err;
+    if (_type == SearchQuery)
+    {
+        QDBusPendingReply<QueryResultType> reply;
+        reply = _database->_proxy.SparqlQuery(_query);
+
+        reply.waitForFinished();
+
+        err = reply.isError();
+        if (!err)
+        {
+            _result = reply.value();
+
+            foreach (const QStringList& row, _result)
+                qDebug() << row.join(", ");
+
+        } else
+            _error = reply.error().message();
+
+    } else {
+        QDBusPendingReply<> reply;
+        reply = _database->_proxy.SparqlUpdate(_query);
+
+        reply.waitForFinished();
+
+        err = reply.isError();
+        if (err)
+            _error = reply.error().message();
+    }
+
+    return !err;
+}
+
+SparqlResult SparqlQuery::result() const
+{
+    return SparqlResult(this);
+}
+
+QString SparqlQuery::error() const
+{
+    return _error;
+}
+
+QString SparqlQuery::query() const
+{
+    return _query;
+}
diff --git a/src/libraries/sparql/sparqlquery.h b/src/libraries/sparql/sparqlquery.h
new file mode 100644
index 0000000..a030cfb
--- /dev/null
+++ b/src/libraries/sparql/sparqlquery.h
@@ -0,0 +1,102 @@
+#ifndef SPARQLQUERY_H
+#define SPARQLQUERY_H
+
+#include <QStringList>
+#include <QVector>
+#include <QString>
+
+class SparqlDatabase;
+class SparqlResult;
+
+/**
+ * \brief SparqlQuery represents SPARQL query.
+ *
+ * There are two different types of queries: search and update queries. Search query uses standard SPARQL syntax
+ * and can only read information from the database. Update queries exploit Advanced SPARQL syntax and allow to
+ * insert, delete and update information in the database.
+ *
+ * Database can be defeined explicitely or default database can be used. In anycase at least one SparqlDatabase
+ * object must be created.
+ *
+ * \see SparqlDatabase
+ */
+class SparqlQuery
+{
+    friend class SparqlResult;
+
+public:
+    /**
+     * \brief Type of the query
+     */
+    enum QueryType
+    {
+        SearchQuery,  ///< Query can use SELECT, CONSTRUCT, DESCRIBE or ASK SPARQL statments
+        UpdateQuery   ///< Query can use INSERT, DELETE and UPDATE advances SPARQL statments
+    };
+
+    /**
+     * \brief Constructs SPARQL query
+     *
+     * \param type Type of the quey.
+     * \param query Query string, It can be defined later with prepare() method.
+     * \param database Pointer to the database. Default database will be used in case of NULL.
+     */
+    SparqlQuery(QueryType type, const QString& query = QString(),  SparqlDatabase* database = NULL);
+
+     /**
+      * \brief Default destructor
+      */
+    ~SparqlQuery();
+
+    /**
+     * \brief Prepare query for execution
+     *
+     * \param SPARQL query to prepare.
+     * \return Status of the application.
+     */
+    bool prepare(const QString query);
+
+    /**
+     * \brief Execute prepared query
+     *
+     * Before executing a query it has to be prepared using prepare() method.
+     * In case of any errors exec() will return false. More detailes information
+     * about source of error can be retrieved using error() method.
+     *
+     * Result of query execution can be retrieved using result() method.
+     * Retult is available only for Search queries.
+     *
+     * \return true in case of success and false in case of failure.
+     */
+    bool exec();
+
+    /**
+     * \brief Returns result of the operation
+     *
+     * \return result can be NULL in case of error or Update query was executed.
+     */
+    SparqlResult result() const;
+
+    /**
+     * \brief Returns textual representation of the error.
+     *
+     * \return Literal error description.
+     */
+    QString error() const;
+
+    /**
+     * \brief Returns prepared SPARQL query to execute.
+     */
+    QString query() const;
+
+private:
+    QueryType       _type;
+    QString         _query;
+    SparqlDatabase* _database;
+    QString         _error;
+
+    typedef QVector<QStringList> QueryResultType;
+    QueryResultType _result;
+};
+
+#endif // SPARQLQUERY_H
diff --git a/src/libraries/sparql/sparqlresult.cpp b/src/libraries/sparql/sparqlresult.cpp
new file mode 100644
index 0000000..de7f2a0
--- /dev/null
+++ b/src/libraries/sparql/sparqlresult.cpp
@@ -0,0 +1,31 @@
+#include "sparqlresult.h"
+#include "sparqlquery.h"
+
+SparqlResult::SparqlResult(const SparqlQuery* query) :
+        _query(query),
+        _current(0)
+{
+}
+
+const QStringList& SparqlResult::fetchRow()
+{
+    Q_ASSERT(_query);
+
+    return _query->_result.at(_current++);
+}
+
+bool SparqlResult::begin() const
+{
+    return (_current == 0);
+}
+
+bool SparqlResult::end() const
+{
+    Q_ASSERT(_query);
+    return (_query->_result.count() == _current);
+}
+
+void SparqlResult::reset()
+{
+    _current = 0;
+}
diff --git a/src/libraries/sparql/sparqlresult.h b/src/libraries/sparql/sparqlresult.h
new file mode 100644
index 0000000..2c9be91
--- /dev/null
+++ b/src/libraries/sparql/sparqlresult.h
@@ -0,0 +1,56 @@
+#ifndef SPARQLRESULT_H
+#define SPARQLRESULT_H
+
+#include <QVector>
+#include <QStringList>
+
+class SparqlQuery;
+
+/**
+ * \brief SparqlResult provides convenient way to fetch data from the executed query.
+ *
+ * To fetch data from already executed query you have to get instance of that class
+ * with SparqlQuery::result() method and call fetchRow() method till you reach the end().
+ *
+ * It is possible to enumerate result of the query using different instances of the
+ * SparqlResult class at the same time. But you have to know that data itself belongs
+ * to the query and you should not access any methods of this class in case of SparqlQuery
+ * was destroyed.
+ *
+ * \see SparqlQuery
+ */
+class SparqlResult
+{
+    friend class SparqlQuery;
+
+public:
+    /**
+     * \brief Fetch the row with results of the query
+     *
+     * \return List of values of the row.
+     */
+    const QStringList& fetchRow();
+
+    /**
+     * \brief Does the result point to the beginig of data set
+     */
+    bool begin() const;
+
+    /**
+     * \brief Does the result point to the end of the data set
+     */
+    bool end() const;
+
+    /**
+     * \brief Reset result and make it points to the begining again
+     */
+    void reset();
+
+private:
+    SparqlResult(const SparqlQuery* query);
+    const SparqlQuery* _query;
+
+    int _current;
+};
+
+#endif // SPARQLRESULT_H
diff --git a/src/libraries/sparql/sparqluri.cpp b/src/libraries/sparql/sparqluri.cpp
new file mode 100644
index 0000000..6963010
--- /dev/null
+++ b/src/libraries/sparql/sparqluri.cpp
@@ -0,0 +1,88 @@
+#include "sparqluri.h"
+#include <QUuid>
+
+SparqlUri::SparqlUri(const QString& base) :
+        _id(generate())
+{
+    bool ret = setBase(base);
+    Q_ASSERT(ret);
+}
+
+SparqlUri::SparqlUri(const QString& base, quint64 id) :
+        _id(id)
+{
+    bool ret = setBase(base);
+    Q_ASSERT(ret);
+}
+
+bool SparqlUri::setBase(const QString& base)
+{
+    _base = base;
+    return true;
+}
+
+QString SparqlUri::base() const
+{
+    return _base;
+}
+
+QString SparqlUri::uri() const
+{
+    return QString("<%1>").arg(base() + QString::number(_id));
+}
+
+void SparqlUri::setId(quint64 id)
+{
+    _id = id;
+}
+
+quint64 SparqlUri::id() const
+{
+    return _id;
+}
+
+quint64 SparqlUri::generate()
+{
+    /*
+     * BUG!BUG!BUG!
+     *
+     * We can't just generate UUID and do not make
+     * sure that it is unique.
+     *
+     * THIS CODE HAS TO BE REWRITTEN.
+     */
+    QUuid uuid = QUuid::createUuid();
+
+    quint64 data1 = uuid.data1;
+    quint64 data2 = uuid.data2;
+    quint64 data3 = uuid.data3;
+    quint64 data4 = *(quint64*)uuid.data4;
+
+    quint64 id = (data1 << 32) ^ (data2 << 16) ^ data3;
+    id |= data4;
+
+    return id;
+}
+
+SparqlUri::operator QString () const
+{
+    return uri();
+}
+
+SparqlUri::operator quint64 () const
+{
+    return id();
+}
+
+QString SparqlUri::operator++ ()
+{
+    _id = generate();
+    return uri();
+}
+
+QString SparqlUri::operator++ (int)
+{
+    QString result(uri());
+    _id = generate();
+    return result;
+}
diff --git a/src/libraries/sparql/sparqluri.h b/src/libraries/sparql/sparqluri.h
new file mode 100644
index 0000000..44aeab1
--- /dev/null
+++ b/src/libraries/sparql/sparqluri.h
@@ -0,0 +1,102 @@
+#ifndef SPARQLURI_H
+#define SPARQLURI_H
+
+#include "sparqldatabase.h"
+
+/**
+ * \brief SparqlUri provides automatic URI generation.
+ *
+ * URI is unique identifier in the SPARQL language, it is required
+ * to be able to generate unique identifiers fast and easy. SparqlUri class
+ * provides convenient way to generate such URI.
+ *
+ * Every URI has base part and autogenerated part. Base part can be defined by user.
+ * Autogenerated part will be changed with every increment operation.
+ *
+ * Autogenerate URI will look like http://base.part/is/fixed#nnnnnn, where nnnnnn is 64bit
+ * integer, No any prediction is made about order or number of digits in the nnnnnn.
+ *
+ * \see SparqlQuery
+ */
+class SparqlUri
+{
+public:
+    /**
+     * \brief Constructor of the URI
+     *
+     * Unique id will be autogenerated.
+     *
+     * \param base Fixed part of the URI.
+     */
+    SparqlUri(const QString& base);
+
+    /**
+     * \brief Constructor of the URI generator
+     *
+     * Value of id is passed as a parameter
+     *
+     * \param base Fixed part of the URI.
+     * \param id Pre-defined id is used in this case.
+     */
+    SparqlUri(const QString& base, quint64 id);
+
+    /**
+     * \brief Set new fixed base of the URI
+     */
+    bool setBase(const QString& base);
+
+    /**
+     * \brief Get fixed base part of the URI
+     */
+    QString base() const;
+
+    /**
+     * \brief Get current URI as a string
+     */
+    void setId(quint64 id);
+
+    /**
+     * \brief Set current nnnnnn part as 64-bit integer
+     */
+    quint64 id() const;
+
+    /**
+     * \brief Get current nnnnnn part as 64-bit integer
+     */
+    QString uri() const;
+
+    /**
+     * \brief Generates new nnnnnn.
+     *
+     * Current URI is not updated. To update current URI as well operator++ should be used.
+     *
+     * \return new nnnnnn part of the URI as 64-bit unsigned integer.
+     */
+    quint64 generate();
+
+    /**
+     * \brief Convenience operator returns URI
+     */
+    operator QString () const;
+
+    /**
+     * \brief Convenience operator returns nnnnnn part of the URI
+     */
+    operator quint64 () const;
+
+    /**
+     * \brief Generates new URI and returns new value
+     */
+    QString operator++ ();
+
+    /**
+     * \brief Generates new URI and returns old value
+     */
+    QString operator++ (int);
+
+private:
+    QString _base;
+    quint64 _id;
+};
+
+#endif // #ifndef SPARQLURI_H
diff --git a/src/libraries/sparql/tracker/README b/src/libraries/sparql/tracker/README
new file mode 100644
index 0000000..9b8b88a
--- /dev/null
+++ b/src/libraries/sparql/tracker/README
@@ -0,0 +1,20 @@
+
+HOWTO Generate proxy code from DBUSXML interface definition
+
+ Obtain latest version of the .xml files from the tracker repository
+   git://git.codethink.co.uk/git/tracker
+   
+   Backup existing .xml files and code of the DBUS proxy classes.
+   
+ Update XML interface description with correct annotations for all Qt types:
+  * For every type="aas" direction="out", add following annotation:
+    <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVector&lt;QStringList&gt;"/>
+
+  * For every type="a{sv}" direction="out", add following annotation:
+    <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVariantList"/>
+
+  * For every signal with type="aas", add following annotation:
+    <annotation name="com.trolltech.QtDBus.QtTypeName.In0" value="QVector&lt;QStringList&gt;"/>
+
+ Run genproxy.sh script
+ 
diff --git a/src/libraries/sparql/tracker/genproxy.sh b/src/libraries/sparql/tracker/genproxy.sh
new file mode 100755
index 0000000..73a960c
--- /dev/null
+++ b/src/libraries/sparql/tracker/genproxy.sh
@@ -0,0 +1,2 @@
+#!/bin/bash
+qdbusxml2cpp -c ResourcesProxy -p resourcesproxy -i registertypes.h tracker-resources.xml org.freedesktop.Tracker.Resources
diff --git a/src/libraries/sparql/tracker/registertypes.cpp b/src/libraries/sparql/tracker/registertypes.cpp
new file mode 100644
index 0000000..e8ce4ed
--- /dev/null
+++ b/src/libraries/sparql/tracker/registertypes.cpp
@@ -0,0 +1,10 @@
+#include <QDBusMetaType>
+#include <QtDebug>
+
+#include "registertypes.h"
+
+void registerTypes()
+{
+    qRegisterMetaType<QVector<QStringList> >();
+    qDBusRegisterMetaType<QVector<QStringList> >();
+}
diff --git a/src/libraries/sparql/tracker/registertypes.h b/src/libraries/sparql/tracker/registertypes.h
new file mode 100644
index 0000000..5c87c3f
--- /dev/null
+++ b/src/libraries/sparql/tracker/registertypes.h
@@ -0,0 +1,12 @@
+#ifndef __REGISTERTYPES_H__
+#define __REGISTERTYPES_H__
+
+#include <QMetaType>
+#include <QVector>
+#include <QStringList>
+
+Q_DECLARE_METATYPE(QVector<QStringList>)
+
+void registerTypes();
+
+#endif // #ifndef __REGISTERTYPES_H__
diff --git a/src/libraries/sparql/tracker/resourcesproxy.cpp b/src/libraries/sparql/tracker/resourcesproxy.cpp
new file mode 100644
index 0000000..96f5d46
--- /dev/null
+++ b/src/libraries/sparql/tracker/resourcesproxy.cpp
@@ -0,0 +1,26 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -c ResourcesProxy -p resourcesproxy -i registertypes.h tracker-resources.xml org.freedesktop.Tracker.Resources
+ *
+ * qdbusxml2cpp is Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "resourcesproxy.h"
+
+/*
+ * Implementation of interface class ResourcesProxy
+ */
+
+ResourcesProxy::ResourcesProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+ResourcesProxy::~ResourcesProxy()
+{
+}
+
diff --git a/src/libraries/sparql/tracker/resourcesproxy.h b/src/libraries/sparql/tracker/resourcesproxy.h
new file mode 100644
index 0000000..eafaa2a
--- /dev/null
+++ b/src/libraries/sparql/tracker/resourcesproxy.h
@@ -0,0 +1,85 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -c ResourcesProxy -p resourcesproxy -i registertypes.h tracker-resources.xml org.freedesktop.Tracker.Resources
+ *
+ * qdbusxml2cpp is Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef RESOURCESPROXY_H_1241509742
+#define RESOURCESPROXY_H_1241509742
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+#include "registertypes.h"
+
+/*
+ * Proxy class for interface org.freedesktop.Tracker.Resources
+ */
+class ResourcesProxy: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.Tracker.Resources"; }
+
+public:
+    ResourcesProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~ResourcesProxy();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> Delete(const QString &subject, const QString &predicate, const QString &object)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(subject) << qVariantFromValue(predicate) << qVariantFromValue(object);
+        return asyncCallWithArgumentList(QLatin1String("Delete"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Insert(const QString &subject, const QString &predicate, const QString &object)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(subject) << qVariantFromValue(predicate) << qVariantFromValue(object);
+        return asyncCallWithArgumentList(QLatin1String("Insert"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Load(const QString &uri)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(uri);
+        return asyncCallWithArgumentList(QLatin1String("Load"), argumentList);
+    }
+
+    inline QDBusPendingReply<QVector<QStringList> > SparqlQuery(const QString &query)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(query);
+        return asyncCallWithArgumentList(QLatin1String("SparqlQuery"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SparqlUpdate(const QString &query)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(query);
+        return asyncCallWithArgumentList(QLatin1String("SparqlUpdate"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+namespace org {
+  namespace freedesktop {
+    namespace Tracker {
+      typedef ::ResourcesProxy Resources;
+    }
+  }
+}
+#endif
diff --git a/src/libraries/sparql/tracker/tracker-resources.xml b/src/libraries/sparql/tracker/tracker-resources.xml
new file mode 100644
index 0000000..233fc64
--- /dev/null
+++ b/src/libraries/sparql/tracker/tracker-resources.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<node name="/org/freedesktop/Tracker">
+  <interface name="org.freedesktop.Tracker.Resources">
+
+    <!-- Insert single statement -->
+    <method name="Insert">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/> 
+      <arg type="s" name="subject" direction="in" />
+      <arg type="s" name="predicate" direction="in" />
+      <arg type="s" name="object" direction="in" />
+    </method>
+
+    <!-- Delete single statement -->
+    <method name="Delete">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/> 
+      <arg type="s" name="subject" direction="in" />
+      <arg type="s" name="predicate" direction="in" />
+      <arg type="s" name="object" direction="in" />
+    </method>
+
+    <!-- Load statements from Turtle file -->
+    <method name="Load">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/> 
+      <arg type="s" name="uri" direction="in" />
+    </method>
+
+    <!-- SPARQL Query without updates -->
+    <method name="SparqlQuery">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/>
+      <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" 
+		  value="QVector&lt;QStringList&gt;"/>
+      <arg type="s" name="query" direction="in" />
+      <arg type="aas" name="result" direction="out" />
+    </method>
+
+    <!-- SPARQL Update extensions, allows bulk insert and delete -->
+    <method name="SparqlUpdate">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/>
+      <arg type="s" name="query" direction="in" />
+    </method>
+
+  </interface>
+</node>
diff --git a/tests/tst_qmailstore/tst_qmailstore.cpp b/tests/tst_qmailstore/tst_qmailstore.cpp
index b806edf..19a6472 100644
--- a/tests/tst_qmailstore/tst_qmailstore.cpp
+++ b/tests/tst_qmailstore/tst_qmailstore.cpp
@@ -491,6 +491,79 @@ void tst_QMailStore::addMessages()
     QCOMPARE(QMailStore::instance()->queryMessages(key, sort, 10, 0), messageIds);
 }
 
+void tst_QMailStore::addMessages()
+{
+    QMailAccount account;
+    account.setName("Account");
+
+    QCOMPARE(QMailStore::instance()->countAccounts(), 0);
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+    QVERIFY(!account.id().isValid());
+    QVERIFY(QMailStore::instance()->addAccount(&account, 0));
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+    QVERIFY(account.id().isValid());
+    QCOMPARE(QMailStore::instance()->countAccounts(), 1);
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+
+    QMailFolder folder;
+    folder.setPath("Folder");
+    folder.setParentAccountId(account.id());
+
+    QCOMPARE(QMailStore::instance()->countFolders(), 0);
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+    QVERIFY(!folder.id().isValid());
+    QVERIFY(QMailStore::instance()->addFolder(&folder));
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+    QVERIFY(folder.id().isValid());
+    QCOMPARE(QMailStore::instance()->countFolders(), 1);
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+
+    QList<QMailMessage> messages;
+    QList<QMailMessage*> messageAddresses;
+    for (int i = 1; i <= 10; ++i) {
+        QMailMessage message;
+        message.setParentAccountId(account.id());
+        message.setParentFolderId(folder.id());
+        message.setMessageType(QMailMessage::Sms);
+        message.setSubject(QString("Message %1").arg(i));
+        message.setBody(QMailMessageBody::fromData(QString("Hi #%1").arg(i), QMailMessageContentType("text/plain"), QMailMessageBody::SevenBit));
+
+        messages.append(message);
+        messageAddresses.append(&messages.last());
+    }
+
+    // Verify that addition is successful
+    QCOMPARE(QMailStore::instance()->countMessages(), 0);
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+    QVERIFY(!messages.first().id().isValid());
+    QVERIFY(!messages.last().id().isValid());
+    QVERIFY(QMailStore::instance()->addMessages(messageAddresses));
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+    QVERIFY(messages.first().id().isValid());
+    QVERIFY(messages.last().id().isValid());
+    QCOMPARE(QMailStore::instance()->countMessages(), 10);
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+
+    // Verify that retrieval yields matching result
+    for (int i = 1; i <= 10; ++i) {
+        QMailMessage message(messages.at(i - 1).id());
+        QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
+        QCOMPARE(message.subject(), QString("Message %1").arg(i));
+        QCOMPARE(message.body().data(), QString("Hi #%1").arg(i));
+    }
+
+    // Test basic limit/offset
+    QMailMessageKey key;
+    QMailMessageSortKey sort;
+    QMailMessageIdList messageIds(QMailStore::instance()->queryMessages(key, sort));
+    QCOMPARE(QMailStore::instance()->queryMessages(key, sort, 4, 0), messageIds.mid(0, 4));
+    QCOMPARE(QMailStore::instance()->queryMessages(key, sort, 4, 3), messageIds.mid(3, 4));
+    QCOMPARE(QMailStore::instance()->queryMessages(key, sort, 4, 6), messageIds.mid(6, 4));
+    QCOMPARE(QMailStore::instance()->queryMessages(key, sort, 9, 0), messageIds.mid(0, 9));
+    QCOMPARE(QMailStore::instance()->queryMessages(key, sort, 9, 1), messageIds.mid(1, 9));
+    QCOMPARE(QMailStore::instance()->queryMessages(key, sort, 10, 0), messageIds);
+}
+
 void tst_QMailStore::updateAccount()
 {
     QMailFolder folder("new folder 1");
