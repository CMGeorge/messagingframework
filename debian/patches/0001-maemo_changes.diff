diff --git a/src/libraries/messageserver/messageserver.pro b/src/libraries/messageserver/messageserver.pro
index fc7540f..38b7e4f 100644
--- a/src/libraries/messageserver/messageserver.pro
+++ b/src/libraries/messageserver/messageserver.pro
@@ -1,12 +1,10 @@
 TEMPLATE = lib 
 
 TARGET = messageserver
-target.path += $$QMF_INSTALL_ROOT/lib
-INSTALLS += target
 
 QT *= network
 
-CONFIG += warn_on
+CONFIG += warn_on create_pc create_prl
 
 DEPENDPATH += .
 
@@ -28,5 +26,19 @@ SOURCES += qmailauthenticator.cpp \
            qmailstoreaccountfilter.cpp \
            qmailtransport.cpp
 
+target.path += $$QMF_INSTALL_ROOT/lib
+INSTALLS += target
+
+# Install headers
+headers.files = $$HEADERS include/*
+headers.path  = $$QMF_INSTALL_ROOT/include/qmf
+
+INSTALLS += headers 
+
+# Install pkgconfig file
+QMAKE_PKGCONFIG_LIBDIR  = $$target.path
+QMAKE_PKGCONFIG_INCDIR  = $$headers.path
+QMAKE_PKGCONFIG_DESTDIR = pkgconfig
+
 include(../../common.pri)
 
diff --git a/src/libraries/qmfutil/qmfutil.pro b/src/libraries/qmfutil/qmfutil.pro
index a4ede0a..fc0272b 100644
--- a/src/libraries/qmfutil/qmfutil.pro
+++ b/src/libraries/qmfutil/qmfutil.pro
@@ -1,10 +1,8 @@
 TEMPLATE = lib 
 
 TARGET = qmfutil 
-target.path += $$QMF_INSTALL_ROOT/lib
-INSTALLS += target
 
-CONFIG += warn_on
+CONFIG += warn_on create_pc create_prl
 
 DEPENDPATH += .
 
@@ -32,5 +30,19 @@ TRANSLATIONS += libqmfutil-ar.ts \
                 libqmfutil-zh_CN.ts \
                 libqmfutil-zh_TW.ts
 
+target.path += $$QMF_INSTALL_ROOT/lib
+INSTALLS += target
+
+# Install headers
+headers.files = $$HEADERS include/*
+headers.path  = $$QMF_INSTALL_ROOT/include/qmf
+
+INSTALLS += headers 
+
+# Install pkgconfig file
+QMAKE_PKGCONFIG_LIBDIR  = $$target.path
+QMAKE_PKGCONFIG_INCDIR  = $$headers.path
+QMAKE_PKGCONFIG_DESTDIR = pkgconfig
+
 include(../../common.pri)
 
diff --git a/src/libraries/qtopiamail/qtopiamail.pro b/src/libraries/qtopiamail/qtopiamail.pro
index 658dae6..d06f32a 100644
--- a/src/libraries/qtopiamail/qtopiamail.pro
+++ b/src/libraries/qtopiamail/qtopiamail.pro
@@ -1,17 +1,35 @@
 TEMPLATE = lib 
 
 TARGET = qtopiamail
-target.path += $$QMF_INSTALL_ROOT/lib 
-INSTALLS += target
 
 DEFINES += QT_BUILD_QCOP_LIB
 
 QT *= sql network
 
-CONFIG += warn_on
+CONFIG += warn_on create_pc create_prl
 
 INCLUDEPATH += support
 
+sparql {
+
+DEFINES += SPARQL_STORE
+
+HEADERS += qmailstore_sparql.h
+
+SOURCES += qmailstore_sparql.cpp
+
+INCLUDEPATH += ../sparql ../sparql/tracker
+
+LIBS += -L../sparql -lsparql
+
+} else {
+
+HEADERS += qmailstore_p.h
+
+SOURCES += qmailstore_p.cpp
+
+}
+
 HEADERS += bind_p.h \
            longstream_p.h \
            longstring_p.h \
@@ -46,12 +64,11 @@ HEADERS += bind_p.h \
            qmailmessagesortkey_p.h \
            qmailserviceaction.h \
            qmailstore.h \
-           qmailstore_p.h \
+           semaphore_p.h \
            qmailstoreimplementation_p.h \
            qmailtimestamp.h \
            qprivateimplementation.h \
            qprivateimplementationdef.h \
-           semaphore_p.h \
            support/qmailglobal.h \
            support/qmaillog.h \
            support/qmailnamespace.h \
@@ -62,7 +79,8 @@ HEADERS += bind_p.h \
            support/qcopchannelmonitor.h \
            support/qcopserver.h \
            support/qmailpluginmanager.h \
-           support/qringbuffer_p.h
+           support/qringbuffer_p.h \
+           support/qmailipc.h

 SOURCES += longstream.cpp \
            longstring.cpp \
@@ -90,7 +108,6 @@ SOURCES += longstream.cpp \
            qmailmessagesortkey.cpp \
            qmailserviceaction.cpp \
            qmailstore.cpp \
-           qmailstore_p.cpp \
            qmailstoreimplementation_p.cpp \
            qmailtimestamp.cpp \
            qprivateimplementation.cpp \
@@ -121,5 +139,19 @@ TRANSLATIONS += libqtopiamail-ar.ts \
                 libqtopiamail-zh_CN.ts \
                 libqtopiamail-zh_TW.ts
 
+target.path += $$QMF_INSTALL_ROOT/lib 
+INSTALLS += target
+
+# Install headers
+headers.files = $$HEADERS include/*
+headers.path  = $$QMF_INSTALL_ROOT/include/qmf
+
+INSTALLS += headers 
+
+# Install pkgconfig file
+QMAKE_PKGCONFIG_LIBDIR  = $$target.path
+QMAKE_PKGCONFIG_INCDIR  = $$headers.path
+QMAKE_PKGCONFIG_DESTDIR = pkgconfig
+
 include(../../common.pri)
 
diff --git a/src/libraries/qtopiamail/support/qmaillog.h b/src/libraries/qtopiamail/support/qmaillog.h
index 00bbe80..379ba8b 100644
--- a/src/libraries/qtopiamail/support/qmaillog.h
+++ b/src/libraries/qtopiamail/support/qmaillog.h
@@ -117,6 +117,8 @@ public:
 
 #define qMailLog(dbgcat) if(!dbgcat##_QLog::enabled()); else dbgcat##_QLog::log(#dbgcat)
 
+#define QMF_ENABLE_LOGGING
+
 #ifdef QMF_ENABLE_LOGGING
 QLOG_ENABLE() //uncategorized logging
 QLOG_ENABLE(Messaging)
diff --git a/src/tools/messageserver/messageserver.pro b/src/tools/messageserver/messageserver.pro
index 700ccac..288a209 100644
--- a/src/tools/messageserver/messageserver.pro
+++ b/src/tools/messageserver/messageserver.pro
@@ -1,8 +1,6 @@
 TEMPLATE = app
 
 TARGET = messageserver
-target.path += $$QMF_INSTALL_ROOT/bin
-INSTALLS += target
 
 DEPENDPATH += . 
 
@@ -39,5 +37,18 @@ TRANSLATIONS += messageserver-ar.ts \
                 messageserver-zh_CN.ts \
                 messageserver-zh_TW.ts
 
+target.path += $$QMF_INSTALL_ROOT/bin
+
+initstart.files = etc/messageserver
+initstart.path  = /etc/init.d
+
+xsessionpost.files = etc/Xsession/51messageserver
+xsessionpost.path  = /etc/X11/Xsession.post
+
+xsessionactdead.files = etc/Xsession/51messageserver
+xsessionactdead.path  = /etc/X11/Xsession.actdead
+
+INSTALLS += target initstart xsessionpost xsessionactdead
+
 include(../../common.pri)
 
diff --git a/qmf.pro b/qmf.pro
index cd9a51e..f7e97ed 100644
--- a/qmf.pro
+++ b/qmf.pro
@@ -1,10 +1,13 @@
 TEMPLATE = subdirs
-SUBDIRS = src/libraries/qtopiamail \
+SUBDIRS = src/libraries/sparql \
+          src/libraries/qtopiamail \
           src/libraries/messageserver \
           src/libraries/qmfutil \
           src/plugins/messageservices/imap \
           src/plugins/messageservices/pop \
           src/plugins/messageservices/smtp \
+          src/plugins/messageservices/dummysink \
+          src/plugins/messageservices/dummysource \
           src/plugins/messageservices/qtopiamailfile \
           src/plugins/contentmanagers/qtopiamailfile \
           src/plugins/viewers/generic \

diff --git a/src/applications/qtmail/qtmail.pro b/src/applications/qtmail/qtmail.pro
index 5c83e96..0d4729d 100644
--- a/src/applications/qtmail/qtmail.pro
+++ b/src/applications/qtmail/qtmail.pro
@@ -11,7 +11,18 @@ INCLUDEPATH += . ../../libraries/qtopiamail \
                  ../../libraries/qmfutil
 
 LIBS += -L../../libraries/qtopiamail -lqtopiamail \
-        -L../../libraries/qmfutil -lqmfutil
+        -L../../libraries/qmfutil    -lqmfutil
+
+QMAKE_LFLAGS += -Wl,-rpath,../../libraries/qtopiamail \
+                -Wl,-rpath,../../libraries/qmfutil
+
+sparql {
+
+LIBS += -L../../libraries/sparql -lsparql
+
+QMAKE_LFLAGS += -Wl,-rpath,../../libraries/sparql
+
+}
 
 HEADERS += foldermodel.h \
            folderdelegate.h \
diff --git a/src/libraries/messageserver/include/QMailAuthenticator b/src/libraries/messageserver/include/QMailAuthenticator
new file mode 100644
index 0000000..a1c5ba5
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailAuthenticator
@@ -0,0 +1 @@
+#include "qmailauthenticator.h"
diff --git a/src/libraries/messageserver/include/QMailMessageClassifier b/src/libraries/messageserver/include/QMailMessageClassifier
new file mode 100644
index 0000000..285ed1a
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageClassifier
@@ -0,0 +1 @@
+#include "qmailmessageclassifier.h"
diff --git a/src/libraries/messageserver/include/QMailMessageService b/src/libraries/messageserver/include/QMailMessageService
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageService
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageServiceConfigurator b/src/libraries/messageserver/include/QMailMessageServiceConfigurator
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageServiceConfigurator
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageServiceEditor b/src/libraries/messageserver/include/QMailMessageServiceEditor
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageServiceEditor
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageServiceFactory b/src/libraries/messageserver/include/QMailMessageServiceFactory
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageServiceFactory
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageServicePlugin b/src/libraries/messageserver/include/QMailMessageServicePlugin
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageServicePlugin
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageSink b/src/libraries/messageserver/include/QMailMessageSink
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageSink
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailMessageSource b/src/libraries/messageserver/include/QMailMessageSource
new file mode 100644
index 0000000..8df572e
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailMessageSource
@@ -0,0 +1 @@
+#include "qmailmessageservice.h"
diff --git a/src/libraries/messageserver/include/QMailServiceConfiguration b/src/libraries/messageserver/include/QMailServiceConfiguration
new file mode 100644
index 0000000..c6f8a6c
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailServiceConfiguration
@@ -0,0 +1 @@
+#include "qmailserviceconfiguration.h"
diff --git a/src/libraries/messageserver/include/QMailTransport b/src/libraries/messageserver/include/QMailTransport
new file mode 100644
index 0000000..1b390c9
--- /dev/null
+++ b/src/libraries/messageserver/include/QMailTransport
@@ -0,0 +1 @@
+#include "qmailtransport.h"
* Unmerged path src/libraries/messageserver/messageserver.pro
diff --git a/src/libraries/qmfutil/include/QMailComposerFactory b/src/libraries/qmfutil/include/QMailComposerFactory
new file mode 100644
index 0000000..23b68f1
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailComposerFactory
@@ -0,0 +1 @@
+#include "qmailcomposer.h"
\ No newline at end of file
diff --git a/src/libraries/qmfutil/include/QMailComposerInterface b/src/libraries/qmfutil/include/QMailComposerInterface
new file mode 100644
index 0000000..23b68f1
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailComposerInterface
@@ -0,0 +1 @@
+#include "qmailcomposer.h"
\ No newline at end of file
diff --git a/src/libraries/qmfutil/include/QMailMessageDelegate b/src/libraries/qmfutil/include/QMailMessageDelegate
new file mode 100644
index 0000000..6d19eb2
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailMessageDelegate
@@ -0,0 +1 @@
+#include "qmailmessagedelegate.h"
\ No newline at end of file
diff --git a/src/libraries/qmfutil/include/QMailViewerFactory b/src/libraries/qmfutil/include/QMailViewerFactory
new file mode 100644
index 0000000..81a8bde
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailViewerFactory
@@ -0,0 +1 @@
+#include "qmailviewer.h"
diff --git a/src/libraries/qmfutil/include/QMailViewerInterface b/src/libraries/qmfutil/include/QMailViewerInterface
new file mode 100644
index 0000000..dc9d052
--- /dev/null
+++ b/src/libraries/qmfutil/include/QMailViewerInterface
@@ -0,0 +1 @@
+#include "qmailviewer.h"
\ No newline at end of file
diff --git a/src/libraries/qmfutil/include/QtopiaHomeMailMessageDelegate b/src/libraries/qmfutil/include/QtopiaHomeMailMessageDelegate
new file mode 100644
index 0000000..6d19eb2
--- /dev/null
+++ b/src/libraries/qmfutil/include/QtopiaHomeMailMessageDelegate
@@ -0,0 +1 @@
+#include "qmailmessagedelegate.h"
\ No newline at end of file
* Unmerged path src/libraries/qmfutil/qmfutil.pro
diff --git a/src/libraries/qtopiamail/include/MailId b/src/libraries/qtopiamail/include/MailId
new file mode 100644
index 0000000..e2db656
--- /dev/null
+++ b/src/libraries/qtopiamail/include/MailId
@@ -0,0 +1 @@
+#include "qmailid.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccount b/src/libraries/qtopiamail/include/QMailAccount
new file mode 100644
index 0000000..e403614
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccount
@@ -0,0 +1 @@
+#include "qmailaccount.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountConfiguration b/src/libraries/qtopiamail/include/QMailAccountConfiguration
new file mode 100644
index 0000000..0631517
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountConfiguration
@@ -0,0 +1 @@
+#include "qmailaccountconfiguration.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountId b/src/libraries/qtopiamail/include/QMailAccountId
new file mode 100644
index 0000000..e2db656
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountId
@@ -0,0 +1 @@
+#include "qmailid.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountKey b/src/libraries/qtopiamail/include/QMailAccountKey
new file mode 100644
index 0000000..1c39992
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountKey
@@ -0,0 +1 @@
+#include "qmailaccountkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountListModel b/src/libraries/qtopiamail/include/QMailAccountListModel
new file mode 100644
index 0000000..a9d6feb
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountListModel
@@ -0,0 +1 @@
+#include "qmailaccountlistmodel.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountMessageSet b/src/libraries/qtopiamail/include/QMailAccountMessageSet
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountMessageSet
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailAccountSortKey b/src/libraries/qtopiamail/include/QMailAccountSortKey
new file mode 100644
index 0000000..87a88f6
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAccountSortKey
@@ -0,0 +1 @@
+#include "qmailaccountsortkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailAddress b/src/libraries/qtopiamail/include/QMailAddress
new file mode 100644
index 0000000..80d6726
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailAddress
@@ -0,0 +1 @@
+#include "qmailaddress.h"
diff --git a/src/libraries/qtopiamail/include/QMailBase64Codec b/src/libraries/qtopiamail/include/QMailBase64Codec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailBase64Codec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailCodec b/src/libraries/qtopiamail/include/QMailCodec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailCodec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailContentManager b/src/libraries/qtopiamail/include/QMailContentManager
new file mode 100644
index 0000000..7c05cb5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailContentManager
@@ -0,0 +1 @@
+#include "qmailcontentmanager.h"
diff --git a/src/libraries/qtopiamail/include/QMailContentManagerFactory b/src/libraries/qtopiamail/include/QMailContentManagerFactory
new file mode 100644
index 0000000..7c05cb5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailContentManagerFactory
@@ -0,0 +1 @@
+#include "qmailcontentmanager.h"
diff --git a/src/libraries/qtopiamail/include/QMailContentManagerPlugin b/src/libraries/qtopiamail/include/QMailContentManagerPlugin
new file mode 100644
index 0000000..7c05cb5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailContentManagerPlugin
@@ -0,0 +1 @@
+#include "qmailcontentmanager.h"
diff --git a/src/libraries/qtopiamail/include/QMailFilterMessageSet b/src/libraries/qtopiamail/include/QMailFilterMessageSet
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFilterMessageSet
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolder b/src/libraries/qtopiamail/include/QMailFolder
new file mode 100644
index 0000000..cae2455
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolder
@@ -0,0 +1 @@
+#include "qmailfolder.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolderId b/src/libraries/qtopiamail/include/QMailFolderId
new file mode 100644
index 0000000..e2db656
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolderId
@@ -0,0 +1 @@
+#include "qmailid.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolderKey b/src/libraries/qtopiamail/include/QMailFolderKey
new file mode 100644
index 0000000..5effe63
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolderKey
@@ -0,0 +1 @@
+#include "qmailfolderkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolderMessageSet b/src/libraries/qtopiamail/include/QMailFolderMessageSet
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolderMessageSet
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailFolderSortKey b/src/libraries/qtopiamail/include/QMailFolderSortKey
new file mode 100644
index 0000000..231dba5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailFolderSortKey
@@ -0,0 +1 @@
+#include "qmailfoldersortkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailLineEndingCodec b/src/libraries/qtopiamail/include/QMailLineEndingCodec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailLineEndingCodec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessage b/src/libraries/qtopiamail/include/QMailMessage
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessage
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageBody b/src/libraries/qtopiamail/include/QMailMessageBody
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageBody
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageContentDisposition b/src/libraries/qtopiamail/include/QMailMessageContentDisposition
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageContentDisposition
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageContentType b/src/libraries/qtopiamail/include/QMailMessageContentType
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageContentType
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageHeaderField b/src/libraries/qtopiamail/include/QMailMessageHeaderField
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageHeaderField
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageId b/src/libraries/qtopiamail/include/QMailMessageId
new file mode 100644
index 0000000..e2db656
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageId
@@ -0,0 +1 @@
+#include "qmailid.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageKey b/src/libraries/qtopiamail/include/QMailMessageKey
new file mode 100644
index 0000000..06211f5
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageKey
@@ -0,0 +1 @@
+#include "qmailmessagekey.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageListModel b/src/libraries/qtopiamail/include/QMailMessageListModel
new file mode 100644
index 0000000..5eb664a
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageListModel
@@ -0,0 +1 @@
+#include "qmailmessagelistmodel.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageMetaData b/src/libraries/qtopiamail/include/QMailMessageMetaData
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageMetaData
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessagePart b/src/libraries/qtopiamail/include/QMailMessagePart
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessagePart
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessagePartContainer b/src/libraries/qtopiamail/include/QMailMessagePartContainer
new file mode 100644
index 0000000..1f120e0
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessagePartContainer
@@ -0,0 +1 @@
+#include "qmailmessage.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageRemovalRecord b/src/libraries/qtopiamail/include/QMailMessageRemovalRecord
new file mode 100644
index 0000000..737bd83
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageRemovalRecord
@@ -0,0 +1 @@
+#include "qmailmessageremovalrecord.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageServer b/src/libraries/qtopiamail/include/QMailMessageServer
new file mode 100644
index 0000000..5398cdc
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageServer
@@ -0,0 +1 @@
+#include "qmailmessageserver.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageSet b/src/libraries/qtopiamail/include/QMailMessageSet
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageSet
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageSetContainer b/src/libraries/qtopiamail/include/QMailMessageSetContainer
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageSetContainer
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageSetModel b/src/libraries/qtopiamail/include/QMailMessageSetModel
new file mode 100644
index 0000000..d8be240
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageSetModel
@@ -0,0 +1 @@
+#include "qmailmessageset.h"
diff --git a/src/libraries/qtopiamail/include/QMailMessageSortKey b/src/libraries/qtopiamail/include/QMailMessageSortKey
new file mode 100644
index 0000000..b6f0399
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailMessageSortKey
@@ -0,0 +1 @@
+#include "qmailmessagesortkey.h"
diff --git a/src/libraries/qtopiamail/include/QMailNewEmailHandler b/src/libraries/qtopiamail/include/QMailNewEmailHandler
new file mode 100644
index 0000000..61db895
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailNewEmailHandler
@@ -0,0 +1 @@
+#include "qmailnewmessagehandler.h"
diff --git a/src/libraries/qtopiamail/include/QMailNewMessageHandler b/src/libraries/qtopiamail/include/QMailNewMessageHandler
new file mode 100644
index 0000000..61db895
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailNewMessageHandler
@@ -0,0 +1 @@
+#include "qmailnewmessagehandler.h"
diff --git a/src/libraries/qtopiamail/include/QMailPassThroughCodec b/src/libraries/qtopiamail/include/QMailPassThroughCodec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailPassThroughCodec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailQuotedPrintableCodec b/src/libraries/qtopiamail/include/QMailQuotedPrintableCodec
new file mode 100644
index 0000000..1a908f2
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailQuotedPrintableCodec
@@ -0,0 +1 @@
+#include "qmailcodec.h"
diff --git a/src/libraries/qtopiamail/include/QMailRetrievalAction b/src/libraries/qtopiamail/include/QMailRetrievalAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailRetrievalAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QMailSearchAction b/src/libraries/qtopiamail/include/QMailSearchAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailSearchAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QMailServiceAction b/src/libraries/qtopiamail/include/QMailServiceAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailServiceAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QMailStorageAction b/src/libraries/qtopiamail/include/QMailStorageAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailStorageAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QMailStore b/src/libraries/qtopiamail/include/QMailStore
new file mode 100644
index 0000000..217a7a7
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailStore
@@ -0,0 +1 @@
+#include "qmailstore.h"
diff --git a/src/libraries/qtopiamail/include/QMailTimeStamp b/src/libraries/qtopiamail/include/QMailTimeStamp
new file mode 100644
index 0000000..07bfe99
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailTimeStamp
@@ -0,0 +1 @@
+#include "qmailtimestamp.h"
diff --git a/src/libraries/qtopiamail/include/QMailTransmitAction b/src/libraries/qtopiamail/include/QMailTransmitAction
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QMailTransmitAction
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/include/QPrivatelyImplemented b/src/libraries/qtopiamail/include/QPrivatelyImplemented
new file mode 100644
index 0000000..0b73b3b
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QPrivatelyImplemented
@@ -0,0 +1 @@
+#include "qprivateimplementation.h"
diff --git a/src/libraries/qtopiamail/include/QPrivatelyNoncopyable b/src/libraries/qtopiamail/include/QPrivatelyNoncopyable
new file mode 100644
index 0000000..0b73b3b
--- /dev/null
+++ b/src/libraries/qtopiamail/include/QPrivatelyNoncopyable
@@ -0,0 +1 @@
+#include "qprivateimplementation.h"
diff --git a/src/libraries/qtopiamail/include/ServiceConfiguration b/src/libraries/qtopiamail/include/ServiceConfiguration
new file mode 100644
index 0000000..0631517
--- /dev/null
+++ b/src/libraries/qtopiamail/include/ServiceConfiguration
@@ -0,0 +1 @@
+#include "qmailaccountconfiguration.h"
diff --git a/src/libraries/qtopiamail/include/Status b/src/libraries/qtopiamail/include/Status
new file mode 100644
index 0000000..cfbd6ca
--- /dev/null
+++ b/src/libraries/qtopiamail/include/Status
@@ -0,0 +1 @@
+#include "qmailserviceaction.h"
diff --git a/src/libraries/qtopiamail/qmailstore.cpp b/src/libraries/qtopiamail/qmailstore.cpp
index dea4500..b062e80 100644
--- a/src/libraries/qtopiamail/qmailstore.cpp
+++ b/src/libraries/qtopiamail/qmailstore.cpp
@@ -42,7 +42,12 @@
 // Needed to give friend access to the function defined by Q_GLOBAL_STATIC
 #define QMAILSTOREINSTANCE_DEFINED_HERE
 #include "qmailstore.h"
+
+#ifndef SPARQL_STORE
 #include "qmailstore_p.h"
+#else
+#include "qmailstore_sparql.h"
+#endif
 
 /*!
     \class QMailStore
diff --git a/src/libraries/qtopiamail/qmailstore_p.cpp b/src/libraries/qtopiamail/qmailstore_p.cpp
index 75a0dc6..ef6a1d3 100644
--- a/src/libraries/qtopiamail/qmailstore_p.cpp
+++ b/src/libraries/qtopiamail/qmailstore_p.cpp
@@ -1991,6 +1991,7 @@ int QMailStorePrivate::pathIdentifier(const QString &filePath)
 
 int QMailStorePrivate::databaseIdentifier(int n) const
 {
+    qMailLog(Messaging) << "Database name:" << database.databaseName();
     int result = static_cast<int>(::ftok(database.databaseName().toAscii(), n));
     if (result == -1)
         qFatal("Could not create database semaphore. Database could not be found.");
@@ -2010,12 +2011,17 @@ QMailStorePrivate::QMailStorePrivate(QMailStore* parent)
       lastQueryError(0),
       mutex(0)
 {
-    ProcessMutex creationMutex(pathIdentifier(QDir::rootPath()));
+    ProcessMutex creationMutex(pathIdentifier(QDir::homePath()));
     MutexGuard guard(creationMutex);
     if (guard.lock(1000)) {
+        qMailLog(Messaging) << "Successfully lock mutex at:" << QDir::homePath();
+
         //open the database
         database = QMail::createDatabase();
+    } else {
+        qMailLog(Messaging) << "Failed to lock the mutex:" << QDir::homePath();
     }
+
     mutex = new ProcessMutex(databaseIdentifier(1));
     readLock = new ProcessReadLock(databaseIdentifier(2));
     if (contentMutex == 0) {
@@ -2046,7 +2052,7 @@ ProcessMutex& QMailStorePrivate::contentManagerMutex(void)
 
 bool QMailStorePrivate::initStore()
 {
-    ProcessMutex creationMutex(pathIdentifier(QDir::rootPath()));
+    ProcessMutex creationMutex(pathIdentifier(QDir::homePath()));
     MutexGuard guard(creationMutex);
     if (!guard.lock(1000)) {
         return false;
diff --git a/src/libraries/qtopiamail/qmailstore_p.h b/src/libraries/qtopiamail/qmailstore_p.h
index c904bf9..839edf6 100644
--- a/src/libraries/qtopiamail/qmailstore_p.h
+++ b/src/libraries/qtopiamail/qmailstore_p.h
@@ -57,7 +57,7 @@
 #include <QSqlDatabase>
 #include <QCache>
 
-//#define QMAILSTORE_LOG_SQL //define to enable SQL query logging
+#define QMAILSTORE_LOG_SQL //define to enable SQL query logging
 //#define QMAILSTORE_USE_RTTI //define if RTTI is available to assist debugging
 
 #ifdef QMAILSTORE_USE_RTTI
diff --git a/src/libraries/qtopiamail/qmailstore_sparql.cpp b/src/libraries/qtopiamail/qmailstore_sparql.cpp
new file mode 100644
index 0000000..132f0a7
--- /dev/null
+++ b/src/libraries/qtopiamail/qmailstore_sparql.cpp
@@ -0,0 +1,3314 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "qmailstore_sparql.h"
+#include "qmailcontentmanager.h"
+#include "qmailmessageremovalrecord.h"
+#include "qmailtimestamp.h"
+#include "semaphore_p.h"
+#include "qmailnamespace.h"
+#include "qmaillog.h"
+#include <QTextCodec>
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <unistd.h>
+#include <time.h>
+#include <QFile>
+#include <QCoreApplication>
+#include <QDir>
+
+#include "sparqlquery.h"
+#include "sparqlresult.h"
+#include "sparqluri.h"
+
+
+#define Q_USE_SQLITE
+
+// When using GCC 4.1.1 on ARM, TR1 functional cannot be included when RTTI
+// is disabled, since it automatically instantiates some code using typeid().
+//#include <tr1/functional>
+//using std::tr1::bind;
+//using std::tr1::cref;
+#include "bind_p.h"
+
+using nonstd::tr1::bind;
+using nonstd::tr1::cref;
+
+
+namespace { // none of this code is externally visible:
+
+//using namespace QMailDataComparator;
+using namespace QMailKey;
+
+// We allow queries to be specified by supplying a list of message IDs against
+// which candidates will be matched; this list can become too large to be
+// expressed directly in SQL.  Instead, we will build a temporary table to
+// match against when required...
+// The most IDs we can include in a query is currently 999; set an upper limit
+// below this to allow for other variables in the same query, bearing in mind
+// that there may be more than one clause containing this number of IDs in the
+// same query...
+const int IdLookupThreshold = 256;
+
+// Note on retry logic - it appears that SQLite3 will return a SQLITE_BUSY error (5)
+// whenever there is contention on file locks or mutexes, and that these occurrences
+// are not handled by the handler installed by either sqlite3_busy_timeout or
+// sqlite3_busy_handler.  Furthermore, the comments for sqlite3_step state that if
+// the SQLITE_BUSY error is returned whilst in a transaction, the transaction should
+// be rolled back.  Therefore, it appears that we must handle this error by retrying
+// at the QMailStore level, since this is the level where we perform transactions.
+const int Sqlite3BusyErrorNumber = 5;
+
+const int Sqlite3ConstraintErrorNumber = 19;
+
+
+// Helper class for automatic unlocking
+template<typename Mutex>
+class Guard
+{
+    Mutex &mutex;
+    bool locked;
+
+public:
+    enum { DefaultTimeout = 1000 };
+
+    Guard(Mutex& m)
+        : mutex(m),
+          locked(false) 
+    {
+    }
+
+    ~Guard()
+    {
+        unlock();
+    }
+
+    bool lock(int timeout = DefaultTimeout)
+    {
+        return (locked = mutex.lock(timeout));
+    }
+
+    void unlock()
+    {
+        if (locked) {
+            mutex.unlock();
+            locked = false; 
+        }
+    }
+};
+
+typedef Guard<ProcessMutex> MutexGuard;
+
+template <typename IdType>
+QVariantList idValueList(const QList<IdType>& ids)
+{
+    QVariantList values;
+
+    foreach (const IdType& id, ids)
+        values.append(QVariant(id.toULongLong()));
+
+    return values;
+}
+
+
+QString escape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(escapee, QString(escaper) + escapee);
+}
+
+QString unescape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(QString(escaper) + escapee, escapee);
+}
+
+QString contentUri(const QString &scheme, const QString &identifier)
+{
+    if (scheme.isEmpty())
+        return QString();
+
+    // Formulate a URI from the content scheme and identifier
+    return escape(scheme, ':') + ':' + escape(identifier, ':');
+}
+
+QString contentUri(const QMailMessageMetaData &message)
+{
+    return contentUri(message.contentScheme(), message.contentIdentifier());
+}
+
+QPair<QString, QString> uriElements(const QString &uri)
+{
+    int index = uri.indexOf(':');
+    while ((index != -1) && (uri.at(index - 1) == '\\'))
+        index = uri.indexOf(':', index + 1);
+
+    return qMakePair(unescape(uri.mid(0, index), ':'), unescape(uri.mid(index + 1), ':'));
+}
+
+const char *WellKnownUris[] = {
+    "qmf://groove.harmattan.com/email#",
+    "qmf://groove.nokia.com/folder#",
+    "qmf://groove.nokia.com/accounts#" };
+
+template <class T, int INDEX>
+class WellKnownUri : public SparqlUri
+{
+public:
+    WellKnownUri() : SparqlUri(WellKnownUris[INDEX]) {}
+    WellKnownUri(const T& id) : SparqlUri(WellKnownUris[INDEX], id.toULongLong()) {}
+    T id() const { return T(id()); }
+    operator T () { return id(); }
+};
+
+typedef WellKnownUri<QMailMessageId, 0> MailMessageUri;
+typedef WellKnownUri<QMailFolderId,  1> MailFolderUri;
+typedef WellKnownUri<QMailAccountId, 2> MailAccountUri;
+
+QString combineOperatorString(QMailKey::Combiner op)
+{
+    switch (op)
+    {
+    case And:
+        return " && ";
+        break;
+
+    case Or:
+        return " || ";
+        break;
+
+    case None:
+        break;
+    }
+
+    return QString();
+}
+
+QString operatorStringPattern(int argNumber, const QString& op, const QString& comp)
+{
+    QStringList pattern;
+    for (int i = 0; i<argNumber; i++)
+        pattern << "(%1 " + op + " %" + QString::number(i+2) + ")";
+
+    if (argNumber > 1)
+        return "(" + pattern.join(comp) + ")";
+    else
+        return pattern.join(comp);
+}
+
+template <class Comparator>
+QString operatorString(Comparator op, int argsNumber = 1);
+
+template <>
+QString operatorString<QMailKey::Comparator>(QMailKey::Comparator op, int argsNumber)
+{
+    switch (op)
+    {
+    case Equal:
+        //  "(%1 = \"%2\")" : "(%1 = \"%2\") || (%1 = \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "=", "") : operatorStringPattern(argsNumber, "=", " || "));
+        break;
+
+    case NotEqual:
+        // "(%1 != \"%2\")" : "(%1 != \"%2\") && (%1 != \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "!=", "") : operatorStringPattern(argsNumber, "!=", " && "));
+        break;
+
+    case LessThan:
+        return "(%1 < %2)";
+        break;
+
+    case LessThanEqual:
+        return "(%1 <= %2)";
+        break;
+
+    case GreaterThan:
+        return "(%1 > %2)";
+        break;
+
+    case GreaterThanEqual:
+        return "(%1 >= %2)";
+        break;
+
+    case Includes:
+    case Present:
+        // "(%1 & \"%2\")" : "(%1 = \"%2\") || (%1 = \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "&", "") : operatorStringPattern(argsNumber, "=", " || "));
+        break;
+
+    case Excludes:
+    case Absent:
+        // "!(%1 & \"%2\")" : "(%1 != \"%2\") && (%1 != \"%3\")"
+        return (argsNumber == 1 ? "(!" + operatorStringPattern(argsNumber, "&", "") + ")": operatorStringPattern(argsNumber, "!=", " && "));
+        break;
+    }
+
+    return QString();
+}
+
+template <class Property>
+QString propertyNameString(Property property);
+
+template <>
+QString propertyNameString<QMailMessageKey::Property>(QMailMessageKey::Property property)
+{
+    switch (property)
+    {
+        case QMailMessageKey::Id:
+            return "?mail";
+
+        case QMailMessageKey::Type:
+            return "?type";
+
+        case QMailMessageKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailMessageKey::Sender:
+            return "?sender";
+
+        case QMailMessageKey::Recipients:
+            return "?recipients";
+
+        case QMailMessageKey::Subject:
+            return "?subject";
+
+        case QMailMessageKey::TimeStamp:
+            return "?timestamp";
+
+        case QMailMessageKey::Status:
+            return "?status";
+
+        case QMailMessageKey::Conversation:
+            return "?conversation";
+
+        case QMailMessageKey::ReceptionTimeStamp:
+            return "?receptionTimeStamp";
+
+        case QMailMessageKey::ServerUid:
+            return "?serverUid";
+
+        case QMailMessageKey::Size:
+            return "?size";
+
+        case QMailMessageKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailMessageKey::AncestorFolderIds:
+            return "?ancestorFolderIds";
+
+        case QMailMessageKey::ContentType:
+            return "?contentType";
+
+        case QMailMessageKey::PreviousParentFolderId:
+            return "?previousParentFolderId";
+
+        case QMailMessageKey::ContentScheme:
+            return "?contentScheme";
+
+        case QMailMessageKey::ContentIdentifier:
+            return "?contentIdentifier";
+
+        case QMailMessageKey::InResponseTo:
+            return "?inResponseTo";
+
+        case QMailMessageKey::ResponseType:
+            return "?responseType";
+
+        case QMailMessageKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailFolderKey::Property>(QMailFolderKey::Property property)
+{
+    switch (property)
+    {
+        case QMailFolderKey::Id:
+            return "?folder";
+
+        case QMailFolderKey::Path:
+            return "?path";
+
+        case QMailFolderKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailFolderKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailFolderKey::DisplayName:
+            return "?displayName";
+
+        case QMailFolderKey::Status:
+            return "?status";
+
+        case QMailFolderKey::AncestorFolderIds:
+            return "?ancestorFolderIds";
+
+        case QMailFolderKey::ServerCount:
+            return "?serverCount";
+
+        case QMailFolderKey::ServerUnreadCount:
+            return "?serverUnreadCount";
+
+        case QMailFolderKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailAccountKey::Property>(QMailAccountKey::Property property)
+{
+    switch (property)
+    {
+        case QMailAccountKey::Id:
+            return "?account";
+
+        case QMailAccountKey::Name:
+            return "?name";
+
+        case QMailAccountKey::MessageType:
+            return "?messageType";
+
+        case QMailAccountKey::FromAddress:
+            return "?fromAddress";
+
+        case QMailAccountKey::Status:
+            return "?status";
+
+        case QMailAccountKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailMessageSortKey::Property>(QMailMessageSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailMessageSortKey::Id:
+            return propertyNameString(QMailMessageKey::Id);
+
+        case QMailMessageSortKey::Type:
+            return propertyNameString(QMailMessageKey::Type);
+
+        case QMailMessageSortKey::ParentFolderId:
+            return propertyNameString(QMailMessageKey::ParentFolderId);
+
+        case QMailMessageSortKey::Sender:
+            return propertyNameString(QMailMessageKey::Sender);
+
+        case QMailMessageSortKey::Recipients:
+            return propertyNameString(QMailMessageKey::Recipients);
+
+        case QMailMessageSortKey::Subject:
+            return propertyNameString(QMailMessageKey::Subject);
+
+        case QMailMessageSortKey::TimeStamp:
+            return propertyNameString(QMailMessageKey::TimeStamp);
+
+        case QMailMessageSortKey::Status:
+            return propertyNameString(QMailMessageKey::Status);
+
+        case QMailMessageSortKey::ReceptionTimeStamp:
+            return propertyNameString(QMailMessageKey::ReceptionTimeStamp);
+
+        case QMailMessageSortKey::ServerUid:
+            return propertyNameString(QMailMessageKey::ServerUid);
+
+        case QMailMessageSortKey::Size:
+            return propertyNameString(QMailMessageKey::Size);
+
+        case QMailMessageSortKey::ParentAccountId:
+            return propertyNameString(QMailMessageKey::ParentAccountId);
+
+        case QMailMessageSortKey::ContentType:
+            return propertyNameString(QMailMessageKey::ContentType);
+
+        case QMailMessageSortKey::PreviousParentFolderId:
+            return propertyNameString(QMailMessageKey::PreviousParentFolderId);
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailFolderSortKey::Property>(QMailFolderSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailFolderSortKey::Id:
+            return propertyNameString(QMailFolderKey::Id);
+
+        case QMailFolderSortKey::Path:
+            return propertyNameString(QMailFolderKey::Path);
+
+        case QMailFolderSortKey::ParentFolderId:
+            return propertyNameString(QMailFolderKey::ParentFolderId);
+
+        case QMailFolderSortKey::ParentAccountId:
+            return propertyNameString(QMailFolderKey::ParentAccountId);
+
+        case QMailFolderSortKey::DisplayName:
+            return propertyNameString(QMailFolderKey::DisplayName);
+
+        case QMailFolderSortKey::Status:
+            return propertyNameString(QMailFolderKey::Status);
+
+        case QMailFolderSortKey::ServerCount:
+            return propertyNameString(QMailFolderKey::ServerCount);
+
+        case QMailFolderSortKey::ServerUnreadCount:
+            return propertyNameString(QMailFolderKey::ServerUnreadCount);
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailAccountSortKey::Property>(QMailAccountSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailAccountSortKey::Id:
+            return propertyNameString(QMailAccountKey::Id);
+
+        case QMailAccountSortKey::Name:
+            return propertyNameString(QMailAccountKey::Name);
+
+        case QMailAccountSortKey::MessageType:
+            return propertyNameString(QMailAccountKey::MessageType);
+
+        case QMailAccountSortKey::Status:
+            return propertyNameString(QMailAccountKey::Status);
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class Property>
+QString sparqlPropertyStatmentString(const QString& uri, Property property);
+
+template <>
+QString sparqlPropertyStatmentString<QMailMessageKey::Property>(const QString& uri, QMailMessageKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailMessageKey::Id:
+            return QString();
+
+        case QMailMessageKey::Type:
+            return QString();
+
+        case QMailMessageKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Sender:
+            return QString("%1 nmo:sender [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Recipients:
+            return QString("%1 nmo:recipient [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Subject:
+            return QString("%1 nmo:messageSubject %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::TimeStamp:
+            return QString("%1 nmo:sentDate %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Conversation:
+            return QString();
+
+        case QMailMessageKey::ReceptionTimeStamp:
+            return QString();
+
+        case QMailMessageKey::ServerUid:
+            return QString("%1 nmo:messageId %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Size:
+            return QString("%1 nie:contentSize %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::AncestorFolderIds:
+            return QString();
+
+        case QMailMessageKey::ContentType:
+            return QString();
+
+        case QMailMessageKey::PreviousParentFolderId:
+            return QString();
+
+        case QMailMessageKey::ContentScheme:
+            return QString();
+
+        case QMailMessageKey::ContentIdentifier:
+            return QString("%1 nie:isStoredAs [ rdf:type nie:DataObject ; nie:dataSource %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::InResponseTo:
+            return QString("%1 nmo:inReplyTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::ResponseType:
+            return QString();
+
+        case QMailMessageKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailFolderKey::Property>(const QString& uri, QMailFolderKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailFolderKey::Id:
+            return QString();
+
+        case QMailFolderKey::Path:
+            return QString("%1 nmo:folderName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::DisplayName:
+            return QString("%1 nmo:folderDisplayName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::AncestorFolderIds:
+            return QString();
+
+        case QMailFolderKey::ServerCount:
+            return QString("%1 nmo:serverCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ServerUnreadCount:
+            return QString("%1 nmo:serverUnreadCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailAccountKey::Property>(const QString& uri, QMailAccountKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailAccountKey::Id:
+            return QString("%1 rdf:type %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Name:
+            return QString("%1 nmo:accountName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::MessageType:
+            return QString();
+
+        case QMailAccountKey::FromAddress:
+            return QString("%1 nmo:fromAddress [ rdf:type nco:EmailAddress ; nco:emailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailMessageSortKey::Property>(const QString& uri, QMailMessageSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailMessageSortKey::Id:
+            return QString();
+
+        case QMailMessageSortKey::Type:
+            return QString();
+
+        case QMailMessageSortKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Sender:
+            return QString("%1 nmo:sender [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Recipients:
+            return QString("%1 nmo:recipient [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Subject:
+            return QString("%1 nmo:messageSubject %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::TimeStamp:
+            return QString("%1 nmo:sentDate %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ReceptionTimeStamp:
+            return QString();
+
+        case QMailMessageSortKey::ServerUid:
+            return QString("%1 nmo:messageId %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Size:
+            return QString("%1 nie:contentSize %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ContentType:
+            return QString();
+
+        case QMailMessageSortKey::PreviousParentFolderId:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailFolderSortKey::Property>(const QString& uri, QMailFolderSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailFolderSortKey::Id:
+            return "id";
+
+        case QMailFolderSortKey::Path:
+            return QString("%1 nmo:folderName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::DisplayName:
+            return QString("%1 nmo:folderDisplayName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ServerCount:
+            return QString("%1 nmo:serverCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ServerUnreadCount:
+            return QString("%1 nmo:serverUnreadCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailAccountSortKey::Property>(const QString& uri, QMailAccountSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailAccountSortKey::Id:
+            return QString();
+
+        case QMailAccountSortKey::Name:
+            return QString("%1 nmo:accountName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountSortKey::MessageType:
+            return QString();
+
+        case QMailAccountSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class Key, class SortKey>
+QString keyStatment(const QString& uri, const Key& key, const SortKey& sort = SortKey())
+{
+    typedef typename Key::ArgumentType     ArgumentType;
+    typedef typename SortKey::ArgumentType SortArgumentType;
+
+    QStringList arguments;
+    foreach (SortArgumentType argument, sort.arguments())
+    {
+        QString statement = sparqlPropertyStatmentString(uri, argument.first);
+        if (!statement.isEmpty() && !arguments.contains(statement))
+            arguments << statement;
+    }
+
+    foreach (ArgumentType argument, key.arguments())
+    {
+        QString statement = sparqlPropertyStatmentString(uri, argument.property);
+        if (!statement.isEmpty() && !arguments.contains(statement))
+            arguments << statement;
+    }
+
+    foreach (const Key& subkey, key.subKeys())
+        arguments << keyStatment(uri, subkey, SortKey());
+
+    return arguments.join("\n");
+}
+
+QString argumentValue(const QVariant& value)
+{
+    if (qVariantCanConvert<QMailAccountId>(value))
+        return MailAccountUri(qVariantValue<QMailAccountId>(value));
+    else if (qVariantCanConvert<QMailFolderId>(value))
+        return MailFolderUri(qVariantValue<QMailFolderId>(value));
+    else if (qVariantCanConvert<QMailMessageId>(value))
+        return MailMessageUri(qVariantValue<QMailMessageId>(value));
+    else if (qVariantCanConvert<QString>(value))
+        return qVariantValue<QString>(value);
+    else if (qVariantCanConvert<int>(value))
+        return QString::number(qVariantValue<int>(value));
+    else {
+        Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class ArgumentType>
+QString keyArgument(const ArgumentType& argument)
+{
+    typedef typename ArgumentType::Property Property;
+    typedef typename ArgumentType::Comparator Comparator;
+
+    QString pattern = operatorString(argument.op, argument.valueList.count());
+    pattern = pattern.arg(propertyNameString(argument.property));
+
+    foreach (QVariant value, argument.valueList)
+        pattern = pattern.arg(argumentValue(value));
+
+    return pattern;
+}
+
+template <class Key>
+QString keyFilter(const Key& key)
+{
+    typedef typename Key::ArgumentType ArgumentType;
+
+    QStringList arguments;
+    foreach (ArgumentType argument, key.arguments())
+        arguments << keyArgument<ArgumentType>(argument);
+
+    foreach (const Key& subkey, key.subKeys())
+        arguments << keyFilter<Key>(subkey);
+
+    QString filter = arguments.size() > 1 ? QString(key.isNegated() ? "!(%1)" : "(%1)") :
+                                            QString(key.isNegated() ? "!(%1)" : "%1");
+    return filter.arg(arguments.join(combineOperatorString(key.combiner())));
+}
+
+template <class SortKey>
+QString sortKey(const SortKey& sortKey)
+{
+    typedef typename SortKey::ArgumentType ArgumentType;
+
+    QString orderCondition;
+    foreach (ArgumentType argument, sortKey.arguments())
+        if (argument.second == Qt::AscendingOrder)
+            orderCondition += QString(" ASC(%1)").arg(propertyNameString(argument.first));
+        else
+            orderCondition += QString(" DESC(%1)").arg(propertyNameString(argument.first));
+
+    if (!orderCondition.isEmpty())
+        return QString("ORDER BY %1").arg(orderCondition);
+
+    return QString();
+}
+
+QString keyQuery(const QMailMessageKey& key, const QMailMessageSortKey& sort = QMailMessageSortKey())
+{
+    QString query = QString("SELECT %1 \n"
+                            "WHERE { \n"
+                            "%1 rdf:type nmo:Email . \n"
+                            "%2"
+                            "%3"
+                            "} %4\n").arg(propertyNameString(QMailMessageKey::Id));
+
+    QString statement = keyStatment(propertyNameString(QMailMessageKey::Id), key, sort);
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter).arg(sortKey(sort));
+}
+
+QString keyQuery(const QMailFolderKey& key, const QMailFolderSortKey& sort = QMailFolderSortKey())
+{
+    QString query = QString("SELECT %1 \n"
+                            "WHERE { \n"
+                            "%1 rdf:type nmo:MailFolder . \n"
+                            "%2"
+                            "%3"
+                            "} %4\n").arg(propertyNameString(QMailFolderKey::Id));
+
+    QString statement = keyStatment(propertyNameString(QMailFolderKey::Id), key, sort);
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter).arg(sortKey(sort));
+}
+
+QString keyQuery(const QMailAccountKey& key, const QMailAccountSortKey& sort = QMailAccountSortKey())
+{
+    QString query = QString("SELECT %1 \n"
+                            "WHERE { \n"
+                            "%1 rdf:type nmo:Mailbox . \n"
+                            "%2"
+                            "%3"
+                            "} %4\n").arg(propertyNameString(QMailAccountKey::Id));
+
+    QString statement = keyStatment(propertyNameString(QMailAccountKey::Id), key, sort);
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter).arg(sortKey(sort));
+}
+
+QString keyCount(const QMailMessageKey& key)
+{
+    QString query("SELECT COUNT(?mail) AS count \n"
+                  "WHERE { \n"
+                  "?mail rdf:type nmo:Email . \n"
+                  "%1"
+                  "%2"
+                  "}\n");
+
+    QString statement = keyStatment("?mail", key, QMailAccountSortKey());
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter);
+}
+
+QString keyCount(const QMailFolderKey& key)
+{
+    QString query("SELECT COUNT(?folder) AS count \n"
+                  "WHERE { \n"
+                  "?folder rdf:type nmo:MailFolder . \n"
+                  "%1"
+                  "%2"
+                  "}\n");
+
+    QString statement = keyStatment("?folder", key, QMailAccountSortKey());
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter);
+}
+
+QString keyCount(const QMailAccountKey& key)
+{
+    QString query("SELECT COUNT(?account) AS count \n"
+                  "WHERE { \n"
+                  "?account rdf:type nmo:Mailbox . \n"
+                  "%1"
+                  "%2"
+                  "}\n");
+
+    QString statement = keyStatment("?account", key, QMailAccountSortKey());
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter);
+}
+
+template <class Key>
+void debugKey(const Key& key)
+{
+    typedef typename Key::ArgumentType ArgumentType;
+
+    qDebug() << "Key Combiner:" << key.combiner();
+    qDebug() << "Key Is empty:" << key.isEmpty();
+    qDebug() << "Key Non Matching:" << key.isNonMatching();
+    qDebug() << "Key Is Negated:" << key.isNegated();
+
+    foreach (ArgumentType argument, key.arguments())
+    {
+        qDebug() << "Argument Property:" << argument.property;
+        qDebug() << "Argument Comparator:" << argument.op;
+        foreach (QVariant value, argument.valueList)
+            qDebug() << "Argument Value List:" << value;
+    }
+
+    foreach (const Key& subkey, key.subKeys())
+        debugKey(subkey);
+}
+
+QString nmoRecipients(const QList<QMailAddress>& recipients)
+{
+    QString result;
+    foreach (const QMailAddress& address, recipients)
+    {
+        QString triplet(QString(
+    "        nmo:recipient [\n"
+    "            rdf:type nco:Contact ;\n"
+    "            nco:fullname \"%1\" ; \n"
+    "            nco:hasEmailAddress <mailto:%2> ] ;\n")
+                .arg(address.name())
+                .arg(address.address()));
+        result.append(triplet);
+    }
+    return result;
+}
+
+template <class T>
+T IdFromUri(const QString& uri)
+{
+    int pos = uri.indexOf('#');
+    if (pos >= 0)
+    {
+        bool ok = false;
+        quint64 postfix = uri.right(uri.length() - pos-1).toULongLong(&ok);
+
+        if (ok)
+            return T(postfix);
+    }
+
+    return T();
+}
+
+} // namespace
+
+// We need to support recursive locking, per-process
+static volatile int mutexLockCount = 0;
+static volatile int readLockCount = 0;
+
+class QMailStorePrivate::Transaction
+{
+    QMailStorePrivate *m_d;
+    bool m_initted;
+    bool m_committed;
+
+public:
+    Transaction(QMailStorePrivate *);
+    ~Transaction();
+
+    bool commit();
+
+    bool committed() const;
+};
+
+QMailStorePrivate::Transaction::Transaction(QMailStorePrivate* d)
+    : m_d(d),
+      m_initted(false),
+      m_committed(false)
+{
+    if (mutexLockCount > 0) {
+        // Increase lock recursion depth
+        ++mutexLockCount;
+        m_initted = true;
+    } else {
+        // This process does not yet have a mutex lock
+        if (m_d->databaseMutex().lock(10000)) {
+            // Wait for any readers to complete
+            if (m_d->databaseReadLock().wait(10000)) {
+                    ++mutexLockCount;
+                    m_initted = true;
+            } else {
+                qWarning() << "Unable to wait for database read lock to reach zero!";
+            }
+
+            if (!m_initted) {
+                m_d->databaseMutex().unlock();
+            }
+        } else {
+            qWarning() << "Unable to lock database mutex for transaction!";
+        }
+    }
+}
+
+QMailStorePrivate::Transaction::~Transaction()
+{
+    if (m_initted && !m_committed) {
+
+        --mutexLockCount;
+        if (mutexLockCount == 0)
+            m_d->databaseMutex().unlock();
+    }
+}
+
+bool QMailStorePrivate::Transaction::commit()
+{
+    if (m_initted && !m_committed) {
+        // TBD: Pretend that we've
+        // commited that already.
+        m_committed = true;
+        --mutexLockCount;
+        if (mutexLockCount == 0)
+            m_d->databaseMutex().unlock();
+    }
+
+    return m_committed;
+}
+
+bool QMailStorePrivate::Transaction::committed() const
+{
+    return m_committed;
+}
+
+class QMailStorePrivate::ReadLock
+{
+    QMailStorePrivate *m_d;
+    bool m_locked;
+
+public:
+    ReadLock(QMailStorePrivate *);
+    ~ReadLock();
+};
+
+QMailStorePrivate::ReadLock::ReadLock(QMailStorePrivate* d)
+    : m_d(d),
+      m_locked(false)
+{
+    if (readLockCount > 0) {
+        // Increase lock recursion depth
+        ++readLockCount;
+        m_locked = true;
+    } else {
+        // This process does not yet have a read lock
+        // Lock the mutex to ensure no writers are active or waiting (unless we have already locked it)
+        if ((mutexLockCount > 0) || m_d->databaseMutex().lock(10000)) {
+            m_d->databaseReadLock().lock();
+            ++readLockCount;
+            m_locked = true;
+
+            if (mutexLockCount == 0)
+                m_d->databaseMutex().unlock();
+        } else {
+            qWarning() << "Unable to lock database mutex for read lock!";
+        }
+    }
+}
+
+QMailStorePrivate::ReadLock::~ReadLock()
+{
+    if (m_locked) {
+        --readLockCount;
+        if (readLockCount == 0)
+            m_d->databaseReadLock().unlock();
+    }
+}
+
+template<typename FunctionType>
+QMailStorePrivate::AttemptResult evaluate(QMailStorePrivate::WriteAccess, FunctionType func, const QString& description, QMailStorePrivate* d)
+{
+    QMailStorePrivate::Transaction t(d);
+
+    QMailStorePrivate::AttemptResult result = func(t);
+
+    // Ensure that the transaction was committed
+    if ((result == QMailStorePrivate::Success) && !t.committed()) {
+        qMailLog(Messaging) << ::getpid() << "Failed to commit successful" << qPrintable(description) << "!";
+    }
+
+    return result;
+}
+
+template<typename FunctionType>
+QMailStorePrivate::AttemptResult evaluate(QMailStorePrivate::ReadAccess, FunctionType func, const QString&, QMailStorePrivate* d)
+{
+    QMailStorePrivate::ReadLock l(d);
+
+    return func(l);
+}
+
+QMailStore::ErrorCode errorType(QMailStorePrivate::ReadAccess)
+{
+    return QMailStore::InvalidId;
+}
+
+QMailStore::ErrorCode errorType(QMailStorePrivate::WriteAccess)
+{
+    return QMailStore::ConstraintFailure;
+}
+
+// Properties of the mailmessages table
+static QMailStorePrivate::MessagePropertyMap messagePropertyMap()
+{
+    QMailStorePrivate::MessagePropertyMap map;
+
+    map.insert(QMailMessageKey::Id,"id");
+    map.insert(QMailMessageKey::Type,"type");
+    map.insert(QMailMessageKey::ParentFolderId,"parentfolderid");
+    map.insert(QMailMessageKey::Sender,"sender");
+    map.insert(QMailMessageKey::Recipients,"recipients");
+    map.insert(QMailMessageKey::Subject,"subject");
+    map.insert(QMailMessageKey::TimeStamp,"stamp");
+    map.insert(QMailMessageKey::ReceptionTimeStamp,"receivedstamp");
+    map.insert(QMailMessageKey::Status,"status");
+    map.insert(QMailMessageKey::ParentAccountId,"parentaccountid");
+    map.insert(QMailMessageKey::ServerUid,"serveruid");
+    map.insert(QMailMessageKey::Size,"size");
+    map.insert(QMailMessageKey::ContentType,"contenttype");
+    map.insert(QMailMessageKey::PreviousParentFolderId,"previousparentfolderid");
+    map.insert(QMailMessageKey::ContentScheme,"mailfile");
+    map.insert(QMailMessageKey::ContentIdentifier,"mailfile");
+    map.insert(QMailMessageKey::InResponseTo,"responseid");
+    map.insert(QMailMessageKey::ResponseType,"responsetype");
+
+    return map;
+}
+
+const QMailMessageKey::Properties &QMailStorePrivate::updatableMessageProperties()
+{
+    static QMailMessageKey::Properties p = QMailMessageKey::ParentFolderId |
+                                           QMailMessageKey::Type |
+                                           QMailMessageKey::Sender |
+                                           QMailMessageKey::Recipients |
+                                           QMailMessageKey::Subject |
+                                           QMailMessageKey::TimeStamp |
+                                           QMailMessageKey::ReceptionTimeStamp |
+                                           QMailMessageKey::Status |
+                                           QMailMessageKey::ParentAccountId |
+                                           QMailMessageKey::ServerUid |
+                                           QMailMessageKey::Size |
+                                           QMailMessageKey::ContentType |
+                                           QMailMessageKey::PreviousParentFolderId |
+                                           QMailMessageKey::ContentScheme |
+                                           QMailMessageKey::ContentIdentifier |
+                                           QMailMessageKey::InResponseTo |
+                                           QMailMessageKey::ResponseType;
+    return p;
+}
+
+const QMailMessageKey::Properties &QMailStorePrivate::allMessageProperties()
+{
+    static QMailMessageKey::Properties p = QMailMessageKey::Id | updatableMessageProperties();
+    return p;
+}
+
+const QMailStorePrivate::MessagePropertyMap& QMailStorePrivate::messagePropertyMap()
+{
+    static const MessagePropertyMap map(::messagePropertyMap());
+    return map;
+}
+
+const QMailStorePrivate::MessagePropertyList& QMailStorePrivate::messagePropertyList()
+{
+    static const MessagePropertyList list(messagePropertyMap().keys());
+    return list;
+}
+
+const QString &QMailStorePrivate::defaultContentScheme() 
+{
+    static QString scheme(QMailContentManagerFactory::defaultScheme());
+    return scheme;
+}
+
+int QMailStorePrivate::pathIdentifier(const QString &filePath)
+{
+    return static_cast<int>(::ftok(filePath.toAscii(), 1));
+}
+
+int QMailStorePrivate::databaseIdentifier(int n) const
+{
+    // TBD: Find good file name for the SPARQL database
+    QString databasePath = QDir::homePath() + "/.cache/tracker/contents.db";
+    int result = static_cast<int>(::ftok(databasePath.toAscii(), n));
+    if (result == -1)
+        qFatal("Could not create database semaphore. Database could not be found.");
+    return result;
+}
+
+
+ProcessMutex* QMailStorePrivate::contentMutex = 0;
+
+QMailStorePrivate::QMailStorePrivate(QMailStore* parent)
+    : QMailStoreImplementation(parent),
+      headerCache(headerCacheSize),
+      folderCache(folderCacheSize),
+      accountCache(accountCacheSize),
+      inTransaction(false),
+      lastQueryError(0),
+      mutex(0)
+{
+    qDebug() << "QMailStorePrivate::QMailStorePrivate";
+    ProcessMutex creationMutex(pathIdentifier(QDir::rootPath()));
+    MutexGuard guard(creationMutex);
+    mutex = new ProcessMutex(databaseIdentifier(1));
+    readLock = new ProcessReadLock(databaseIdentifier(2));
+    if (contentMutex == 0) {
+        contentMutex = new ProcessMutex(databaseIdentifier(3));
+    }
+}
+
+QMailStorePrivate::~QMailStorePrivate()
+{
+    delete mutex;
+    delete readLock;
+}
+
+ProcessMutex& QMailStorePrivate::databaseMutex(void) const
+{
+    return *mutex;
+}
+
+ProcessReadLock& QMailStorePrivate::databaseReadLock(void) const
+{
+    return *readLock;
+}
+
+ProcessMutex& QMailStorePrivate::contentManagerMutex(void)
+{
+    return *contentMutex;
+}
+
+bool QMailStorePrivate::initStore()
+{
+    ProcessMutex creationMutex(pathIdentifier(QDir::rootPath()));
+    MutexGuard guard(creationMutex);
+    if (!guard.lock(1000)) {
+        return init;
+    }
+
+    if (sparqlDatabase.isOpenError()) {
+        qMailLog(Messaging) << "Unable to open database in initStore!";
+        return false;
+    }
+
+    if (!setupStandardFolder(QMailFolder::InboxFolder,  tr("Inbox"))     ||
+        !setupStandardFolder(QMailFolder::OutboxFolder, tr("Outbox"))    ||
+        !setupStandardFolder(QMailFolder::DraftsFolder, tr("Drafts"))    ||
+        !setupStandardFolder(QMailFolder::SentFolder,   tr("Sent"))      ||
+        !setupStandardFolder(QMailFolder::TrashFolder,  tr("Trash"))) {
+            return false;
+        }
+
+        QMailAccount::initStore();
+        QMailFolder::initStore();
+        QMailMessage::initStore();
+
+    if (!QMailContentManagerFactory::init()) {
+        qMailLog(Messaging) << "Could not initialize content manager factory";
+        return false;
+    }
+
+    // We are now correctly initialized
+    init = true;
+    return true;
+}
+
+void QMailStorePrivate::clearContent()
+{
+    // Clear all caches
+    accountCache.clear();
+    folderCache.clear();
+    headerCache.clear();
+
+    // TBD: Drop all data
+    
+    // Remove all content
+    QMailContentManagerFactory::clearContent();
+}
+
+void QMailStorePrivate::setQueryError(const SparqlQuery& query, const QString &description)
+{
+    QString s;
+    QTextStream ts(&s);
+
+    lastQueryError = query.error();
+
+    ts << qPrintable(description) << "; error:\"" << query.query() << '"';
+    qMailLog(Messaging) << "(" << ::getpid() << ")" << qPrintable(s);
+    qWarning() << qPrintable(s);
+}
+
+QString QMailStorePrivate::queryError() const
+{
+    return lastQueryError;
+}
+
+void QMailStorePrivate::clearQueryError(void) 
+{
+    lastQueryError.clear();
+}
+
+bool QMailStorePrivate::uriExists(const QString& uri)
+{
+    // TBD: Check whether value exists already
+    Q_UNUSED(uri);
+    return false;
+}
+
+bool QMailStorePrivate::setupStandardFolder(enum QMailFolder::StandardFolder folder, const QString& name)
+{
+    MailFolderUri  folderUri(QMailFolderId((int)folder));
+    MailFolderUri  parentFolderUri(QMailFolderId(0));
+    MailAccountUri parentAccountUri(QMailAccountId(0));
+
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "%1 rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName \"%2\" ; \n"
+    "   nie:isLogicalPartOf %3 ; \n"
+    "   nie:relatedTo %4 ; \n"
+    "   nmo:folderDisplayName \"%5\" ; \n"
+    "   nmo:status \"%6\"^^xsd:integer ; \n"
+    "   nmo:serverCount \"%7\"^^xsd:integer ; \n"
+    "   nmo:serverUnreadCount \"%8\"^^xsd:integet . \n"
+    "}").arg(folderUri.uri())
+        .arg(name)
+        .arg(parentFolderUri.uri())
+        .arg(parentAccountUri.uri())
+        .arg(0)
+        .arg(0)
+        .arg(0)
+        .arg(0));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return false;
+    }
+
+    qDebug() << "Query succeeded";
+
+    // TBD: Update folder links also
+    return true;
+}
+
+QMailAccount QMailStorePrivate::extractAccount(const QMailAccountId& id, const QStringList& list)
+{
+    QMailAccount account;
+
+    // Load account data
+    account.setId(id);
+    account.setName(list.at(0));
+    /* account.setStatus(list.at(1).toULongLong()); */
+    account.setSignature(list.at(1));
+    account.setFromAddress(QMailAddress(list.at(2)));
+
+    return account;
+}
+
+QMailFolder QMailStorePrivate::extractFolder(const QMailFolderId& id, const QStringList& list)
+{
+    // Load folder data
+    QMailFolder folder(list.at(0), IdFromUri<QMailFolderId>(list.at(1)), IdFromUri<QMailAccountId>(list.at(2)));
+
+    folder.setId(id);
+    folder.setDisplayName(list.at(3));
+//    folder.setStatus(list.at(4).toULongLong());
+//    folder.setServerCount(list.at(5).toUInt());
+//    folder.setServerUnreadCount(list.at(6).toUInt());
+
+    return folder;
+}
+
+void QMailStorePrivate::extractMessageMetaData(const QStringList& list, QMailMessageMetaData* metaData)
+{
+    // Load message properties
+
+    metaData->setParentFolderId(IdFromUri<QMailFolderId>(list.at(0)));
+    metaData->setFrom(QMailAddress(list.at(1), list.at(2)));
+    metaData->setSubject(list.at(3));
+    metaData->setDate(QMailTimeStamp(list.at(4)));
+    metaData->setStatus(list.at(5).toULongLong());
+    metaData->setParentAccountId(IdFromUri<QMailAccountId>(list.at(6)));
+    metaData->setServerUid(list.at(10));
+    metaData->setSize(list.at(9).toUInt());
+    metaData->setContent((QMailMessageMetaDataFwd::ContentType)list.at(10).toInt());
+    metaData->setInResponseTo(QMailMessageId(IdFromUri<QMailMessageId>(list.at(11))));
+    metaData->setResponseType((QMailMessageMetaDataFwd::ResponseType)list.at(12).toInt());
+    metaData->setReceivedDate(QMailTimeStamp(list.at(13)));
+
+    metaData->setUnmodified();
+}
+
+bool QMailStorePrivate::addAccount(QMailAccount *account, QMailAccountConfiguration *config,
+                                   QMailAccountIdList *addedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptAddAccount, this, 
+                                        account, config, 
+                                        addedAccountIds), 
+                                   "addAccount");
+}
+
+bool QMailStorePrivate::addFolder(QMailFolder *folder,
+                                  QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{   
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptAddFolder, this, 
+                                        folder, 
+                                        addedFolderIds, modifiedAccountIds), 
+                                   "addFolder");
+}
+
+bool QMailStorePrivate::addMessage(QMailMessage *message,
+                                   QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    if (!message->parentAccountId().isValid()) {
+        // Require a parent account - possibly relax this later
+        qMailLog(Messaging) << "Unable to add message without parent account";
+        return false;
+    }
+
+    if (message->contentScheme().isEmpty()) {
+        // Use the default storage scheme
+        message->setContentScheme(defaultContentScheme());
+    }
+
+    MutexGuard lock(contentManagerMutex());
+    if (!lock.lock(1000)) {
+        qMailLog(Messaging) << "Unable to acquire message body mutex in addMessage!";
+        return false;
+    } 
+
+    if (QMailContentManager *contentManager = QMailContentManagerFactory::create(message->contentScheme())) {
+        QMailStore::ErrorCode code = contentManager->add(message);
+        if (code != QMailStore::NoError) {
+            setLastError(code);
+            qMailLog(Messaging) << "Unable to add message content to URI:" << ::contentUri(*message);
+            return false;
+        }
+
+        if (!addMessage(static_cast<QMailMessageMetaData*>(message), updatedMessageIds, addedMessageIds, modifiedFolderIds, modifiedAccountIds)) {
+            QMailStore::ErrorCode code = contentManager->remove(message->contentIdentifier());
+            if (code != QMailStore::NoError) {
+                setLastError(code);
+                qMailLog(Messaging) << "Could not remove extraneous message content:" << ::contentUri(*message);
+            }
+
+            return false;
+        }
+    } else {
+        qMailLog(Messaging) << "Unable to create content manager for scheme:" << message->contentScheme();
+        return false;
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::addMessage(QMailMessageMetaData *metaData,
+                                   QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptAddMessage, this, 
+                                        metaData,
+                                        addedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "addMessage");
+}
+
+bool QMailStorePrivate::removeAccounts(const QMailAccountKey &key,
+                                       QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRemoveAccounts, this, 
+                                        cref(key), 
+                                        deletedAccounts, deletedFolders, deletedMessages), 
+                                   "removeAccounts");
+}
+
+bool QMailStorePrivate::removeFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option,
+                                      QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRemoveFolders, this, 
+                                        cref(key), option, 
+                                        deletedFolders, deletedMessages, modifiedAccountIds),
+                                   "removeFolders");
+}
+
+bool QMailStorePrivate::removeMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option,
+                                       QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRemoveMessages, this, 
+                                        cref(key), option, 
+                                        deletedMessages, modifiedAccountIds, modifiedFolderIds),
+                                   "removeMessages");
+}
+
+bool QMailStorePrivate::updateAccount(QMailAccount *account, QMailAccountConfiguration *config,
+                                      QMailAccountIdList *updatedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateAccount, this, 
+                                        account, config, 
+                                        updatedAccountIds), 
+                                   "updateAccount");
+}
+
+bool QMailStorePrivate::updateAccountConfiguration(QMailAccountConfiguration *config,
+                                                   QMailAccountIdList *updatedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateAccount, this, 
+                                        reinterpret_cast<QMailAccount*>(0), config, 
+                                        updatedAccountIds), 
+                                   "updateAccount");
+}
+
+bool QMailStorePrivate::updateFolder(QMailFolder *folder,
+                                     QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateFolder, this, 
+                                        folder, 
+                                        updatedFolderIds, modifiedAccountIds), 
+                                   "updateFolder");
+}
+
+bool QMailStorePrivate::updateMessage(QMailMessageMetaData *metaData, QMailMessage *message,
+                                      QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, bool *modifiedContent)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateMessage, this, 
+                                        metaData, message, 
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds, modifiedContent), 
+                                   "updateMessage");
+}
+
+bool QMailStorePrivate::updateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, const QMailMessageMetaData &data,
+                                               QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateMessagesMetaData, this, 
+                                        cref(key), cref(properties), cref(data), 
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "updateMessagesMetaData");
+}
+
+bool QMailStorePrivate::updateMessagesMetaData(const QMailMessageKey &key, quint64 status, bool set,
+                                               QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptUpdateMessagesStatus, this, 
+                                        cref(key), status, set,
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "updateMessagesMetaData"); // not 'updateMessagesStatus', due to function name exported by QMailStore
+}
+
+bool QMailStorePrivate::restoreToPreviousFolder(const QMailMessageKey &key,
+                                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRestoreToPreviousFolder, this, 
+                                        cref(key), 
+                                        updatedMessageIds, modifiedFolderIds, modifiedAccountIds), 
+                                   "restoreToPreviousFolder");
+}
+
+bool QMailStorePrivate::purgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids)
+{
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptPurgeMessageRemovalRecords, this, 
+                                        cref(accountId), cref(serverUids)), 
+                                   "purgeMessageRemovalRecords");
+}
+
+int QMailStorePrivate::countAccounts(const QMailAccountKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptCountAccounts, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "countAccounts");
+    return result;
+}
+
+int QMailStorePrivate::countFolders(const QMailFolderKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptCountFolders, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "countFolders");
+    return result;
+}
+
+int QMailStorePrivate::countMessages(const QMailMessageKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptCountMessages, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "countMessages");
+    return result;
+}
+
+int QMailStorePrivate::sizeOfMessages(const QMailMessageKey &key) const
+{
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptSizeOfMessages, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), &result), 
+                           "sizeOfMessages");
+    return result;
+}
+
+QMailAccountIdList QMailStorePrivate::queryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey) const
+{
+    QMailAccountIdList ids;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptQueryAccounts, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(sortKey), &ids), 
+                           "queryAccounts");
+    return ids;
+}
+
+QMailFolderIdList QMailStorePrivate::queryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey) const
+{
+    QMailFolderIdList ids;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptQueryFolders, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(sortKey), &ids), 
+                           "queryFolders");
+    return ids;
+}
+
+QMailMessageIdList QMailStorePrivate::queryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey) const
+{
+    QMailMessageIdList ids;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptQueryMessages, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(sortKey), &ids), 
+                           "queryMessages");
+    return ids;
+}
+
+QMailAccount QMailStorePrivate::account(const QMailAccountId &id) const
+{
+    if (accountCache.contains(id))
+        return accountCache.lookup(id);
+
+    QMailAccount account;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptAccount, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &account), 
+                           "account");
+    return account;
+}
+
+QMailAccountConfiguration QMailStorePrivate::accountConfiguration(const QMailAccountId &id) const
+{
+    QMailAccountConfiguration config;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptAccountConfiguration, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &config), 
+                           "accountConfiguration");
+    return config;
+}
+
+QMailFolder QMailStorePrivate::folder(const QMailFolderId &id) const
+{
+    if (folderCache.contains(id))
+        return folderCache.lookup(id);
+
+    QMailFolder folder;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptFolder, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &folder), 
+                           "folder");
+    return folder;
+}
+
+QMailMessage QMailStorePrivate::message(const QMailMessageId &id) const
+{
+    // Resolve from overloaded member functions:
+    AttemptResult (QMailStorePrivate::*func)(const QMailMessageId&, QMailMessage*, ReadLock&) = &QMailStorePrivate::attemptMessage;
+
+    QMailMessage msg;
+    repeatedly<ReadAccess>(bind(func, const_cast<QMailStorePrivate*>(this), 
+                                cref(id), &msg), 
+                           "message(id)");
+    return msg;
+}
+
+QMailMessage QMailStorePrivate::message(const QString &uid, const QMailAccountId &accountId) const
+{
+    // Resolve from overloaded member functions:
+    AttemptResult (QMailStorePrivate::*func)(const QString&, const QMailAccountId&, QMailMessage*, ReadLock&) = &QMailStorePrivate::attemptMessage;
+
+    QMailMessage msg;
+    repeatedly<ReadAccess>(bind(func, const_cast<QMailStorePrivate*>(this), 
+                                cref(uid), cref(accountId), &msg), 
+                           "message(uid, accountId)");
+    return msg;
+}
+
+QMailMessageMetaData QMailStorePrivate::messageMetaData(const QMailMessageId &id) const
+{
+    if (headerCache.contains(id))
+        return headerCache.lookup(id);
+
+    //if not in the cache, then preload the cache with the id and its most likely requested siblings
+    preloadHeaderCache(id);
+
+    return headerCache.lookup(id);
+}
+
+QMailMessageMetaData QMailStorePrivate::messageMetaData(const QString &uid, const QMailAccountId &accountId) const
+{
+    QMailMessageKey uidKey(QMailMessageKey::serverUid(uid));
+    QMailMessageKey accountKey(QMailMessageKey::parentAccountId(accountId));
+
+    QMailMessageMetaDataList results = messagesMetaData(uidKey & accountKey, allMessageProperties(), QMailStore::ReturnAll);
+    if (!results.isEmpty()) {
+        if (results.count() > 1){
+            qMailLog(Messaging) << "Warning, messageMetaData by uid returned more than 1 result";
+        }
+
+        headerCache.insert(results.first());
+        return results.first();
+    }
+
+    return QMailMessageMetaData();
+}
+
+QMailMessageMetaDataList QMailStorePrivate::messagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option) const
+{
+    QMailMessageMetaDataList metaData;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptMessagesMetaData, const_cast<QMailStorePrivate*>(this), 
+                                cref(key), cref(properties), option, &metaData),
+                           "messagesMetaData");
+    return metaData;
+}
+
+QMailMessageRemovalRecordList QMailStorePrivate::messageRemovalRecords(const QMailAccountId &accountId, const QMailFolderId &folderId) const
+{
+    QMailMessageRemovalRecordList removalRecords;
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptMessageRemovalRecords, const_cast<QMailStorePrivate*>(this), 
+                                cref(accountId), cref(folderId), &removalRecords), 
+                           "messageRemovalRecords(accountId, folderId)");
+    return removalRecords;
+}
+
+bool QMailStorePrivate::registerAccountStatusFlag(const QString &name)
+{
+    if (accountStatusMask(name) != 0)
+        return true;
+
+    static const QString context("accountstatus");
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRegisterStatusBit, this,
+                                        cref(name), cref(context), 64), 
+                                   "registerAccountStatusBit");
+}
+
+quint64 QMailStorePrivate::accountStatusMask(const QString &name) const
+{
+    static QMap<QString, quint64> statusMap;
+    static const QString context("accountstatus");
+
+    return queryStatusMap(name, context, statusMap);
+}
+
+bool QMailStorePrivate::registerFolderStatusFlag(const QString &name)
+{
+    if (folderStatusMask(name) != 0)
+        return true;
+
+    static const QString context("folderstatus");
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRegisterStatusBit, this,
+                                        cref(name), cref(context), 64), 
+                                   "registerFolderStatusBit");
+}
+
+quint64 QMailStorePrivate::folderStatusMask(const QString &name) const
+{
+    static QMap<QString, quint64> statusMap;
+    static const QString context("folderstatus");
+
+    return queryStatusMap(name, context, statusMap);
+}
+
+bool QMailStorePrivate::registerMessageStatusFlag(const QString &name)
+{
+    if (messageStatusMask(name) != 0)
+        return true;
+
+    static const QString context("messagestatus");
+    return repeatedly<WriteAccess>(bind(&QMailStorePrivate::attemptRegisterStatusBit, this,
+                                        cref(name), cref(context), 64), 
+                                   "registerMessageStatusBit");
+}
+
+quint64 QMailStorePrivate::messageStatusMask(const QString &name) const
+{
+    static QMap<QString, quint64> statusMap;
+    static const QString context("messagestatus");
+
+    return queryStatusMap(name, context, statusMap);
+}
+
+quint64 QMailStorePrivate::queryStatusMap(const QString &name, const QString &context, QMap<QString, quint64> &map) const
+{
+    QMap<QString, quint64>::const_iterator it = map.find(name);
+    if (it != map.end())
+        return it.value();
+
+    int result(0);
+    repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptStatusBit, const_cast<QMailStorePrivate*>(this), 
+                                cref(name), cref(context), &result), 
+                           "folderStatusMask");
+    if (result == 0)
+        return 0;
+
+    quint64 maskValue = (1 << (result - 1));
+    map[name] = maskValue;
+    return maskValue;
+}
+
+QMailFolderIdList QMailStorePrivate::folderAncestorIds(const QMailFolderIdList& ids, bool inTransaction, AttemptResult *result) const
+{
+    QMailFolderIdList ancestorIds;
+
+    QMailStorePrivate *self(const_cast<QMailStorePrivate*>(this));
+    if (inTransaction) {
+        // We can't retry this query after a busy error if we're in a transaction
+        ReadLock l(self);
+        *result = self->attemptFolderAncestorIds(ids, &ancestorIds, l);
+    } else {
+        bool ok = repeatedly<ReadAccess>(bind(&QMailStorePrivate::attemptFolderAncestorIds, self,
+                                              cref(ids), &ancestorIds), 
+                                         "folderAncestorIds");
+        if (result)
+            *result = ok ? Success : Failure;
+    }
+
+    return ancestorIds;
+}
+
+void QMailStorePrivate::removeExpiredData(const QMailMessageIdList& messageIds, const QStringList& contentUris, const QMailFolderIdList& folderIds, const QMailAccountIdList& accountIds)
+{
+    foreach (const QMailMessageId& id, messageIds) {
+        headerCache.remove(id);
+    }
+
+    {
+        MutexGuard lock(contentManagerMutex());
+        if (!lock.lock(1000)) {
+            qMailLog(Messaging) << "Unable to acquire message body mutex in removeExpiredData!";
+        } else {
+            foreach (const QString& contentUri, contentUris) {
+                QPair<QString, QString> elements(::uriElements(contentUri));
+
+                if (QMailContentManager *contentManager = QMailContentManagerFactory::create(elements.first)) {
+                    QMailStore::ErrorCode code = contentManager->remove(elements.second);
+                    if (code != QMailStore::NoError) {
+                        setLastError(code);
+                        qMailLog(Messaging) << "Unable to remove expired message content:" << contentUri;
+                        continue;
+                    }
+                } else {
+                    qMailLog(Messaging) << "Unable to create content manager for scheme:" << elements.first;
+                    continue;
+                }
+            }
+        }
+    }
+
+    foreach (const QMailFolderId& id, folderIds) {
+        folderCache.remove(id);
+    }
+
+    foreach (const QMailAccountId& id, accountIds) {
+        accountCache.remove(id);
+    }
+}
+
+template<typename AccessType, typename FunctionType>
+bool QMailStorePrivate::repeatedly(FunctionType func, const QString &description) const
+{
+    static const unsigned int MinRetryDelay = 64;
+    static const unsigned int MaxRetryDelay = 2048;
+    static const unsigned int MaxAttempts = 10;
+
+    // This function calls the supplied function repeatedly, retrying whenever it
+    // returns the DatabaseFailure result and the database's last error is SQLITE_BUSY.
+    // It sleeps between repeated attempts, for increasing amounts of time.
+    // The argument should be an object allowing nullary invocation returning an
+    // AttemptResult value, created with tr1::bind if necessary.
+
+    unsigned int attemptCount = 0;
+    unsigned int delay = MinRetryDelay;
+
+     while (true) {
+        AttemptResult result = evaluate(AccessType(), func, description, const_cast<QMailStorePrivate*>(this));
+
+        if (result == Success) {
+            if (attemptCount > 0) {
+                qMailLog(Messaging) << ::getpid() << "Able to" << qPrintable(description) << "after" << attemptCount << "failed attempts";
+            }
+            return true;
+        } else if (result == Failure) {
+            qMailLog(Messaging) << ::getpid() << "Unable to" << qPrintable(description);
+            if (lastError() == QMailStore::NoError) {
+                setLastError(errorType(AccessType()));
+            }
+            return false;
+        } else { 
+            // result == DatabaseFailure
+            if (queryError() == "Sqlite3BusyErrorNumber") {
+                if (attemptCount < MaxAttempts) {
+                    qMailLog(Messaging) << ::getpid() << "Failed to" << qPrintable(description) << "- busy, pausing to retry";
+
+                    // Pause before we retry
+                    QMail::usleep(delay * 1000);
+                    if (delay < MaxRetryDelay)
+                        delay *= 2;
+
+                    ++attemptCount;
+                } else {
+                    qMailLog(Messaging) << ::getpid() << "Retry count exceeded - failed to" << qPrintable(description);
+                    break;
+                }
+            } else if (queryError() == "Sqlite3ConstraintErrorNumber") {
+                qMailLog(Messaging) << ::getpid() << "Unable to" << qPrintable(description) << "- constraint failure";
+                setLastError(QMailStore::ConstraintFailure);
+                break;
+            } else {
+                qMailLog(Messaging) << ::getpid() << "Unable to" << qPrintable(description) << "- code:" << queryError();
+                break;
+            }
+        }
+    }
+
+    // We experienced a database-related failure
+    if (lastError() == QMailStore::NoError) {
+        setLastError(QMailStore::FrameworkFault);
+    }
+    return false;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::addCustomFields(quint64 id, const QMap<QString, QString> &fields)
+{
+    if (!fields.isEmpty()) {
+        QVariantList customFields;
+        QVariantList customValues;
+
+        // Insert any custom fields belonging to this account
+        QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+        for ( ; it != end; ++it) {
+            customFields.append(QVariant(it.key()));
+            customValues.append(QVariant(it.value()));
+        }
+        // TBD: Add custom fields
+        Q_UNUSED(id);
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::updateCustomFields(quint64 id, const QMap<QString, QString> &fields)
+{
+    QMap<QString, QString> existing;
+
+    {
+        // Find the existing fields
+        // TBD: Put actual code here
+        Q_UNUSED(id);
+    }
+
+    QVariantList obsoleteFields;
+    QVariantList modifiedFields;
+    QVariantList modifiedValues;
+    QVariantList addedFields;
+    QVariantList addedValues;
+
+    // Compare the sets
+    QMap<QString, QString>::const_iterator fend = fields.end(), eend = existing.end();
+    QMap<QString, QString>::const_iterator it = existing.begin();
+    for ( ; it != eend; ++it) {
+        QMap<QString, QString>::const_iterator current = fields.find(it.key());
+        if (current == fend) {
+            obsoleteFields.append(QVariant(it.key()));
+        } else if (*current != *it) {
+            modifiedFields.append(QVariant(current.key()));
+            modifiedValues.append(QVariant(current.value()));
+        }
+    }
+
+    for (it = fields.begin(); it != fend; ++it) {
+        if (existing.find(it.key()) == eend) {
+            addedFields.append(QVariant(it.key()));
+            addedValues.append(QVariant(it.value()));
+        }
+    }
+
+    // TBD: Update custom fields
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::customFields(quint64 id, QMap<QString, QString> *fields)
+{
+    // TBD: Load information about custom fields
+    Q_UNUSED(id);
+    Q_UNUSED(fields);
+
+    return Success;
+}
+
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRemoveAccounts(const QMailAccountKey &key, 
+                                                                          QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages,
+                                                                          Transaction &t)
+{
+    // TBD: Delete accounts
+    Q_UNUSED(key);
+    Q_UNUSED(deletedAccounts);
+    Q_UNUSED(deletedFolders);
+    Q_UNUSED(deletedMessages);
+    Q_UNUSED(t);
+
+    return DatabaseFailure;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRemoveFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option, 
+                                                                         QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts,
+                                                                         Transaction &t)
+{
+    // TBD: Remove folders
+    Q_UNUSED(key);
+    Q_UNUSED(option);
+    Q_UNUSED(deletedFolders);
+    Q_UNUSED(deletedMessages);
+    Q_UNUSED(modifiedAccounts);
+    Q_UNUSED(t);
+
+    return DatabaseFailure;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRemoveMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option, 
+                                                                          QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts, QMailFolderIdList *modifiedFolders,
+                                                                          Transaction &t)
+{
+    // TBD: Remove messages
+    Q_UNUSED(key);
+    Q_UNUSED(option);
+    Q_UNUSED(deletedMessages);
+    Q_UNUSED(modifiedAccounts);
+    Q_UNUSED(modifiedFolders);
+    Q_UNUSED(t);
+
+    return DatabaseFailure;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAccount *account, QMailAccountConfiguration *config, 
+                                                                         QMailAccountIdList *updatedAccountIds,
+                                                                         Transaction &t)
+{
+    Q_UNUSED(t);
+
+    QMailAccountId id(account ? account->id() : config ? config->id() : QMailAccountId());
+    if (!id.isValid())
+        return Failure;
+
+    if (account) {
+        // Update the account cache
+        if (accountCache.contains(id))
+            accountCache.insert(*account);
+    }
+
+    updatedAccountIds->append(id);
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateFolder(QMailFolder *folder, 
+                                                                        QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                        Transaction &t)
+{
+    //check that the parent folder actually exists
+    if(!checkPreconditions(*folder, true))
+        return Failure;
+
+    QMailFolderId parentFolderId;
+    QMailAccountId parentAccountId;
+
+    // TBD: Update folder
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(t);
+
+    //update the folder cache
+    if (folderCache.contains(folder->id()))
+        folderCache.insert(*folder);
+
+    updatedFolderIds->append(folder->id());
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateMessage(QMailMessageMetaData *metaData, QMailMessage *message, 
+                                                                         QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, bool *modifiedContent,
+                                                                         Transaction &t)
+{
+    if (!metaData->id().isValid())
+        return Failure;
+
+    QMailAccountId parentAccountId;
+    QMailFolderId parentFolderId;
+    QString contentUri;
+    QMailFolderIdList folderIds;
+
+    QMailMessageKey::Properties updateProperties(QMailStorePrivate::updatableMessageProperties());
+    QVariantList extractedValues;
+
+    // Do we actually have an update to perform?
+    bool updateContent(message && message->contentModified());
+    if (metaData->dataModified() || updateContent) {
+        // Find the existing properties 
+        {
+            // TBD: Query database
+            Q_UNUSED(t);
+        }
+
+        if (updateContent) {
+            updateProperties |= QMailMessageKey::ContentIdentifier;
+
+            bool addContent(updateContent && contentUri.isEmpty());
+            if (addContent)
+                updateProperties |= QMailMessageKey::ContentScheme;
+
+            // We need to update the content for this message
+            if (metaData->contentScheme().isEmpty()) {
+                // Use the default storage scheme
+                metaData->setContentScheme(defaultContentScheme());
+            }
+
+            MutexGuard lock(contentManagerMutex());
+            if (!lock.lock(1000)) {
+                qMailLog(Messaging) << "Unable to acquire message body mutex in updateMessage!";
+                return Failure;
+            } 
+
+            if (QMailContentManager *contentManager = QMailContentManagerFactory::create(metaData->contentScheme())) {
+                if (addContent) {
+                    // We need to add this content to the message
+                    QMailStore::ErrorCode code = contentManager->add(message);
+                    if (code != QMailStore::NoError) {
+                        setLastError(code);
+                        qMailLog(Messaging) << "Unable to add message content to URI:" << ::contentUri(*metaData);
+                        return Failure;
+                    }
+                } else {
+                    QMailStore::ErrorCode code = contentManager->update(message);
+                    if (code != QMailStore::NoError) {
+                        setLastError(code);
+                        qMailLog(Messaging) << "Unable to update message content:" << contentUri;
+                        return Failure;
+                    }
+                }
+
+                metaData->setContentIdentifier(message->contentIdentifier());
+            } else {
+                qMailLog(Messaging) << "Unable to create content manager for scheme:" << metaData->contentScheme();
+                return Failure;
+            }
+        }
+
+        // Don't update the previous parent folder if it isn't set
+        if (!metaData->previousParentFolderId().isValid())
+            updateProperties &= ~QMailMessageKey::PreviousParentFolderId;
+
+        extractedValues = messageValues(updateProperties, *metaData);
+
+        {
+            // TBD: update exctracted values
+        }
+
+        if (metaData->customFieldsModified()) {
+            AttemptResult result = updateCustomFields(metaData->id().toULongLong(), metaData->customFields());
+            if (result != Success)
+                return result;
+
+            updateProperties |= QMailMessageKey::Custom;
+        }
+    }
+
+    if (parentAccountId.isValid()) {
+        // The message is now up-to-date with data store
+        metaData->setUnmodified();
+
+        if (headerCache.contains(metaData->id())) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(metaData->id());
+            updateMessageValues(updateProperties, extractedValues, metaData->customFields(), cachedMetaData);
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+        }
+
+        updatedMessageIds->append(metaData->id());
+        *modifiedFolderIds = folderIds;
+
+        if (metaData->parentAccountId().isValid())
+            modifiedAccountIds->append(metaData->parentAccountId());
+        if (parentAccountId.isValid()) {
+            if (parentAccountId != metaData->parentAccountId())
+                modifiedAccountIds->append(parentAccountId);
+        }
+    }
+
+    *modifiedContent = updateContent;
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::affectedByMessageIds(const QMailMessageIdList &messages, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const
+{
+    AttemptResult result;
+
+    // Find the set of folders whose contents are modified by this update
+    QMailFolderIdList messageFolderIds;
+
+    QMailStorePrivate *self(const_cast<QMailStorePrivate*>(this));
+    {
+        ReadLock l(self);
+        result = self->attemptMessageFolderIds(QMailMessageKey::id(messages), &messageFolderIds, l);
+    }
+
+    if (result != Success)
+        return result;
+
+    return affectedByFolderIds(messageFolderIds, folderIds, accountIds);
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::affectedByFolderIds(const QMailFolderIdList &folders, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const
+{
+    AttemptResult result;
+
+    // Any ancestor folders are also modified
+    QMailFolderIdList ancestorIds;
+
+    QMailStorePrivate *self(const_cast<QMailStorePrivate*>(this));
+    {
+        ReadLock l(self);
+        result = self->attemptFolderAncestorIds(folders, &ancestorIds, l);
+    }
+
+    if (result != Success)
+        return result;
+
+    *folderIds = folders + ancestorIds;
+
+    // Find the set of accounts whose contents are modified by this update
+    ReadLock l(self);
+    result = self->attemptFolderAccountIds(QMailFolderKey::id(*folderIds), accountIds, l);
+    return result;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &props, const QMailMessageMetaData &data, 
+                                                                                  QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                                  Transaction &t) 
+{
+    //do some checks first
+    if (props & QMailMessageKey::Id) {
+        qMailLog(Messaging) << "Updating of messages IDs is not supported";
+        return Failure;
+    }
+    
+    QMailMessageKey::Properties properties(props);
+
+    if (properties & QMailMessageKey::ParentFolderId) {
+        MailFolderUri folderUri(data.parentFolderId());
+        if (!uriExists(folderUri)) {
+            qMailLog(Messaging) << "Update of messages failed. Parent folder does not exist";
+            return Failure;
+        }
+    }
+
+    // TBD: Update message metadata
+    Q_UNUSED(key);
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(t);
+
+    QVariantList extractedValues;
+
+    // Update the header cache
+    foreach (const QMailMessageId& id, *updatedMessageIds) {
+        if (headerCache.contains(id)) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(id);
+            updateMessageValues(properties, extractedValues, data.customFields(), cachedMetaData);
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateMessagesStatus(const QMailMessageKey &key, quint64 status, bool set, 
+                                                                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                                                Transaction &t)
+{
+    //get the valid ids
+    *updatedMessageIds = queryMessages(key, QMailMessageSortKey());
+
+    // TBD: Update status
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(t);
+
+    // Update the header cache
+    foreach (const QMailMessageId& id, *updatedMessageIds) {
+        if (headerCache.contains(id)) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(id);
+            quint64 newStatus = cachedMetaData.status();
+            newStatus = set ? (newStatus | status) : (newStatus & ~status);
+            cachedMetaData.setStatus(newStatus);
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRestoreToPreviousFolder(const QMailMessageKey &key, 
+                                                                                   QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                                                   Transaction &t)
+{
+    // TBD: Restore messages to previous folder
+    Q_UNUSED(key);
+    Q_UNUSED(modifiedFolderIds);
+    Q_UNUSED(modifiedAccountIds);
+    Q_UNUSED(t);
+
+    // Update the header cache
+    foreach (const QMailMessageId &id, *updatedMessageIds) {
+        if (headerCache.contains(id)) {
+            QMailMessageMetaData cachedMetaData = headerCache.lookup(id);
+            cachedMetaData.setParentFolderId(cachedMetaData.previousParentFolderId());
+            cachedMetaData.setPreviousParentFolderId(QMailFolderId());
+            cachedMetaData.setUnmodified();
+            headerCache.insert(cachedMetaData);
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptPurgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids,
+                                                                                      Transaction &t)
+{
+    QMailMessageIdList removalIds;
+
+    // TBD: Purge remove records
+    Q_UNUSED(accountId);
+    Q_UNUSED(serverUids);
+    Q_UNUSED(t);
+
+    return Success;
+}
+
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptSizeOfMessages(const QMailMessageKey &key, 
+                                                                          int *result, 
+                                                                          ReadLock &)
+{
+    // TBD: Count overal size of the messages
+    Q_UNUSED(key);
+    Q_UNUSED(result);
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(const QMailAccountId &id, 
+                                                                                QMailAccountConfiguration *result, 
+                                                                                ReadLock &)
+{
+    // TBD: Find any configuration fields for this account
+
+    // TBD: Fill account configuration with information
+
+
+    result->setId(id);
+    result->setModified(false);
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessage(const QString &uid, const QMailAccountId &accountId, 
+                                                                   QMailMessage *result, 
+                                                                   ReadLock &lock)
+{
+    quint64 id(0);
+
+    {
+        // TBD: Search for the message with particular server UID
+        Q_UNUSED(uid);
+        Q_UNUSED(accountId);
+    }
+            
+    if (id == 0) {
+        return Failure;
+    }
+
+    return attemptMessage(QMailMessageId(id), result, lock);
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessagesMetaData(const QMailMessageKey& key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option,
+                                                                            QMailMessageMetaDataList *result,
+                                                                            ReadLock &)
+{
+    if (properties == QMailMessageKey::Custom) {
+        // We're only selecting custom fields
+
+        // TBD: Search by custom fields
+        QMap<QString, QStringList> fields;
+        int maxLen = 0;
+        Q_UNUSED(key);
+
+        for (int i = 0; i < maxLen; ++i)
+            result->append(QMailMessageMetaData());
+
+        // Add all pairs to the results
+        foreach (const QString &name, fields.keys()) {
+            QMailMessageMetaDataList::iterator it = result->begin();
+            foreach (const QString &value, fields[name]) {
+                (*it).setCustomField(name, value);
+                ++it;
+            }
+        }
+
+        QMailMessageMetaDataList::iterator it = result->begin(), end = result->end();
+        for ( ; it != end; ++it)
+            (*it).setCustomFieldsModified(false);
+    } else {
+        bool includeCustom(properties & QMailMessageKey::Custom);
+        if (includeCustom && (option == QMailStore::ReturnDistinct)) {
+            qWarning() << "Warning: Distinct-ness is not supported with custom fields!";
+        }
+
+        QMailMessageKey::Properties props(properties);
+
+        bool removeId(false);
+        if (includeCustom && !(props & QMailMessageKey::Id)) {
+            // We need the ID to match against the custom table
+            props |= QMailMessageKey::Id;
+            removeId = true;
+        }
+
+        {
+            // TBD: Search messages by fields
+        }
+
+        if (includeCustom) {
+            QMailMessageMetaDataList::iterator it = result->begin(), end = result->end();
+            for ( ; it != end; ++it) {
+                // Add the custom fields to the record
+                QMap<QString, QString> fields;
+                AttemptResult attemptResult = customFields((*it).id().toULongLong(), &fields);
+                if (attemptResult != Success)
+                    return attemptResult;
+
+                QMailMessageMetaData &metaData(*it);
+                metaData.setCustomFields(fields);
+                metaData.setCustomFieldsModified(false);
+
+                if (removeId)
+                    metaData.setId(QMailMessageId());
+            }
+        }
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessageRemovalRecords(const QMailAccountId &accountId, const QMailFolderId &folderId, 
+                                                                                 QMailMessageRemovalRecordList *result, 
+                                                                                 ReadLock &)
+{
+    // TBD: Search for deleted messages
+    Q_UNUSED(accountId);
+    Q_UNUSED(folderId);
+    Q_UNUSED(result);
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessageFolderIds(const QMailMessageKey &key, 
+                                                                            QMailFolderIdList *result, 
+                                                                            ReadLock &)
+{
+    // TBD: Look for message ID
+    Q_UNUSED(key);
+    Q_UNUSED(result);
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptFolderAccountIds(const QMailFolderKey &key, 
+                                                                            QMailAccountIdList *result, 
+                                                                            ReadLock &)
+{
+    // TBD: Look for message folder ID
+    Q_UNUSED(key);
+    Q_UNUSED(result);
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptFolderAncestorIds(const QMailFolderIdList &ids, 
+                                                                             QMailFolderIdList *result, 
+                                                                             ReadLock &)
+{
+    // TBD: Look for ancestor message folder ID
+    Q_UNUSED(ids);
+    Q_UNUSED(result);
+
+    return Success;
+}
+
+void QMailStorePrivate::preloadHeaderCache(const QMailMessageId& id) const
+{
+    QMailMessageIdList idBatch;
+    idBatch.append(id);
+
+    int index = lastQueryMessageResult.indexOf(id);
+    if (index != -1) {
+        // Preload based on result of last call to queryMessages
+        int count = 1;
+
+        QMailMessageIdList::const_iterator begin = lastQueryMessageResult.begin();
+        QMailMessageIdList::const_iterator end = lastQueryMessageResult.end();
+        QMailMessageIdList::const_iterator lowIt = begin + index;
+        QMailMessageIdList::const_iterator highIt = lowIt;
+
+        bool ascend(true);
+        bool descend(lowIt != begin);
+
+        while ((count < (QMailStorePrivate::lookAhead * 2)) && (ascend || descend)) {
+            if (ascend) {
+                ++highIt;
+                if (highIt == end) {
+                    ascend = false;
+                } else  {
+                    if (!headerCache.contains(*highIt)) {
+                        idBatch.append(*highIt);
+                        ++count;
+                    } else {
+                        // Most likely, a sequence in the other direction will be more useful
+                        ascend = false;
+                    }
+                }
+            }
+
+            if (descend) {
+                --lowIt;
+                if (!headerCache.contains(*lowIt)) {
+                    idBatch.prepend(*lowIt);
+                    ++count;
+
+                    if (lowIt == begin) {
+                        descend = false;
+                    }
+                } else {
+                    // Most likely, a sequence in the other direction will be more useful
+                    descend = false;
+                }
+            }
+        }
+    } else {
+        // Don't bother preloading - if there is a query result, we have now searched outside it;
+        // we should consider it to have outlived its usefulness
+        if (!lastQueryMessageResult.isEmpty())
+            lastQueryMessageResult = QMailMessageIdList();
+    }
+
+    QMailMessageMetaData result;
+    QMailMessageKey key(QMailMessageKey::id(idBatch));
+    foreach (const QMailMessageMetaData& metaData, messagesMetaData(key, allMessageProperties(), QMailStore::ReturnAll)) {
+        if (metaData.id().isValid()) {
+            headerCache.insert(metaData);
+            if (metaData.id() == id)
+                result = metaData;
+        }
+    }
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptStatusBit(const QString &name, const QString &context, 
+                                                                     int *result, 
+                                                                     ReadLock &)
+{
+    // TBD: Find out wheither this status bit is present
+    Q_UNUSED(name);
+    Q_UNUSED(context);
+    Q_UNUSED(result);
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptRegisterStatusBit(const QString &name, const QString &context, int maximum, 
+                                                                             Transaction &t)
+{
+    int highest = 0;
+
+    // TBD: Find out the highest bit
+    Q_UNUSED(name);
+    Q_UNUSED(context);
+    Q_UNUSED(t);
+
+    if (highest == maximum) {
+        return Failure;
+    } else {
+        // TBD: Add new status bit
+    }
+
+    t.commit();
+
+    return Success;
+}
+
+bool QMailStorePrivate::checkPreconditions(const QMailFolder& folder, bool update)
+{
+    //if the parent is valid, check that it exists 
+    //if the account is valid, check that is exists 
+
+    if(!update)
+    {
+        if(folder.id().isValid())
+        {
+            qMailLog(Messaging) << "Folder exists, use update instead of add.";
+            return false;
+        }
+    }
+    else 
+    {
+        if(!folder.id().isValid())
+        {
+            qMailLog(Messaging) << "Folder does not exist, use add instead of update.";
+            return false;
+        }
+
+        if(folder.parentFolderId().isValid() && folder.parentFolderId() == folder.id())
+        {
+            qMailLog(Messaging) << "A folder cannot be a child to itself";
+            return false;
+        }
+    }
+
+    if(folder.parentFolderId().isValid())
+    {
+        MailFolderUri folderUri(folder.parentFolderId());
+        if(!uriExists(folderUri))
+        {
+            qMailLog(Messaging) << "Parent folder does not exist!";
+            return false;
+        }
+    }
+
+    if(folder.parentAccountId().isValid())
+    {
+        MailAccountUri accountUri(folder.parentAccountId());
+        if(!uriExists(accountUri))
+        {
+            qMailLog(Messaging) << "Parent account does not exist!";
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool QMailStorePrivate::deleteMessages(const QMailMessageKey& key, 
+                                       QMailStore::MessageRemovalOption option, 
+                                       QMailMessageIdList& deletedMessages, 
+                                       QStringList& expiredContent, 
+                                       QMailAccountIdList& modifiedAccounts, 
+                                       QMailFolderIdList& modifiedFolders)
+{
+    // TBD: Delete messages
+    Q_UNUSED(key);
+    Q_UNUSED(option);
+    Q_UNUSED(deletedMessages);
+    Q_UNUSED(expiredContent);
+    Q_UNUSED(modifiedAccounts);
+    Q_UNUSED(modifiedFolders);
+
+    return true;
+}
+
+bool QMailStorePrivate::deleteFolders(const QMailFolderKey& key, 
+                                      QMailStore::MessageRemovalOption option, 
+                                      QMailFolderIdList& deletedFolders, 
+                                      QMailMessageIdList& deletedMessages, 
+                                      QStringList& expiredContent, 
+                                      QMailAccountIdList& modifiedAccounts)
+{
+    // TBD: Delete folders, subfolders and all messages
+    Q_UNUSED(key);
+    Q_UNUSED(option);
+    Q_UNUSED(deletedFolders);
+    Q_UNUSED(deletedMessages);
+    Q_UNUSED(expiredContent);
+    Q_UNUSED(modifiedAccounts);
+
+    return true;
+}
+
+bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key, 
+                                       QMailAccountIdList& deletedAccounts, 
+                                       QMailFolderIdList& deletedFolders, 
+                                       QMailMessageIdList& deletedMessages, 
+                                       QStringList& expiredContent)
+{
+    // TBD: Delete accounts, folders, subfolders and all messages
+    Q_UNUSED(key);
+    Q_UNUSED(deletedAccounts);
+    Q_UNUSED(deletedFolders);
+    Q_UNUSED(deletedMessages);
+    Q_UNUSED(expiredContent);
+
+    return true;
+}
+
+void QMailStorePrivate::emitIpcNotification(QMailStoreImplementation::AccountUpdateSignal signal, const QMailAccountIdList &ids)
+{
+    if ((signal == &QMailStore::accountsUpdated) || (signal == &QMailStore::accountsRemoved)) {
+        foreach (const QMailAccountId &id, ids)
+            accountCache.remove(id);
+    }
+
+    QMailStoreImplementation::emitIpcNotification(signal, ids);
+}
+
+void QMailStorePrivate::emitIpcNotification(QMailStoreImplementation::FolderUpdateSignal signal, const QMailFolderIdList &ids)
+{
+    if ((signal == &QMailStore::foldersUpdated) || (signal == &QMailStore::foldersRemoved)) {
+        foreach (const QMailFolderId &id, ids)
+            folderCache.remove(id);
+    }
+
+    QMailStoreImplementation::emitIpcNotification(signal, ids);
+}
+
+void QMailStorePrivate::emitIpcNotification(QMailStoreImplementation::MessageUpdateSignal signal, const QMailMessageIdList &ids)
+{
+    if ((signal == &QMailStore::messagesUpdated) || (signal == &QMailStore::messagesRemoved)) {
+        foreach (const QMailMessageId &id, ids)
+            headerCache.remove(id);
+    }
+
+    QMailStoreImplementation::emitIpcNotification(signal, ids);
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddMessage(QMailMessageMetaData *metaData,
+                                                                      QMailMessageIdList *addedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                      Transaction &t)
+{
+    Q_UNUSED(t);
+
+    if (!metaData->parentFolderId().isValid()) {
+        qMailLog(Messaging) << "Unable to add message. Invalid parent folder id";
+        return Failure;
+    }
+
+    MailMessageUri messageUri;
+    MailFolderUri  parentFolderUri(metaData->parentFolderId());
+    MailAccountUri parentAccountUri(metaData->parentAccountId());
+
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT {\n"
+    "%1 rdf:type nmo:Email ;\n"
+    "   nie:isLogicalPartOf %2 ;\n"
+    "   nmo:sender [\n"
+    "   rdf:type nco:Contact ;\n"
+    "       nco:fullname \"%3\" ; \n"
+    "       nco:hasEmailAddress <mailto:%4> ] ;\n"
+    + nmoRecipients(metaData->to()) +
+    "   nmo:messageSubject \"%5\" ;\n"
+    "   nmo:sentDate \"%6\"^^xsd:dateTime ;\n"
+    "   nmo:status \"%7\"^^xsd:integer ;\n"
+    "   nie:relatedTo %8 ;\n"
+    "   nie:isStoredAs [\n"
+    "       rdf:type nie:DataObject ;\n"
+    "       nie:dataSource <%9> ] ;\n"
+    "   nmo:messageId \"%10\" ;\n"
+    "   nie:contentSize \"%11\"^^xsd:integer ;\n"
+    "   nie:mimeType \"%12\" ;\n"
+    "   nmo:inReplyTo \"%13\" ;\n"
+    "   nmo:messageHeader [\n"
+    "       rdf:type nmo:MessageHeader ;\n"
+    "       nmo:headerName \"responseType\" ;\n"
+    "       nmo:headerValue \"%14\" ] ;\n"
+    "   nmo:receivedDate \"%15\"^^xsd:dateTime .\n"
+    "}").arg(messageUri.uri())
+        .arg(parentFolderUri.uri())
+        .arg(metaData->from().name())
+        .arg(metaData->from().address())
+        .arg(metaData->subject())
+        .arg(QMailTimeStamp(metaData->date()).toLocalTime().toString())
+        .arg(static_cast<int>(metaData->status()))
+        .arg(parentAccountUri.uri())
+        .arg(::contentUri(*metaData))
+        .arg(metaData->serverUid())
+        .arg(metaData->size())
+        .arg(static_cast<int>(metaData->content()))
+        .arg(metaData->inResponseTo().toULongLong())
+        .arg(metaData->responseType())
+        .arg(QMailTimeStamp(metaData->receivedDate()).toLocalTime().toString()));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    qDebug() << "Query succeeded";
+    metaData->setId(QMailMessageId(messageUri.id()));
+
+    addedMessageIds->append(metaData->id());
+    *modifiedFolderIds = QMailFolderIdList() << metaData->parentFolderId();
+    if (metaData->parentAccountId().isValid())
+        modifiedAccountIds->append(metaData->parentAccountId());
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddFolder(QMailFolder *folder,
+                                                                     QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                                     Transaction &t)
+{
+    Q_UNUSED(t);
+
+    //check that the parent folder actually exists
+    if (!checkPreconditions(*folder))
+        return Failure;
+
+    MailFolderUri folderUri;
+    MailFolderUri parentFolderUri(folder->parentFolderId());
+    MailAccountUri parentAccountUri(folder->parentAccountId());
+
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "%1 rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName \"%2\" ; \n"
+    "   nie:isLogicalPartOf %3 ; \n"
+    "   nie:relatedTo %4 ; \n"
+    "   nmo:folderDisplayName \"%5\" ; \n"
+    "   nmo:status \"%6\"^^xsd:integer ; \n"
+    "   nmo:serverCount \"%7\"^^xsd:integer ; \n"
+    "   nmo:serverUnreadCount \"%8\"^^xsd:integet . \n"
+    "}").arg(folderUri.uri())
+        .arg(folder->path())
+        .arg(parentFolderUri.uri())
+        .arg(parentAccountUri.uri())
+        .arg(folder->displayName())
+        .arg(folder->status())
+        .arg(folder->serverCount())
+        .arg(folder->serverUnreadCount()));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    qDebug() << "Query succeeded";
+    folder->setId(QMailFolderId(folderUri.id()));
+
+    // TBD: Update folder links also
+
+    addedFolderIds->append(folder->id());
+    if (folder->parentAccountId().isValid())
+        modifiedAccountIds->append(folder->parentAccountId());
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config,
+                                                                      QMailAccountIdList *addedAccountIds,
+                                                                      Transaction &t)
+{
+    Q_UNUSED(config);
+    Q_UNUSED(t);
+
+    MailAccountUri accountUri;
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "%1 rdf:type nmo:Mailbox ; \n"
+    "   nmo:accountName \"%2\" ; \n"
+    "   nmo:status \"%3\"^^xsd:integer ; \n"
+    "   nmo:signature \"%4\" ; \n"
+    "   nmo:fromAddress [ \n"
+    "       rdf:type nco:EmailAddress ; \n"
+    "       nco:emailAddress \"%5\" ] . \n"
+    "}").arg(accountUri.uri())
+        .arg(account->name())
+        .arg(account->status())
+        .arg(account->signature())
+        .arg(account->fromAddress().toString(true)));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    qDebug() << "Query succeeded";
+    account->setId(QMailAccountId(accountUri.id()));
+
+    addedAccountIds->append(account->id());
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAccountId &id,
+                                                                   QMailAccount *result,
+                                                                   ReadLock &)
+{
+    MailAccountUri messageUri(id);
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?name ?signature ?fromAddress \n"
+    "WHERE { \n"
+    "%1 rdf:type nmo:Mailbox ; \n"
+    "   nmo:accountName ?name ; \n"
+//    "   nmo:status ?status ; \n"
+    "   nmo:signature ?signature ; \n"
+    "   nmo:fromAddress [ \n"
+    "       rdf:type nco:EmailAddress ; \n"
+    "       nco:emailAddress ?fromAddress ] . \n"
+    "}").arg(messageUri.uri()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+    Q_ASSERT(!res.end());
+
+    *result = extractAccount(id, res.fetchRow());
+
+    // Update cache
+    accountCache.insert(*result);
+    return Success;
+}
+
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptFolder(const QMailFolderId &id,
+                                                                  QMailFolder *result,
+                                                                  ReadLock &)
+{
+    MailFolderUri folderUri(id);
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?name ?parentFolder ?parentAccount ?displayName \n"
+    "WHERE { \n"
+    "%1 rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName ?name ; \n"
+    "   nie:isLogicalPartOf ?parentFolder ; \n"
+    "   nie:relatedTo ?parentAccount ; \n"
+    "   nmo:folderDisplayName ?displayName ; \n"
+//    "   nmo:status ?status ; \n"
+//    "   nmo:serverCount ?serverCount ; \n"
+//    "   nmo:serverUnreadCount ?serverUnreadCount . \n"
+    "}").arg(folderUri.uri()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+    Q_ASSERT(!res.end());
+
+    *result = extractFolder(id, res.fetchRow());
+
+    // Update cache
+    folderCache.insert(*result);
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptMessage(const QMailMessageId &id,
+                                                                   QMailMessage *result,
+                                                                   ReadLock &)
+{
+    if (!id.isValid())
+        return Failure;
+
+    MailMessageUri messageUri(id);
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?fullName ?mailAddress \n"
+    "WHERE { \n"
+    "%1 rdf:type nmo:Email ; \n"
+    "   nmo:recipient [ \n"
+    "       rdf:type nco:Contact ; \n"
+    "       nco:fullname ?fullName ; \n"
+    "       nco:hasEmailAddress ?mailAddress ] \n"
+    "}").arg(messageUri.uri()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    QList<QMailAddress> recipients;
+    while (!res.end())
+    {
+        QStringList row = res.fetchRow();
+        recipients.push_back(QMailAddress(row.at(0), row.at(1)));
+    }
+
+    query.prepare(QString(
+    "SELECT ?folderId ?senderFullName ?senderEmailAddress ?messageSubject ?sentDate ?status ?accountId ?dataSource ?uid ?contentSize ?mimeType ?inReplyTo ?headerValue ?receivedDate \n"
+    "WHERE { \n"
+    "%1 rdf:type nmo:Email ;\n"
+    "   nie:isLogicalPartOf ?folderId ;\n"
+    "   nmo:sender [\n"
+    "       rdf:type nco:Contact ;\n"
+    "       nco:fullname ?senderFullName ; \n"
+    "       nco:hasEmailAddress ?senderEmailAddress ] ;\n"
+    "   nmo:messageSubject ?messageSubject ;\n"
+    "   nmo:sentDate ?sentDate ;\n"
+    "   nmo:status ?status ;\n"
+    "   nie:relatedTo ?accountId ;\n"
+    "   nie:isStoredAs [\n"
+    "       rdf:type nie:DataObject ;\n"
+    "       nie:dataSource ?dataSource ] ;\n"
+    "   nmo:messageId ?uid ;\n"
+    "   nie:contentSize ?contentSize ;\n"
+    "   nie:mimeType ?mimeType ;\n"
+    "   nmo:inReplyTo ?inReplyTo ;\n"
+    "       nmo:messageHeader [\n"
+    "       rdf:type nmo:MessageHeader ;\n"
+    "       nmo:headerName \"responseType\" ;\n"
+    "       nmo:headerValue ?headerValue ] ;\n"
+    "   nmo:receivedDate ?receivedDate .\n"
+    "}").arg(messageUri.uri()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    res = query.result();
+    Q_ASSERT(!res.end());
+
+    QMailMessage message;
+    message.setId(id);
+    extractMessageMetaData(res.fetchRow(), &message);
+    message.setTo(recipients);
+
+    *result = message;
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey,
+                                                                         QMailAccountIdList *ids,
+                                                                         ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyQuery(key, sortKey));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult result = query.result();
+
+    ids->clear();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        ids->append(IdFromUri<QMailAccountId>(row.first()));
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey,
+                                                                        QMailFolderIdList *ids,
+                                                                        ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyQuery(key, sortKey));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult result = query.result();
+
+    ids->clear();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        ids->append(IdFromUri<QMailFolderId>(row.first()));
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey,
+                                                                         QMailMessageIdList *ids,
+                                                                         ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyQuery(key, sortKey));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult result = query.result();
+
+    ids->clear();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        ids->append(IdFromUri<QMailMessageId>(row.first()));
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountAccounts(const QMailAccountKey &key, int *result,
+                                                                         ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyCount(key));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    Q_ASSERT(!res.end());
+
+    *result = res.fetchRow().first().toInt();
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountFolders(const QMailFolderKey &key, int *result,
+                                                                        ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyCount(key));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    Q_ASSERT(!res.end());
+
+    *result = res.fetchRow().first().toInt();
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountMessages(const QMailMessageKey &key,
+                                                                         int *result,
+                                                                         ReadLock &)
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyCount(key));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return Failure;
+    }
+
+    SparqlResult res = query.result();
+
+    Q_ASSERT(!res.end());
+
+    *result = res.fetchRow().first().toInt();
+
+    return Success;
+}
diff --git a/src/libraries/qtopiamail/qmailstore_sparql.h b/src/libraries/qtopiamail/qmailstore_sparql.h
new file mode 100644
index 0000000..fe05e08
--- /dev/null
+++ b/src/libraries/qtopiamail/qmailstore_sparql.h
@@ -0,0 +1,470 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMAILSTORE_P_H
+#define QMAILSTORE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt Extended API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qmailstoreimplementation_p.h"
+#include "sparqldatabase.h"
+
+#include <QCache>
+
+//#define QMAILSTORE_LOG_SQL //define to enable SQL query logging
+//#define QMAILSTORE_USE_RTTI //define if RTTI is available to assist debugging
+
+#ifdef QMAILSTORE_USE_RTTI
+#include <typeinfo>
+#endif
+
+class ProcessMutex;
+class ProcessReadLock;
+class SparqlResult;
+class SparqlQuery;
+
+class QMailStorePrivate : public QMailStoreImplementation
+{
+    Q_OBJECT
+
+public:
+    typedef QMap<QMailMessageKey::Property, QString> MessagePropertyMap;
+    typedef QList<QMailMessageKey::Property> MessagePropertyList;
+
+    class Transaction;
+    class ReadLock;
+    class Key;
+
+    struct ReadAccess {};
+    struct WriteAccess {};
+
+    QMailStorePrivate(QMailStore* parent);
+    ~QMailStorePrivate();
+
+    virtual bool initStore();
+    void clearContent();
+
+    bool addAccount(QMailAccount *account, QMailAccountConfiguration *config,
+                    QMailAccountIdList *addedAccountIds);
+
+    bool addFolder(QMailFolder *f,
+                   QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool addMessage(QMailMessage *m,
+                    QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool addMessage(QMailMessageMetaData *m,
+                    QMailMessageIdList *addedMessageIds, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool removeAccounts(const QMailAccountKey &key,
+                        QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool removeFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option,
+                       QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool removeMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option,
+                        QMailMessageIdList *deletedMessages, QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool updateAccount(QMailAccount *account, QMailAccountConfiguration* config,
+                       QMailAccountIdList *updatedAccountIds);
+
+    bool updateAccountConfiguration(QMailAccountConfiguration* config,
+                                    QMailAccountIdList *updatedAccountIds);
+
+    bool updateFolder(QMailFolder* f,
+                      QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool updateMessage(QMailMessageMetaData *metaData, QMailMessage *mail,
+                       QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, bool *modifiedContent);
+
+    bool updateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, const QMailMessageMetaData &data,
+                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool updateMessagesMetaData(const QMailMessageKey &key, quint64 messageStatus, bool set,
+                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool restoreToPreviousFolder(const QMailMessageKey &key,
+                                 QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds);
+
+    bool purgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids);
+
+    int countAccounts(const QMailAccountKey &key) const;
+    int countFolders(const QMailFolderKey &key) const;
+    int countMessages(const QMailMessageKey &key) const;
+
+    int sizeOfMessages(const QMailMessageKey &key) const;
+
+    QMailAccountIdList queryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey) const;
+    QMailFolderIdList queryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey) const;
+    QMailMessageIdList queryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey) const;
+
+    QMailAccount account(const QMailAccountId &id) const;
+    QMailAccountConfiguration accountConfiguration(const QMailAccountId &id) const;
+
+    QMailFolder folder(const QMailFolderId &id) const;
+
+    QMailMessage message(const QMailMessageId &id) const;
+    QMailMessage message(const QString &uid, const QMailAccountId &accountId) const;
+
+    QMailMessageMetaData messageMetaData(const QMailMessageId &id) const;
+    QMailMessageMetaData messageMetaData(const QString &uid, const QMailAccountId &accountId) const;
+    QMailMessageMetaDataList messagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option) const;
+    QMailMessageRemovalRecordList messageRemovalRecords(const QMailAccountId &parentAccountId, const QMailFolderId &parentFolderId) const;
+
+    bool registerAccountStatusFlag(const QString &name);
+    quint64 accountStatusMask(const QString &name) const;
+
+    bool registerFolderStatusFlag(const QString &name);
+    quint64 folderStatusMask(const QString &name) const;
+
+    bool registerMessageStatusFlag(const QString &name);
+    quint64 messageStatusMask(const QString &name) const;
+
+    static QString expandValueList(const QVariantList& valueList);
+    static QString expandValueList(int valueCount);
+
+    template<typename ValueType>
+    static ValueType extractValue(const QVariant& var, const ValueType &defaultValue = ValueType());
+
+private:
+    friend class ReadLock;
+
+    enum AttemptResult { Success = 0, Failure, DatabaseFailure };
+    
+    static ProcessMutex& contentManagerMutex(void);
+
+    ProcessMutex& databaseMutex(void) const;
+    ProcessReadLock& databaseReadLock(void) const;
+
+    static const MessagePropertyMap& messagePropertyMap();
+    static const MessagePropertyList& messagePropertyList();
+
+    static const QMailMessageKey::Properties &updatableMessageProperties();
+    static const QMailMessageKey::Properties &allMessageProperties();
+
+    bool containsProperty(const QMailMessageKey::Property& p, const QMailMessageKey& key) const;
+    bool containsProperty(const QMailMessageSortKey::Property& p, const QMailMessageSortKey& sortkey) const;
+
+    int databaseIdentifier(int n) const;
+
+    bool setupStandardFolder(QMailFolder::StandardFolder folder, const QString& name);
+
+    void setQueryError(const SparqlQuery& query, const QString& description = QString());
+    QString queryError() const;
+    void clearQueryError(void);
+
+    bool uriExists(const QString& uri);
+
+    bool checkPreconditions(const QMailFolder& folder, bool update = false);
+
+    void preloadHeaderCache(const QMailMessageId& id) const;
+
+    QMailFolderIdList folderAncestorIds(const QMailFolderIdList& ids, bool inTransaction, AttemptResult *result) const;
+
+    quint64 queryStatusMap(const QString &name, const QString &context, QMap<QString, quint64> &map) const;
+
+    bool deleteMessages(const QMailMessageKey& key,
+                        QMailStore::MessageRemovalOption option,
+                        QMailMessageIdList& deletedMessageIds,
+                        QStringList& expiredMailfiles,
+                        QMailAccountIdList& modifiedAccounts,
+                        QMailFolderIdList& modifiedFolders);
+
+    bool deleteFolders(const QMailFolderKey& key,
+                       QMailStore::MessageRemovalOption option,
+                       QMailFolderIdList& deletedFolders,
+                       QMailMessageIdList& deletedMessageIds,
+                       QStringList& expiredMailfiles,
+                       QMailAccountIdList& modifiedAccounts);
+
+    bool deleteAccounts(const QMailAccountKey& key,
+                        QMailAccountIdList& deletedAccounts,
+                        QMailFolderIdList& deletedFolders,
+                        QMailMessageIdList& deletedMessageIds,
+                        QStringList& expiredMailfile);
+
+    void removeExpiredData(const QMailMessageIdList& messageIds,
+                           const QStringList& mailfiles,
+                           const QMailFolderIdList& folderIds = QMailFolderIdList(),
+                           const QMailAccountIdList& accountIds = QMailAccountIdList());
+
+    template<typename AccessType, typename FunctionType>
+    bool repeatedly(FunctionType func, const QString &description) const;
+
+    AttemptResult addCustomFields(quint64 id, const QMap<QString, QString> &fields);
+    AttemptResult updateCustomFields(quint64 id, const QMap<QString, QString> &fields);
+    AttemptResult customFields(quint64 id, QMap<QString, QString> *fields);
+
+    AttemptResult attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config, 
+                                    QMailAccountIdList *addedAccountIds, 
+                                    Transaction &t);
+
+    AttemptResult attemptAddFolder(QMailFolder *folder, 
+                                   QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                   Transaction &t);
+
+    AttemptResult attemptAddMessage(QMailMessageMetaData *metaData,
+                                    QMailMessageIdList *addedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                    Transaction &t);
+
+    AttemptResult attemptRemoveAccounts(const QMailAccountKey &key, 
+                                        QMailAccountIdList *deletedAccounts, QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages,
+                                        Transaction &t);
+
+    AttemptResult attemptRemoveFolders(const QMailFolderKey &key, QMailStore::MessageRemovalOption option, 
+                                       QMailFolderIdList *deletedFolders, QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts,
+                                       Transaction &t);
+
+    AttemptResult attemptRemoveMessages(const QMailMessageKey &key, QMailStore::MessageRemovalOption option, 
+                                        QMailMessageIdList *deletedMessages, QMailAccountIdList *modifiedAccounts, QMailFolderIdList *modifiedFolders,
+                                        Transaction &t);
+
+    AttemptResult attemptUpdateAccount(QMailAccount *account, QMailAccountConfiguration *config, 
+                                       QMailAccountIdList *updatedAccountIds,
+                                       Transaction &t);
+
+    AttemptResult attemptUpdateAccountConfiguration(QMailAccountConfiguration *config, 
+                                                    QMailAccountIdList *updatedAccountIds,
+                                                    Transaction &t);
+
+    AttemptResult attemptUpdateFolder(QMailFolder *folder, 
+                                      QMailFolderIdList *updatedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                      Transaction &t);
+
+    AttemptResult attemptUpdateMessage(QMailMessageMetaData *metaData, QMailMessage *mail, 
+                                       QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, bool *modifiedContent,
+                                       Transaction &t);
+
+    AttemptResult affectedByMessageIds(const QMailMessageIdList &messages, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const;
+
+    AttemptResult affectedByFolderIds(const QMailFolderIdList &folders, QMailFolderIdList *folderIds, QMailAccountIdList *accountIds) const;
+
+    AttemptResult attemptUpdateMessagesMetaData(const QMailMessageKey &key, const QMailMessageKey::Properties &props, const QMailMessageMetaData &data, 
+                                                QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds,
+                                                Transaction &t); 
+
+    AttemptResult attemptUpdateMessagesStatus(const QMailMessageKey &key, quint64 status, bool set, 
+                                              QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                              Transaction &t);
+
+    AttemptResult attemptRestoreToPreviousFolder(const QMailMessageKey &key, 
+                                                 QMailMessageIdList *updatedMessageIds, QMailFolderIdList *modifiedFolderIds, QMailAccountIdList *modifiedAccountIds, 
+                                                 Transaction &t);
+
+    AttemptResult attemptPurgeMessageRemovalRecords(const QMailAccountId &accountId, const QStringList &serverUids,
+                                                    Transaction &t);
+
+    AttemptResult attemptCountAccounts(const QMailAccountKey &key, int *result, 
+                                       ReadLock &);
+
+    AttemptResult attemptCountFolders(const QMailFolderKey &key, int *result, 
+                                      ReadLock &);
+
+    AttemptResult attemptCountMessages(const QMailMessageKey &key, 
+                                       int *result, 
+                                       ReadLock &);
+
+    AttemptResult attemptSizeOfMessages(const QMailMessageKey &key, 
+                                        int *result, 
+                                        ReadLock &);
+
+    AttemptResult attemptQueryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey, 
+                                       QMailAccountIdList *ids, 
+                                       ReadLock &);
+
+    AttemptResult attemptQueryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey, 
+                                      QMailFolderIdList *ids, 
+                                      ReadLock &);
+
+    AttemptResult attemptQueryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey,
+                                       QMailMessageIdList *ids, 
+                                       ReadLock &);
+
+    AttemptResult attemptAccount(const QMailAccountId &id, 
+                                 QMailAccount *result, 
+                                 ReadLock &);
+
+    AttemptResult attemptAccountConfiguration(const QMailAccountId &id, 
+                                              QMailAccountConfiguration *result, 
+                                              ReadLock &);
+
+    AttemptResult attemptFolder(const QMailFolderId &id, 
+                                QMailFolder *result, 
+                                ReadLock &);
+
+    AttemptResult attemptMessage(const QMailMessageId &id, 
+                                 QMailMessage *result, 
+                                 ReadLock &);
+
+    AttemptResult attemptMessage(const QString &uid, const QMailAccountId &accountId, 
+                                 QMailMessage *result, 
+                                 ReadLock &);
+
+    AttemptResult attemptMessagesMetaData(const QMailMessageKey& key, const QMailMessageKey::Properties &properties, QMailStore::ReturnOption option,
+                                          QMailMessageMetaDataList *result, 
+                                          ReadLock &);
+
+    AttemptResult attemptMessageRemovalRecords(const QMailAccountId &accountId, const QMailFolderId &parentFolderId, 
+                                               QMailMessageRemovalRecordList *result,
+                                               ReadLock &);
+
+    AttemptResult attemptMessageFolderIds(const QMailMessageKey &key, 
+                                          QMailFolderIdList *result, 
+                                          ReadLock &);
+
+    AttemptResult attemptFolderAccountIds(const QMailFolderKey &key, 
+                                          QMailAccountIdList *result, 
+                                          ReadLock &);
+
+    AttemptResult attemptFolderAncestorIds(const QMailFolderIdList &ids, 
+                                           QMailFolderIdList *result, 
+                                           ReadLock &);
+
+    AttemptResult attemptStatusBit(const QString &name, const QString &context, 
+                                   int *result, 
+                                   ReadLock &);
+
+    AttemptResult attemptRegisterStatusBit(const QString &name, const QString &context, int maximum, 
+                                           Transaction &t);
+
+    QMailAccount extractAccount(const QMailAccountId& id, const QStringList& list);
+    QMailFolder extractFolder(const QMailFolderId& id, const QStringList& list);
+    void extractMessageMetaData(const QStringList& list, QMailMessageMetaData* metaData);
+    QMailMessageRemovalRecord extractMessageRemovalRecord(const QStringList& r);
+
+    virtual void emitIpcNotification(QMailStoreImplementation::AccountUpdateSignal signal, const QMailAccountIdList &ids);
+    virtual void emitIpcNotification(QMailStoreImplementation::FolderUpdateSignal signal, const QMailFolderIdList &ids);
+    virtual void emitIpcNotification(QMailStoreImplementation::MessageUpdateSignal signal, const QMailMessageIdList &ids);
+
+    static const int headerCacheSize = 100;
+    static const int folderCacheSize = 10;
+    static const int accountCacheSize = 10;
+    static const int lookAhead = 5;
+
+    static QVariantList messageValues(const QMailMessageKey::Properties& properties, const QMailMessageMetaData& data);
+    static void updateMessageValues(const QMailMessageKey::Properties& properties, const QVariantList& values, const QMap<QString, QString>& customFields, QMailMessageMetaData& metaData);
+
+    static const QString &defaultContentScheme();
+    static const QString &messagesBodyPath();
+    static QString messageFilePath(const QString &fileName);
+    static int pathIdentifier(const QString &filePath);
+
+private:
+    template <typename T, typename ID> 
+    class Cache
+    {
+    public:
+        Cache(unsigned int size = 10);
+        ~Cache();
+
+        T lookup(const ID& id) const;
+        void insert(const T& item);
+        bool contains(const ID& id) const;
+        void remove(const ID& id);
+        void clear();
+
+    private:
+        QCache<quint64,T> mCache;
+    };
+
+    mutable QMailMessageIdList lastQueryMessageResult;
+
+    mutable Cache<QMailMessageMetaData, QMailMessageId> headerCache;
+    mutable Cache<QMailFolder, QMailFolderId> folderCache;
+    mutable Cache<QMailAccount, QMailAccountId> accountCache;
+
+    mutable QList<const QMailMessageKey*> requiredTableKeys;
+    mutable QList<const QMailMessageKey*> temporaryTableKeys;
+    QList<const QMailMessageKey*> expiredTableKeys;
+
+    bool inTransaction;
+    mutable QString lastQueryError;
+
+    ProcessMutex *mutex;
+    ProcessReadLock *readLock;
+
+    static ProcessMutex *contentMutex;
+
+    SparqlDatabase sparqlDatabase;
+};
+
+template <typename ValueType>
+ValueType QMailStorePrivate::extractValue(const QVariant &var, const ValueType &defaultValue)
+{
+    if (!qVariantCanConvert<ValueType>(var)) {
+        qWarning() << "QMailStorePrivate::extractValue - Cannot convert variant to:"
+#ifdef QMAILSTORE_USE_RTTI
+                   << typeid(ValueType).name();
+#else
+                   << "requested type";
+#endif
+        return defaultValue;
+    }
+
+    return qVariantValue<ValueType>(var);
+}
+
+
+template <typename T, typename ID> 
+QMailStorePrivate::Cache<T, ID>::Cache(unsigned int cacheSize)
+    : mCache(cacheSize)
+{
+}
+
+template <typename T, typename ID> 
+QMailStorePrivate::Cache<T, ID>::~Cache()
+{
+}
+
+template <typename T, typename ID> 
+T QMailStorePrivate::Cache<T, ID>::lookup(const ID& id) const
+{
+    if (id.isValid())
+        if (T* cachedItem = mCache.object(id.toULongLong()))
+            return *cachedItem;
+
+    return T();
+}
+
+template <typename T, typename ID> 
+void QMailStorePrivate::Cache<T, ID>::insert(const T& item)
+{
+    if (item.id().isValid())
+        mCache.insert(item.id().toULongLong(),new T(item));
+}
+
+template <typename T, typename ID> 
+bool QMailStorePrivate::Cache<T, ID>::contains(const ID& id) const
+{
+    return mCache.contains(id.toULongLong());
+}
+
+template <typename T, typename ID> 
+void QMailStorePrivate::Cache<T, ID>::remove(const ID& id)
+{
+    mCache.remove(id.toULongLong());
+}
+
+template <typename T, typename ID> 
+void QMailStorePrivate::Cache<T, ID>::clear()
+{
+    mCache.clear();
+}
+
+#endif
* Unmerged path src/libraries/qtopiamail/qtopiamail.pro
* Unmerged path src/libraries/qtopiamail/support/qmaillog.h
diff --git a/src/libraries/qtopiamail/support/qmailnamespace.cpp b/src/libraries/qtopiamail/support/qmailnamespace.cpp
index ca46279..03a1840 100644
--- a/src/libraries/qtopiamail/support/qmailnamespace.cpp
+++ b/src/libraries/qtopiamail/support/qmailnamespace.cpp
@@ -40,6 +40,7 @@
 ****************************************************************************/
 
 #include "qmailnamespace.h"
+#include "qmaillog.h"
 #include <QSqlDatabase>
 #include <stdio.h>
 #include <unistd.h>
@@ -161,6 +162,7 @@ int QMail::fileLock(const QString& lockFile)
     int fdlock = -1;
 
     QString path = QDir::tempPath() + "/" + lockFile;
+    qMailLog(Messaging) << "File Lock Path:" << path;
     if((fdlock = ::open(path.toLatin1(), O_WRONLY|O_CREAT, 0666)) == -1)
         return -1;
 
@@ -209,9 +211,9 @@ QString QMail::pluginsPath()
 {
     static QString pluginsEnv(getenv(QMF_PLUGINS_ENV));
     if(!pluginsEnv.isEmpty())
-        return pluginsEnv + "/";
-    //default to "." if no env set
-    return pluginsEnv;
+        return pluginsEnv;
+    //default to "/usr/lib/qmf/" if no env set
+    return "/usr/lib/qmf/";
 }
 
 QString QMail::sslCertsPath()
@@ -225,11 +227,16 @@ QSqlDatabase QMail::createDatabase()
     QSqlDatabase db;
     if(!init)
     {
+        Q_ASSERT(QSqlDatabase::isDriverAvailable("QSQLITE"));
+
         db = QSqlDatabase::addDatabase("QSQLITE");
         QDir dp(dataPath());
         if(!dp.exists())
             if(!dp.mkpath(dataPath()))
                 qCritical() << "Cannot create data path";
+
+        qMailLog(Messaging) << "Set database name:" << dataPath() + "/qmailstore.db";
+
         db.setDatabaseName(dataPath() + "/qmailstore.db");
         if(!db.open())
             qCritical() << "Cannot open database";
diff --git a/src/libraries/sparql/include/SparqlDatabase b/src/libraries/sparql/include/SparqlDatabase
new file mode 100644
index 0000000..ac92cb7
--- /dev/null
+++ b/src/libraries/sparql/include/SparqlDatabase
@@ -0,0 +1 @@
+#include "sparqldatabase.h"
diff --git a/src/libraries/sparql/include/SparqlQuery b/src/libraries/sparql/include/SparqlQuery
new file mode 100644
index 0000000..bf9b61e
--- /dev/null
+++ b/src/libraries/sparql/include/SparqlQuery
@@ -0,0 +1 @@
+#include "sparqlquery.h"
diff --git a/src/libraries/sparql/include/SparqlResult b/src/libraries/sparql/include/SparqlResult
new file mode 100644
index 0000000..8e66d59
--- /dev/null
+++ b/src/libraries/sparql/include/SparqlResult
@@ -0,0 +1 @@
+#include "sparqlresult.h"
diff --git a/src/libraries/sparql/include/SparqlUri b/src/libraries/sparql/include/SparqlUri
new file mode 100644
index 0000000..52d7ed8
--- /dev/null
+++ b/src/libraries/sparql/include/SparqlUri
@@ -0,0 +1 @@
+#include "sparqluri.h"
diff --git a/src/libraries/sparql/sparql.pro b/src/libraries/sparql/sparql.pro
new file mode 100644
index 0000000..b323449
--- /dev/null
+++ b/src/libraries/sparql/sparql.pro
@@ -0,0 +1,39 @@
+TEMPLATE = lib
+
+TARGET = sparql
+
+INCLUDEPATH += . tracker
+
+QT *= dbus
+
+# Input
+DBUS_HEADERS += tracker/registertypes.h \
+                tracker/resourcesproxy.h
+
+SPARQL_HEADERS += sparqldatabase.h \
+                  sparqlquery.h \
+                  sparqlresult.h \
+                  sparqluri.h
+
+HEADERS += $$DBUS_HEADERS $$SPARQL_HEADERS
+
+SOURCES += \
+    sparqldatabase.cpp \
+    sparqlquery.cpp \
+    sparqlresult.cpp \
+    tracker/registertypes.cpp \
+    tracker/resourcesproxy.cpp \
+    sparqluri.cpp
+
+# Install headers
+sparql_headers.files = $$SPARQL_HEADERS include/*
+sparql_headers.path  = $$QMF_INSTALL_ROOT/include/qmf
+
+dbus_headers.files = $$DBUS_HEADERS
+dbus_headers.path  = $$QMF_INSTALL_ROOT/include/qmf/tracker
+
+INSTALLS += sparql_headers dbus_headers
+
+target.path += $$QMF_INSTALL_ROOT/lib
+
+INSTALLS += target
diff --git a/src/libraries/sparql/sparqldatabase.cpp b/src/libraries/sparql/sparqldatabase.cpp
new file mode 100644
index 0000000..7568a09
--- /dev/null
+++ b/src/libraries/sparql/sparqldatabase.cpp
@@ -0,0 +1,44 @@
+#include "sparqldatabase.h"
+
+#include <QDBusConnection>
+
+// Pointer to the default database
+SparqlDatabase* SparqlDatabase::_defaultDatabase = NULL;
+
+
+SparqlDatabase::SparqlDatabase(const QString& databaseName) :
+        _proxy(databaseName, "/org/freedesktop/Tracker/Resources", QDBusConnection::sessionBus()),
+        _databaseName(databaseName)
+{
+    qDebug() << "SparqlDatabase::SparqlDatabase";
+    if (!_defaultDatabase)
+    {
+        // Register Qt types
+        registerTypes();
+
+        _defaultDatabase = this;
+    }
+}
+
+SparqlDatabase::~SparqlDatabase()
+{
+    if (_defaultDatabase == this)
+        _defaultDatabase = NULL;
+}
+
+SparqlDatabase* SparqlDatabase::defaultDatabase()
+{
+    return _defaultDatabase;
+}
+
+QString SparqlDatabase::databaseName() const
+{
+    return _databaseName;
+}
+
+bool SparqlDatabase::isOpenError() const
+{
+    // Check wheither we are connected
+    bool isConnected = _proxy.connection().isConnected();
+    return !isConnected;
+}
diff --git a/src/libraries/sparql/sparqldatabase.h b/src/libraries/sparql/sparqldatabase.h
new file mode 100644
index 0000000..ab1d6b5
--- /dev/null
+++ b/src/libraries/sparql/sparqldatabase.h
@@ -0,0 +1,59 @@
+#ifndef SPARQLDATABASE_H
+#define SPARQLDATABASE_H
+
+#include "tracker/resourcesproxy.h"
+
+/**
+ * \brief SparqlDatabase represents connection to the SPARQL data base.
+ *
+ * SparqlDatabase represents connection to the SPARQL data base. It relies on the
+ * proxy implementation. It is possible to keep several databases opened at the same
+ * time, but only one of them will be default. All queries without exact database
+ * specification will be performed with default database.
+ *
+ * \see SparqlQuery
+ */
+class SparqlDatabase
+{
+    friend class SparqlQuery;
+
+public:
+    /**
+     * \brief Creates new database
+     *
+     * \param databaseName Name of the data base.
+     */
+    SparqlDatabase(const QString& databaseName = "org.freedesktop.Tracker");
+
+    /**
+     * \brief Default destructor
+     */
+    ~SparqlDatabase();
+
+    /**
+     * \brief Returns default database
+     *
+     * First created database will become default one.
+     *
+     * \return Pointer to the default database.
+     */
+    static SparqlDatabase* defaultDatabase();
+
+    /**
+     * \brief Returns name of the database
+     */
+    QString databaseName() const;
+
+    /**
+     * \brief Returns true wheither there was an error during opening database.
+     */
+    bool isOpenError() const;
+
+private:
+    static SparqlDatabase* _defaultDatabase;
+
+    ResourcesProxy _proxy;
+    QString        _databaseName;
+};
+
+#endif // SPARQLDATABASE_H
diff --git a/src/libraries/sparql/sparqlquery.cpp b/src/libraries/sparql/sparqlquery.cpp
new file mode 100644
index 0000000..8801b79
--- /dev/null
+++ b/src/libraries/sparql/sparqlquery.cpp
@@ -0,0 +1,86 @@
+#include "sparqlquery.h"
+#include "sparqldatabase.h"
+#include "sparqlresult.h"
+
+#include <QDBusPendingReply>
+
+SparqlQuery::SparqlQuery(SparqlQuery::QueryType type, const QString& query,  SparqlDatabase* database) :
+        _type(type),
+        _query(query),
+        _database(database),
+        _result(NULL)
+{
+    if (!_database)
+        _database = SparqlDatabase::defaultDatabase();
+
+    Q_ASSERT(_database);
+}
+
+SparqlQuery::~SparqlQuery()
+{
+}
+
+bool SparqlQuery::prepare(const QString query)
+{
+    _query = query;
+
+    return true;
+}
+
+bool SparqlQuery::exec()
+{
+    Q_ASSERT(_database);
+
+    // Clear last error status and query result
+    _result.clear();
+    _error.clear();
+
+    qDebug() << _query;
+
+    bool err;
+    if (_type == SearchQuery)
+    {
+        QDBusPendingReply<QueryResultType> reply;
+        reply = _database->_proxy.SparqlQuery(_query);
+
+        reply.waitForFinished();
+
+        err = reply.isError();
+        if (!err)
+        {
+            _result = reply.value();
+
+            foreach (const QStringList& row, _result)
+                qDebug() << row.join(", ");
+
+        } else
+            _error = reply.error().message();
+
+    } else {
+        QDBusPendingReply<> reply;
+        reply = _database->_proxy.SparqlUpdate(_query);
+
+        reply.waitForFinished();
+
+        err = reply.isError();
+        if (err)
+            _error = reply.error().message();
+    }
+
+    return !err;
+}
+
+SparqlResult SparqlQuery::result() const
+{
+    return SparqlResult(this);
+}
+
+QString SparqlQuery::error() const
+{
+    return _error;
+}
+
+QString SparqlQuery::query() const
+{
+    return _query;
+}
diff --git a/src/libraries/sparql/sparqlquery.h b/src/libraries/sparql/sparqlquery.h
new file mode 100644
index 0000000..a030cfb
--- /dev/null
+++ b/src/libraries/sparql/sparqlquery.h
@@ -0,0 +1,102 @@
+#ifndef SPARQLQUERY_H
+#define SPARQLQUERY_H
+
+#include <QStringList>
+#include <QVector>
+#include <QString>
+
+class SparqlDatabase;
+class SparqlResult;
+
+/**
+ * \brief SparqlQuery represents SPARQL query.
+ *
+ * There are two different types of queries: search and update queries. Search query uses standard SPARQL syntax
+ * and can only read information from the database. Update queries exploit Advanced SPARQL syntax and allow to
+ * insert, delete and update information in the database.
+ *
+ * Database can be defeined explicitely or default database can be used. In anycase at least one SparqlDatabase
+ * object must be created.
+ *
+ * \see SparqlDatabase
+ */
+class SparqlQuery
+{
+    friend class SparqlResult;
+
+public:
+    /**
+     * \brief Type of the query
+     */
+    enum QueryType
+    {
+        SearchQuery,  ///< Query can use SELECT, CONSTRUCT, DESCRIBE or ASK SPARQL statments
+        UpdateQuery   ///< Query can use INSERT, DELETE and UPDATE advances SPARQL statments
+    };
+
+    /**
+     * \brief Constructs SPARQL query
+     *
+     * \param type Type of the quey.
+     * \param query Query string, It can be defined later with prepare() method.
+     * \param database Pointer to the database. Default database will be used in case of NULL.
+     */
+    SparqlQuery(QueryType type, const QString& query = QString(),  SparqlDatabase* database = NULL);
+
+     /**
+      * \brief Default destructor
+      */
+    ~SparqlQuery();
+
+    /**
+     * \brief Prepare query for execution
+     *
+     * \param SPARQL query to prepare.
+     * \return Status of the application.
+     */
+    bool prepare(const QString query);
+
+    /**
+     * \brief Execute prepared query
+     *
+     * Before executing a query it has to be prepared using prepare() method.
+     * In case of any errors exec() will return false. More detailes information
+     * about source of error can be retrieved using error() method.
+     *
+     * Result of query execution can be retrieved using result() method.
+     * Retult is available only for Search queries.
+     *
+     * \return true in case of success and false in case of failure.
+     */
+    bool exec();
+
+    /**
+     * \brief Returns result of the operation
+     *
+     * \return result can be NULL in case of error or Update query was executed.
+     */
+    SparqlResult result() const;
+
+    /**
+     * \brief Returns textual representation of the error.
+     *
+     * \return Literal error description.
+     */
+    QString error() const;
+
+    /**
+     * \brief Returns prepared SPARQL query to execute.
+     */
+    QString query() const;
+
+private:
+    QueryType       _type;
+    QString         _query;
+    SparqlDatabase* _database;
+    QString         _error;
+
+    typedef QVector<QStringList> QueryResultType;
+    QueryResultType _result;
+};
+
+#endif // SPARQLQUERY_H
diff --git a/src/libraries/sparql/sparqlresult.cpp b/src/libraries/sparql/sparqlresult.cpp
new file mode 100644
index 0000000..de7f2a0
--- /dev/null
+++ b/src/libraries/sparql/sparqlresult.cpp
@@ -0,0 +1,31 @@
+#include "sparqlresult.h"
+#include "sparqlquery.h"
+
+SparqlResult::SparqlResult(const SparqlQuery* query) :
+        _query(query),
+        _current(0)
+{
+}
+
+const QStringList& SparqlResult::fetchRow()
+{
+    Q_ASSERT(_query);
+
+    return _query->_result.at(_current++);
+}
+
+bool SparqlResult::begin() const
+{
+    return (_current == 0);
+}
+
+bool SparqlResult::end() const
+{
+    Q_ASSERT(_query);
+    return (_query->_result.count() == _current);
+}
+
+void SparqlResult::reset()
+{
+    _current = 0;
+}
diff --git a/src/libraries/sparql/sparqlresult.h b/src/libraries/sparql/sparqlresult.h
new file mode 100644
index 0000000..2c9be91
--- /dev/null
+++ b/src/libraries/sparql/sparqlresult.h
@@ -0,0 +1,56 @@
+#ifndef SPARQLRESULT_H
+#define SPARQLRESULT_H
+
+#include <QVector>
+#include <QStringList>
+
+class SparqlQuery;
+
+/**
+ * \brief SparqlResult provides convenient way to fetch data from the executed query.
+ *
+ * To fetch data from already executed query you have to get instance of that class
+ * with SparqlQuery::result() method and call fetchRow() method till you reach the end().
+ *
+ * It is possible to enumerate result of the query using different instances of the
+ * SparqlResult class at the same time. But you have to know that data itself belongs
+ * to the query and you should not access any methods of this class in case of SparqlQuery
+ * was destroyed.
+ *
+ * \see SparqlQuery
+ */
+class SparqlResult
+{
+    friend class SparqlQuery;
+
+public:
+    /**
+     * \brief Fetch the row with results of the query
+     *
+     * \return List of values of the row.
+     */
+    const QStringList& fetchRow();
+
+    /**
+     * \brief Does the result point to the beginig of data set
+     */
+    bool begin() const;
+
+    /**
+     * \brief Does the result point to the end of the data set
+     */
+    bool end() const;
+
+    /**
+     * \brief Reset result and make it points to the begining again
+     */
+    void reset();
+
+private:
+    SparqlResult(const SparqlQuery* query);
+    const SparqlQuery* _query;
+
+    int _current;
+};
+
+#endif // SPARQLRESULT_H
diff --git a/src/libraries/sparql/sparqluri.cpp b/src/libraries/sparql/sparqluri.cpp
new file mode 100644
index 0000000..6963010
--- /dev/null
+++ b/src/libraries/sparql/sparqluri.cpp
@@ -0,0 +1,88 @@
+#include "sparqluri.h"
+#include <QUuid>
+
+SparqlUri::SparqlUri(const QString& base) :
+        _id(generate())
+{
+    bool ret = setBase(base);
+    Q_ASSERT(ret);
+}
+
+SparqlUri::SparqlUri(const QString& base, quint64 id) :
+        _id(id)
+{
+    bool ret = setBase(base);
+    Q_ASSERT(ret);
+}
+
+bool SparqlUri::setBase(const QString& base)
+{
+    _base = base;
+    return true;
+}
+
+QString SparqlUri::base() const
+{
+    return _base;
+}
+
+QString SparqlUri::uri() const
+{
+    return QString("<%1>").arg(base() + QString::number(_id));
+}
+
+void SparqlUri::setId(quint64 id)
+{
+    _id = id;
+}
+
+quint64 SparqlUri::id() const
+{
+    return _id;
+}
+
+quint64 SparqlUri::generate()
+{
+    /*
+     * BUG!BUG!BUG!
+     *
+     * We can't just generate UUID and do not make
+     * sure that it is unique.
+     *
+     * THIS CODE HAS TO BE REWRITTEN.
+     */
+    QUuid uuid = QUuid::createUuid();
+
+    quint64 data1 = uuid.data1;
+    quint64 data2 = uuid.data2;
+    quint64 data3 = uuid.data3;
+    quint64 data4 = *(quint64*)uuid.data4;
+
+    quint64 id = (data1 << 32) ^ (data2 << 16) ^ data3;
+    id |= data4;
+
+    return id;
+}
+
+SparqlUri::operator QString () const
+{
+    return uri();
+}
+
+SparqlUri::operator quint64 () const
+{
+    return id();
+}
+
+QString SparqlUri::operator++ ()
+{
+    _id = generate();
+    return uri();
+}
+
+QString SparqlUri::operator++ (int)
+{
+    QString result(uri());
+    _id = generate();
+    return result;
+}
diff --git a/src/libraries/sparql/sparqluri.h b/src/libraries/sparql/sparqluri.h
new file mode 100644
index 0000000..44aeab1
--- /dev/null
+++ b/src/libraries/sparql/sparqluri.h
@@ -0,0 +1,102 @@
+#ifndef SPARQLURI_H
+#define SPARQLURI_H
+
+#include "sparqldatabase.h"
+
+/**
+ * \brief SparqlUri provides automatic URI generation.
+ *
+ * URI is unique identifier in the SPARQL language, it is required
+ * to be able to generate unique identifiers fast and easy. SparqlUri class
+ * provides convenient way to generate such URI.
+ *
+ * Every URI has base part and autogenerated part. Base part can be defined by user.
+ * Autogenerated part will be changed with every increment operation.
+ *
+ * Autogenerate URI will look like http://base.part/is/fixed#nnnnnn, where nnnnnn is 64bit
+ * integer, No any prediction is made about order or number of digits in the nnnnnn.
+ *
+ * \see SparqlQuery
+ */
+class SparqlUri
+{
+public:
+    /**
+     * \brief Constructor of the URI
+     *
+     * Unique id will be autogenerated.
+     *
+     * \param base Fixed part of the URI.
+     */
+    SparqlUri(const QString& base);
+
+    /**
+     * \brief Constructor of the URI generator
+     *
+     * Value of id is passed as a parameter
+     *
+     * \param base Fixed part of the URI.
+     * \param id Pre-defined id is used in this case.
+     */
+    SparqlUri(const QString& base, quint64 id);
+
+    /**
+     * \brief Set new fixed base of the URI
+     */
+    bool setBase(const QString& base);
+
+    /**
+     * \brief Get fixed base part of the URI
+     */
+    QString base() const;
+
+    /**
+     * \brief Get current URI as a string
+     */
+    void setId(quint64 id);
+
+    /**
+     * \brief Set current nnnnnn part as 64-bit integer
+     */
+    quint64 id() const;
+
+    /**
+     * \brief Get current nnnnnn part as 64-bit integer
+     */
+    QString uri() const;
+
+    /**
+     * \brief Generates new nnnnnn.
+     *
+     * Current URI is not updated. To update current URI as well operator++ should be used.
+     *
+     * \return new nnnnnn part of the URI as 64-bit unsigned integer.
+     */
+    quint64 generate();
+
+    /**
+     * \brief Convenience operator returns URI
+     */
+    operator QString () const;
+
+    /**
+     * \brief Convenience operator returns nnnnnn part of the URI
+     */
+    operator quint64 () const;
+
+    /**
+     * \brief Generates new URI and returns new value
+     */
+    QString operator++ ();
+
+    /**
+     * \brief Generates new URI and returns old value
+     */
+    QString operator++ (int);
+
+private:
+    QString _base;
+    quint64 _id;
+};
+
+#endif // #ifndef SPARQLURI_H
diff --git a/src/libraries/sparql/tracker/README b/src/libraries/sparql/tracker/README
new file mode 100644
index 0000000..9b8b88a
--- /dev/null
+++ b/src/libraries/sparql/tracker/README
@@ -0,0 +1,20 @@
+
+HOWTO Generate proxy code from DBUSXML interface definition
+
+ Obtain latest version of the .xml files from the tracker repository
+   git://git.codethink.co.uk/git/tracker
+   
+   Backup existing .xml files and code of the DBUS proxy classes.
+   
+ Update XML interface description with correct annotations for all Qt types:
+  * For every type="aas" direction="out", add following annotation:
+    <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVector&lt;QStringList&gt;"/>
+
+  * For every type="a{sv}" direction="out", add following annotation:
+    <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="QVariantList"/>
+
+  * For every signal with type="aas", add following annotation:
+    <annotation name="com.trolltech.QtDBus.QtTypeName.In0" value="QVector&lt;QStringList&gt;"/>
+
+ Run genproxy.sh script
+ 
diff --git a/src/libraries/sparql/tracker/genproxy.sh b/src/libraries/sparql/tracker/genproxy.sh
new file mode 100755
index 0000000..73a960c
--- /dev/null
+++ b/src/libraries/sparql/tracker/genproxy.sh
@@ -0,0 +1,2 @@
+#!/bin/bash
+qdbusxml2cpp -c ResourcesProxy -p resourcesproxy -i registertypes.h tracker-resources.xml org.freedesktop.Tracker.Resources
diff --git a/src/libraries/sparql/tracker/registertypes.cpp b/src/libraries/sparql/tracker/registertypes.cpp
new file mode 100644
index 0000000..e8ce4ed
--- /dev/null
+++ b/src/libraries/sparql/tracker/registertypes.cpp
@@ -0,0 +1,10 @@
+#include <QDBusMetaType>
+#include <QtDebug>
+
+#include "registertypes.h"
+
+void registerTypes()
+{
+    qRegisterMetaType<QVector<QStringList> >();
+    qDBusRegisterMetaType<QVector<QStringList> >();
+}
diff --git a/src/libraries/sparql/tracker/registertypes.h b/src/libraries/sparql/tracker/registertypes.h
new file mode 100644
index 0000000..5c87c3f
--- /dev/null
+++ b/src/libraries/sparql/tracker/registertypes.h
@@ -0,0 +1,12 @@
+#ifndef __REGISTERTYPES_H__
+#define __REGISTERTYPES_H__
+
+#include <QMetaType>
+#include <QVector>
+#include <QStringList>
+
+Q_DECLARE_METATYPE(QVector<QStringList>)
+
+void registerTypes();
+
+#endif // #ifndef __REGISTERTYPES_H__
diff --git a/src/libraries/sparql/tracker/resourcesproxy.cpp b/src/libraries/sparql/tracker/resourcesproxy.cpp
new file mode 100644
index 0000000..96f5d46
--- /dev/null
+++ b/src/libraries/sparql/tracker/resourcesproxy.cpp
@@ -0,0 +1,26 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -c ResourcesProxy -p resourcesproxy -i registertypes.h tracker-resources.xml org.freedesktop.Tracker.Resources
+ *
+ * qdbusxml2cpp is Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "resourcesproxy.h"
+
+/*
+ * Implementation of interface class ResourcesProxy
+ */
+
+ResourcesProxy::ResourcesProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+ResourcesProxy::~ResourcesProxy()
+{
+}
+
diff --git a/src/libraries/sparql/tracker/resourcesproxy.h b/src/libraries/sparql/tracker/resourcesproxy.h
new file mode 100644
index 0000000..eafaa2a
--- /dev/null
+++ b/src/libraries/sparql/tracker/resourcesproxy.h
@@ -0,0 +1,85 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -c ResourcesProxy -p resourcesproxy -i registertypes.h tracker-resources.xml org.freedesktop.Tracker.Resources
+ *
+ * qdbusxml2cpp is Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef RESOURCESPROXY_H_1241509742
+#define RESOURCESPROXY_H_1241509742
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+#include "registertypes.h"
+
+/*
+ * Proxy class for interface org.freedesktop.Tracker.Resources
+ */
+class ResourcesProxy: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.freedesktop.Tracker.Resources"; }
+
+public:
+    ResourcesProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~ResourcesProxy();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> Delete(const QString &subject, const QString &predicate, const QString &object)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(subject) << qVariantFromValue(predicate) << qVariantFromValue(object);
+        return asyncCallWithArgumentList(QLatin1String("Delete"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Insert(const QString &subject, const QString &predicate, const QString &object)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(subject) << qVariantFromValue(predicate) << qVariantFromValue(object);
+        return asyncCallWithArgumentList(QLatin1String("Insert"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Load(const QString &uri)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(uri);
+        return asyncCallWithArgumentList(QLatin1String("Load"), argumentList);
+    }
+
+    inline QDBusPendingReply<QVector<QStringList> > SparqlQuery(const QString &query)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(query);
+        return asyncCallWithArgumentList(QLatin1String("SparqlQuery"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SparqlUpdate(const QString &query)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(query);
+        return asyncCallWithArgumentList(QLatin1String("SparqlUpdate"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+namespace org {
+  namespace freedesktop {
+    namespace Tracker {
+      typedef ::ResourcesProxy Resources;
+    }
+  }
+}
+#endif
diff --git a/src/libraries/sparql/tracker/tracker-resources.xml b/src/libraries/sparql/tracker/tracker-resources.xml
new file mode 100644
index 0000000..233fc64
--- /dev/null
+++ b/src/libraries/sparql/tracker/tracker-resources.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<node name="/org/freedesktop/Tracker">
+  <interface name="org.freedesktop.Tracker.Resources">
+
+    <!-- Insert single statement -->
+    <method name="Insert">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/> 
+      <arg type="s" name="subject" direction="in" />
+      <arg type="s" name="predicate" direction="in" />
+      <arg type="s" name="object" direction="in" />
+    </method>
+
+    <!-- Delete single statement -->
+    <method name="Delete">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/> 
+      <arg type="s" name="subject" direction="in" />
+      <arg type="s" name="predicate" direction="in" />
+      <arg type="s" name="object" direction="in" />
+    </method>
+
+    <!-- Load statements from Turtle file -->
+    <method name="Load">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/> 
+      <arg type="s" name="uri" direction="in" />
+    </method>
+
+    <!-- SPARQL Query without updates -->
+    <method name="SparqlQuery">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/>
+      <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" 
+		  value="QVector&lt;QStringList&gt;"/>
+      <arg type="s" name="query" direction="in" />
+      <arg type="aas" name="result" direction="out" />
+    </method>
+
+    <!-- SPARQL Update extensions, allows bulk insert and delete -->
+    <method name="SparqlUpdate">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value="true"/>
+      <arg type="s" name="query" direction="in" />
+    </method>
+
+  </interface>
+</node>
diff --git a/src/plugins/messageservices/dummysink/dummysink.pro b/src/plugins/messageservices/dummysink/dummysink.pro
new file mode 100644
index 0000000..8fcfd89
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysink.pro
@@ -0,0 +1,31 @@
+TEMPLATE = lib 
+
+TARGET = dummysink
+
+target.path = $$QMF_INSTALL_ROOT/plugins/messageservices
+INSTALLS += target
+
+QT += network
+
+DEPENDPATH += .
+
+INCLUDEPATH += . ../../../libraries/qtopiamail \
+               ../../../libraries/messageserver \
+               ../../../libraries/qtopiamail/support
+
+LIBS += -L../../../libraries/qtopiamail -lqtopiamail \
+        -L../../../libraries/messageserver -lmessageserver
+
+HEADERS += dummysinkauthenticator.h \
+           dummysinkclient.h \
+           dummysinkconfiguration.h \
+           dummysinkservice.h \
+           dummysinksettings.h
+
+FORMS += dummysinksettings.ui
+
+SOURCES += dummysinkauthenticator.cpp \
+           dummysinkclient.cpp \
+           dummysinkconfiguration.cpp \
+           dummysinkservice.cpp \
+           dummysinksettings.cpp
diff --git a/src/plugins/messageservices/dummysink/dummysinkauthenticator.cpp b/src/plugins/messageservices/dummysink/dummysinkauthenticator.cpp
new file mode 100644
index 0000000..7af18a1
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinkauthenticator.cpp
@@ -0,0 +1,68 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummysinkauthenticator.h"
+#include "dummysinkconfiguration.h"
+#include <qmailauthenticator.h>
+
+
+namespace {
+
+QMap<QMailAccountId, QList<QByteArray> > gResponses;
+
+}
+
+QByteArray DummySinkAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
+{
+    QByteArray result(QMailAuthenticator::getAuthentication(svcCfg, capabilities));
+    if (!result.isEmpty())
+        return result;
+
+#ifndef QT_NO_OPENSSL
+    DummySinkConfiguration dummyCfg(svcCfg);
+    if (dummyCfg.dummyAuthentication() != DummySinkConfiguration::Auth_NONE) {
+        QMailAccountId id(dummyCfg.id());
+        QByteArray username(dummyCfg.dummyUsername().toAscii());
+        QByteArray password(dummyCfg.dummyPassword().toAscii());
+
+        if (dummyCfg.dummyAuthentication() == DummySinkConfiguration::Auth_LOGIN) {
+            result = QByteArray("LOGIN");
+            gResponses[id] = (QList<QByteArray>() << username << password);
+        } else if (dummyCfg.dummyAuthentication() == DummySinkConfiguration::Auth_PLAIN) {
+            result = QByteArray("PLAIN");
+            gResponses[id] = (QList<QByteArray>() << QByteArray(username + '\0' + username + '\0' + password));
+        }
+    }
+#endif
+
+    if (!result.isEmpty()) {
+        result.prepend("AUTH ");
+    }
+    return result;
+}
+
+QByteArray DummySinkAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge)
+{
+    QByteArray result;
+
+    QMap<QMailAccountId, QList<QByteArray> >::iterator it = gResponses.find(svcCfg.id());
+    if (it != gResponses.end()) {
+        QList<QByteArray> &responses = it.value();
+        result = responses.takeFirst();
+
+        if (responses.isEmpty())
+            gResponses.erase(it);
+    } else {
+        result = QMailAuthenticator::getResponse(svcCfg, challenge);
+    }
+
+    return result;
+}
+
diff --git a/src/plugins/messageservices/dummysink/dummysinkauthenticator.h b/src/plugins/messageservices/dummysink/dummysinkauthenticator.h
new file mode 100644
index 0000000..6ea3f51
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinkauthenticator.h
@@ -0,0 +1,27 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMY_SINK_AUTHENTICATOR_H
+#define DUMMY_SINK_AUTHENTICATOR_H
+
+#include <qmailaccountconfiguration.h>
+
+#include <QByteArray>
+#include <QStringList>
+
+class DummySinkAuthenticator
+{
+public:
+    static QByteArray getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+    static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge);
+};
+
+#endif
+
diff --git a/src/plugins/messageservices/dummysink/dummysinkclient.cpp b/src/plugins/messageservices/dummysink/dummysinkclient.cpp
new file mode 100644
index 0000000..fd5447b
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinkclient.cpp
@@ -0,0 +1,351 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummysinkclient.h"
+#include "dummysinkservice.h"
+#include "dummysinkauthenticator.h"
+#include "dummysinkconfiguration.h"
+
+#include <QHostAddress>
+#include <QTextCodec>
+#include <qmaillog.h>
+#include <qmailaddress.h>
+#include <qmailstore.h>
+#include <qmailtransport.h>
+#include <qmaillog.h>
+
+
+DummySinkClient::DummySinkClient(QObject* parent)
+    : QObject(parent),
+    ConnectionActive(false),
+    transport(NULL),
+    progressSendSize(0),
+    totalSendSize(0)
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::DummySinkClient(QObject* parent) called" << flush;
+
+    domainName = "groovemail.com";
+}
+
+DummySinkClient::~DummySinkClient()
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::~DummySinkClient(QObject* parent) called" << flush;
+    delete transport;
+}
+
+QMailMessage::MessageType DummySinkClient::messageType() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::messageType() called" << flush;
+
+    return QMailMessage::Email;
+}
+
+void DummySinkClient::setAccount(const QMailAccountId &id)
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::setAccount(const QMailAccountId &id) called" << flush;
+
+    // Load the current configuration for this account
+    config = QMailAccountConfiguration(id);
+}
+
+QMailAccountId DummySinkClient::account() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::account() called" << flush;
+
+    return config.id();
+}
+
+void DummySinkClient::newConnection()
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::newConnection() called" << flush;
+
+    if (!transport)
+    {
+        // Set up the transport
+        transport = new QMailTransport("DUMMYSINK");
+
+        connect(transport, SIGNAL(readyRead()),
+                this, SLOT(readyRead()));
+        connect(transport, SIGNAL(connected(QMailTransport::EncryptType)),
+                this, SLOT(connected(QMailTransport::EncryptType)));
+        connect(transport, SIGNAL(bytesWritten(qint64)),
+                this, SLOT(sent(qint64)));
+        connect(transport, SIGNAL(updateStatus(QString)),
+                this, SIGNAL(updateStatus(QString)));
+        connect(transport, SIGNAL(errorOccurred(int,QString)),
+                this, SLOT(transportError(int,QString)));
+
+        qMailLog(DUMMYSINK) << "DummySinkClient::newConnection() transport connected" << flush;
+    }
+
+    // Set size attributes.
+    progressSendSize = 0;
+
+    emit connected(QMailTransport::Encrypt_NONE);
+
+    //DummySinkConfiguration dummyCfg(config);
+    //transport->open(dummyCfg.dummyServer(), dummyCfg.dummyPort(), static_cast<QMailTransport::EncryptType>(dummyCfg.dummyEncryption()));
+}
+
+QMailServiceAction::Status::ErrorCode DummySinkClient::addMail(const QMailMessage& mail)
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::addMail() called" << flush;
+
+    QStringList sendTo;
+    foreach (const QMailAddress& address, mail.recipients()) {
+        // Only send to mail addresses
+        if (address.isEmailAddress())
+            sendTo.append(address.address());
+    }
+    if (sendTo.isEmpty()) {
+        qMailLog(DUMMYSINK) << "Cannot send message with empty recipient address!";
+        return QMailServiceAction::Status::ErrInvalidAddress;
+    }
+
+    // Set required mail parameters and add mail to send list.
+    RawEmail rawmail;
+    rawmail.from = "<" + mail.from().address() + ">";
+    rawmail.to = sendTo;
+    rawmail.mail = mail;
+    rawmail.mail.setContentSize(mail.body().data().length());
+    rawmail.mail.setSize(mail.body().data().length());
+    rawmail.mail.setStatus(QMailMessage::Incoming, true);
+    rawmail.mail.setStatus(QMailMessage::New, true);
+    rawmail.mail.setReceivedDate(QMailTimeStamp::currentDateTime());
+    rawmail.mail.setParentFolderId(QMailFolderId(QMailFolder::InboxFolder));
+    rawmail.mail.setStatus(QMailMessage::ContentAvailable, 1);
+    rawmail.mail.setStatus(QMailMessage::PartialContentAvailable, 1);
+    rawmail.mail.setParentAccountId(config.id());
+
+    mailList.append(rawmail);
+    sendSize.insert(rawmail.mail.id(), rawmail.mail.indicativeSize());
+
+    // Add messages size to total messages size to be sent.
+    totalSendSize += rawmail.mail.body().data().length();
+
+    // Logging the data that is being sent to the store/network.
+    {
+        qMailLog(DUMMYSINK) << "To: " << flush;
+    }
+
+    if (!QMailStore::instance()->addMessage(&rawmail.mail))
+    {
+        qWarning() << "Unable to add message after transmission:" << rawmail.mail.id();
+    }
+
+    messageProcessed(mail.id());
+
+    return QMailServiceAction::Status::ErrNoError;
+}
+
+void DummySinkClient::connected(QMailTransport::EncryptType encryptType)
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::connected() called" << flush;
+
+    DummySinkConfiguration dummyCfg(config);
+    if (dummyCfg.dummyEncryption() == encryptType) {
+        qMailLog(DUMMYSINK) << "Connected" << flush;
+        emit updateStatus(tr("Connected"));
+    }
+
+    // Set connection is active.
+    ConnectionActive = true;
+
+    emit readyRead();
+}
+
+void DummySinkClient::transportError(int errorCode, QString msg)
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::transportError(int errorCode, QString msg) called" << flush;
+
+    operationFailed(errorCode, msg);
+}
+
+void DummySinkClient::sent(qint64 size)
+{
+    Q_UNUSED(size);
+    qMailLog(DUMMYSINK) << "DummySinkClient::sent(qint64 size) called" << flush;
+}
+
+void DummySinkClient::readyRead()
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::senreadyReadt() called" << flush;
+
+    incomingData();
+}
+
+void DummySinkClient::sendCommand(const char *data, int len)
+{
+    Q_UNUSED(data);
+    Q_UNUSED(len);
+    qMailLog(DUMMYSINK) << "DummySinkClient::sendCommand(const char *data, int len) called" << flush;
+}
+
+void DummySinkClient::sendCommand(const QString &cmd)
+{
+    Q_UNUSED(cmd);
+    qMailLog(DUMMYSINK) << "DummySinkClient::sendCommand(const QString &cmd) called" << flush;
+}
+
+void DummySinkClient::sendCommand(const QByteArray &cmd)
+{
+    Q_UNUSED(cmd);
+    qMailLog(DUMMYSINK) << "DummySinkClient::sendCommand(const QByteArray &cmd) called" << flush;
+}
+
+void DummySinkClient::incomingData()
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::incomingData() called" << flush;
+
+    nextAction("send mail");
+}
+
+void DummySinkClient::nextAction(const QString &response)
+{
+    Q_UNUSED(response);
+
+    qMailLog(DUMMYSINK) << "DummySinkClient::incomingData(nextAction(const QString &response) called" << flush;
+
+    for(mailItr = mailList.begin(); mailItr != mailList.end(); mailItr++)
+    {
+	QMailMessageId msgId(mailItr->mail.id());
+
+        // Create new mail to add into store.
+        QMailMessage NewMail(mailItr->mail.serverUid(), mailItr->mail.parentAccountId());
+        NewMail.setBody(QMailMessageBody::fromData(mailItr->mail.body().data(), mailItr->mail.contentType(), mailItr->mail.transferEncoding()));
+        NewMail.setMessageType(mailItr->mail.messageType());
+        NewMail.setTo(mailItr->mail.to());
+        NewMail.setSubject(mailItr->mail.subject());
+        NewMail.setParentAccountId(mailItr->mail.parentAccountId());
+
+        // Print mail contents for debug information.
+        qMailLog(DUMMYSINK) << "******************************************" << flush;
+        qMailLog(DUMMYSINK) << "* Mail information being sent to network *" << flush;
+        qMailLog(DUMMYSINK) << "******************************************" << flush;
+        qMailLog(DUMMYSINK) << "";
+        qMailLog(DUMMYSINK) << "Message Type: "   << NewMail.messageType() << flush;
+        qMailLog(DUMMYSINK) << "Content Type: "   << (NewMail.contentType()).type() \
+                            << "Sub Type: "       << (NewMail.contentType()).subType() \
+                            << "Charset: "        << (NewMail.contentType()).charset() << flush;
+        qMailLog(DUMMYSINK) << "Encoding: "       << NewMail.transferEncoding() << flush;
+        qMailLog(DUMMYSINK) << "Size: "           << (NewMail.body()).data().length() << flush;
+        qMailLog(DUMMYSINK) << "Sending account: "<< NewMail.parentAccountId() << flush;
+
+        qMailLog(DUMMYSINK) << "Sending to: " << flush;
+        foreach(const QMailAddress& Addr, NewMail.recipients())
+        {
+            if (Addr.isEmailAddress())
+            {
+                qMailLog(DUMMYSINK) << "    " << Addr.address() << flush;
+            }
+        }
+
+        qMailLog(DUMMYSINK) << "";
+        qMailLog(DUMMYSINK) << "Subject: " << NewMail.subject() << flush;
+        qMailLog(DUMMYSINK) << "Body: " << (NewMail.body()).data() << flush;
+        qMailLog(DUMMYSINK) << "*******************END********************" << flush;
+
+    	// Set the message's message ID
+        NewMail.setHeaderField("Message-ID", "dummyMailHeader");
+
+        // Set mail size.
+        NewMail.setContentSize(NewMail.body().data().length());
+        NewMail.setSize(NewMail.contentSize());
+        NewMail.setPreviousParentFolderId(QMailFolderId(0));
+
+        if (!QMailStore::instance()->addMessage(&NewMail))
+    	{
+    		qWarning() << "Unable to update message after transmission:" << msgId;
+    	}
+
+        progressSendSize += (mailItr->mail.body()).data().length();
+        mailItr->mail.setStatus(Sent, true);
+        mailItr->mail.setParentFolderId(QMailFolderId(QMailFolder::SentFolder));
+        mailItr->mail.setPreviousParentFolderId(QMailFolderId(QMailFolder::OutboxFolder));
+
+        emit sent(progressSendSize);
+
+        if (!QMailStore::instance()->updateMessage(&mailItr->mail))
+        {
+            qWarning() << "Unable to update message after transmission:" << msgId;
+        }
+
+        emit messageTransmitted(msgId);
+        messageProcessed(msgId);
+        sendingId = QMailMessageId();
+    }
+
+    mailList.clear();
+    deactivateConnection();
+    emit sendCompleted();
+}
+
+void DummySinkClient::cancelTransfer()
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::cancelTransfer() called" << flush;
+
+    operationFailed(QMailServiceAction::Status::ErrCancel, tr("Cancelled by user"));
+}
+
+void DummySinkClient::messageProcessed(const QMailMessageId &id)
+{
+    Q_UNUSED(id);
+
+    qMailLog(DUMMYSINK) << "DummySinkClient::messageProcessed(const QMailMessageId &id) called" << flush;
+
+    emit progressChanged(progressSendSize, totalSendSize);
+}
+
+void DummySinkClient::operationFailed(int code, const QString &text)
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::operationFailed(int code, const QString &text) called" << flush;
+
+    if (ConnectionActive)
+    {
+        transport->close();
+        qMailLog(DUMMYSINK) << "Connection closed:" << text << flush;
+        
+        mailList.clear();
+    }
+
+    deactivateConnection();
+    emit errorOccurred(code, text);
+}
+
+void DummySinkClient::operationFailed(QMailServiceAction::Status::ErrorCode code, const QString &text)
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::operationFailed(QMailServiceAction::Status::ErrorCode code, const QString &text) called" << flush;
+    mailList.clear();
+
+    QString msg;
+    if (code == QMailServiceAction::Status::ErrUnknownResponse) {
+        if (config.id().isValid()) {
+            DummySinkConfiguration dummyCfg(config);
+            msg = dummyCfg.dummyServer() + ": ";
+        }
+    }
+    msg.append(text);
+
+    deactivateConnection();
+    emit errorOccurred(code, msg);
+}
+
+void DummySinkClient::deactivateConnection()
+{
+    qMailLog(DUMMYSINK) << "DummySinkClient::deactivateConnection() called" << flush;
+
+    // Close connection.
+    if(transport && transport->connected())
+        transport->close();
+
+    // Set connection is free.
+    ConnectionActive = false;
+    emit progressChanged(0, 0);
+}
diff --git a/src/plugins/messageservices/dummysink/dummysinkclient.h b/src/plugins/messageservices/dummysink/dummysinkclient.h
new file mode 100644
index 0000000..772e51c
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinkclient.h
@@ -0,0 +1,102 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMY_SINK_CLIENT_H
+#define DUMMY_SINK_CLIENT_H
+
+#include <qstring.h>
+#include <qobject.h>
+#include <qstringlist.h>
+#include <qlist.h>
+#include <qmailaccountconfiguration.h>
+#include <qmailmessage.h>
+#include <qmailmessageserver.h>
+#include <qmailtransport.h>
+
+struct RawEmail
+{
+    QString from;
+    QStringList to;
+    QMailMessage mail;
+};
+
+class DummySinkClient : public QObject
+{
+    Q_OBJECT
+
+public:
+    DummySinkClient(QObject* parent);
+    ~DummySinkClient();
+
+    QMailMessage::MessageType messageType() const;
+
+    void setAccount(const QMailAccountId &accountId);
+    QMailAccountId account() const;
+
+    void newConnection();
+    void cancelTransfer();
+
+    QMailServiceAction::Status::ErrorCode addMail(const QMailMessage& mail);
+
+signals:
+    void errorOccurred(int, const QString &);
+    void errorOccurred(QMailServiceAction::Status::ErrorCode, const QString &);
+    void updateStatus(const QString &);
+
+    void progressChanged(uint, uint);
+    void messageTransmitted(const QMailMessageId&);
+    void sendCompleted();
+
+protected slots:
+    void connected(QMailTransport::EncryptType encryptType);
+    void transportError(int, QString msg);
+    void readyRead();
+    void sent(qint64);
+
+private:
+    void deactivateConnection();
+    void sendCommand(const char *data, int len = -1);
+    void sendCommand(const QString &cmd);
+    void sendCommand(const QByteArray &cmd);
+    void incomingData();
+    void nextAction(const QString &response);
+    void messageProcessed(const QMailMessageId &id);
+
+    void operationFailed(int code, const QString &text);
+    void operationFailed(QMailServiceAction::Status::ErrorCode code, const QString &text);
+
+private:
+    enum TransferStatus
+    {
+        Init, Helo, Extension, StartTLS, TLS, Connected, Auth,
+        From, Recv, MRcv, Data, Body, Sent, Done
+    };
+
+    QMailAccountConfiguration config;
+    TransferStatus status;
+    QList<RawEmail> mailList;
+    QList<RawEmail>::Iterator mailItr;
+    QMailMessageId sendingId;
+    bool ConnectionActive;
+
+    QStringList::Iterator it;
+    QMailTransport *transport;
+
+    // SendMap maps id -> (units) to be sent
+    typedef QMap<QMailMessageId, uint> SendMap;
+    SendMap sendSize;
+    uint progressSendSize;
+    uint totalSendSize;
+
+    quint32 addressComponent;
+    QByteArray domainName;
+};
+
+#endif
diff --git a/src/plugins/messageservices/dummysink/dummysinkconfiguration.cpp b/src/plugins/messageservices/dummysink/dummysinkconfiguration.cpp
new file mode 100644
index 0000000..96a6a73
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinkconfiguration.cpp
@@ -0,0 +1,125 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummysinkconfiguration.h"
+
+
+DummySinkConfiguration::DummySinkConfiguration(const QMailAccountConfiguration &config)
+    : QMailServiceConfiguration(config, "dummysink")
+{
+}
+
+DummySinkConfiguration::DummySinkConfiguration(const QMailAccountConfiguration::ServiceConfiguration &svcCfg)
+    : QMailServiceConfiguration(svcCfg)
+{
+}
+
+QString DummySinkConfiguration::userName() const
+{
+    return value("username");
+}
+
+QString DummySinkConfiguration::emailAddress() const
+{
+    return value("address");
+}
+
+QString DummySinkConfiguration::dummyServer() const
+{
+    return value("server");
+}
+
+int DummySinkConfiguration::dummyPort() const
+{
+    return value("port", "25").toInt();
+}
+
+#ifndef QT_NO_OPENSSL
+
+QString DummySinkConfiguration::dummyUsername() const
+{
+    return value("dummyusername");
+}
+
+QString DummySinkConfiguration::dummyPassword() const
+{
+    return decodeValue(value("dummypassword"));
+}
+
+#endif
+
+int DummySinkConfiguration::dummyAuthentication() const
+{
+    return value("authentication", "0").toInt();
+}
+
+int DummySinkConfiguration::dummyEncryption() const
+{
+    return value("encryption", "0").toInt();
+}
+
+
+DummySinkConfigurationEditor::DummySinkConfigurationEditor(QMailAccountConfiguration *config)
+    : DummySinkConfiguration(*config)
+{
+}
+
+void DummySinkConfigurationEditor::setUserName(const QString& str)
+{
+    setValue("username",str);
+}
+
+void DummySinkConfigurationEditor::setEmailAddress(const QString &str)
+{
+    setValue("address", str);
+}
+
+void DummySinkConfigurationEditor::setDummySinkServer(const QString &str)
+{
+    setValue("server", str);
+}
+
+void DummySinkConfigurationEditor::setDummySinkPort(int i)
+{
+    setValue("port", QString::number(i));
+}
+
+#ifndef QT_NO_OPENSSL
+
+void DummySinkConfigurationEditor::setDummySinkUsername(const QString& str)
+{
+    setValue("dummyusername", str);
+}
+
+void DummySinkConfigurationEditor::setDummySinkPassword(const QString& str)
+{
+    setValue("dummypassword", encodeValue(str));
+}
+
+#endif
+
+#ifndef QT_NO_OPENSSL
+
+void DummySinkConfigurationEditor::setDummySinkAuthentication(int t)
+{
+    setValue("authentication", QString::number(t));
+}
+
+#endif
+
+#ifndef QT_NO_OPENSSL
+
+void DummySinkConfigurationEditor::setDummySinkEncryption(int t)
+{
+    setValue("encryption", QString::number(t));
+}
+
+#endif
+
diff --git a/src/plugins/messageservices/dummysink/dummysinkconfiguration.h b/src/plugins/messageservices/dummysink/dummysinkconfiguration.h
new file mode 100644
index 0000000..0264830
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinkconfiguration.h
@@ -0,0 +1,75 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMY_SINK_CONFIGURATION_H
+#define DUMMY_SINK_CONFIGURATION_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt Extended API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <qmailserviceconfiguration.h>
+
+class QTOPIAMAIL_EXPORT DummySinkConfiguration : public QMailServiceConfiguration
+{
+public:
+    enum AuthType {
+        Auth_NONE = 0,
+#ifndef QT_NO_OPENSSL
+        Auth_LOGIN = 1,
+        Auth_PLAIN = 2,
+#endif
+        Auth_INCOMING = 3
+    };
+
+    explicit DummySinkConfiguration(const QMailAccountConfiguration &config);
+    explicit DummySinkConfiguration(const QMailAccountConfiguration::ServiceConfiguration &svcCfg);
+
+    QString userName() const;
+    QString emailAddress() const;
+    QString dummyServer() const;
+    int dummyPort() const;
+#ifndef QT_NO_OPENSSL
+    QString dummyUsername() const;
+    QString dummyPassword() const;
+#endif
+    int dummyAuthentication() const;
+    int dummyEncryption() const;
+};
+
+class QTOPIAMAIL_EXPORT DummySinkConfigurationEditor : public DummySinkConfiguration
+{
+public:
+    explicit DummySinkConfigurationEditor(QMailAccountConfiguration *config);
+
+    void setUserName(const QString &str);
+    void setEmailAddress(const QString &str);
+    void setDummySinkServer(const QString &str);
+    void setDummySinkPort(int i);
+#ifndef QT_NO_OPENSSL
+    void setDummySinkUsername(const QString& username);
+    void setDummySinkPassword(const QString& password);
+#endif
+#ifndef QT_NO_OPENSSL
+    void setDummySinkAuthentication(int t);
+#endif
+#ifndef QT_NO_OPENSSL
+    void setDummySinkEncryption(int t);
+#endif
+};
+
+#endif
diff --git a/src/plugins/messageservices/dummysink/dummysinkservice.cpp b/src/plugins/messageservices/dummysink/dummysinkservice.cpp
new file mode 100644
index 0000000..7e4e9d7
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinkservice.cpp
@@ -0,0 +1,264 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummysinkservice.h"
+#include "dummysinksettings.h"
+#include <QtPlugin>
+#include <qmaillog.h>
+
+namespace { const QString serviceKey("dummysink"); }
+
+class DummySinkService::Sink : public QMailMessageSink
+{
+    Q_OBJECT
+
+public:
+    Sink(DummySinkService *service)
+        : QMailMessageSink(service),
+          _service(service)
+    {
+        connect(&_service->_client, SIGNAL(messageTransmitted(QMailMessageId)), this, SLOT(messageTransmitted(QMailMessageId)));
+        connect(&_service->_client, SIGNAL(sendCompleted()), this, SLOT(sendCompleted()));
+    }
+
+public slots:
+    virtual bool transmitMessages(const QMailMessageIdList &ids);
+
+    void messageTransmitted(const QMailMessageId &id);
+    void sendCompleted();
+
+private:
+    DummySinkService *_service;
+};
+
+bool DummySinkService::Sink::transmitMessages(const QMailMessageIdList &ids)
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::Sink::transmitMessages() called" << flush;
+
+    QMailServiceAction::Status::ErrorCode errorCode = QMailServiceAction::Status::ErrNoError;
+    QString errorText;
+
+    if (ids.isEmpty()) {
+        errorCode = QMailServiceAction::Status::ErrInvalidData;
+        errorText = tr("No messages to transmit");
+    } else {
+        foreach (const QMailMessageId id, ids) {
+            QMailMessage message(id);
+            if ((errorCode = _service->_client.addMail(message)) != QMailServiceAction::Status::ErrNoError) {
+                errorText = tr("Unable to addMail");
+                break;
+            }
+        }
+    }
+
+    if (errorCode == QMailServiceAction::Status::ErrNoError) {
+        _service->_client.newConnection();
+        return true;
+    }
+
+    _service->errorOccurred(errorCode, errorText);
+    return false;
+}
+
+void DummySinkService::Sink::messageTransmitted(const QMailMessageId &id)
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::Sink::messageTransmitted() called" << flush;
+
+    emit messagesTransmitted(QMailMessageIdList() << id);
+}
+
+void DummySinkService::Sink::sendCompleted()
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::Sink::sendCompleted() called" << flush;
+
+   emit _service->activityChanged(QMailServiceAction::Successful);
+   emit _service->actionCompleted(true);
+}
+
+
+DummySinkService::DummySinkService(const QMailAccountId &accountId)
+    : QMailMessageService(),
+      _client(this),
+      _sink(new Sink(this))
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::DummySinkService(const QMailAccountId &accountId) called" << flush;
+
+    connect(&_client, SIGNAL(progressChanged(uint, uint)), this, SIGNAL(progressChanged(uint, uint)));
+
+    connect(&_client, SIGNAL(errorOccurred(int, QString)), this, SLOT(errorOccurred(int, QString)));
+    connect(&_client, SIGNAL(errorOccurred(QMailServiceAction::Status::ErrorCode, QString)), this, SLOT(errorOccurred(QMailServiceAction::Status::ErrorCode, QString)));
+    connect(&_client, SIGNAL(updateStatus(QString)), this, SLOT(updateStatus(QString)));
+
+    _client.setAccount(accountId);
+}
+
+DummySinkService::~DummySinkService()
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::~DummySinkService() called" << flush;
+
+    delete _sink;
+}
+
+QString DummySinkService::service() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::service() called" << flush;
+
+    return serviceKey;
+}
+
+QMailAccountId DummySinkService::accountId() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::accountId() called" << flush;
+
+    return _client.account();
+}
+
+bool DummySinkService::hasSink() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::hasSink() called" << flush;
+
+    return true;
+}
+
+QMailMessageSink &DummySinkService::sink() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::sink() called" << flush;
+    qMailLog(DUMMYSINK) << "DummySinkService::sink(), _sink =" << _sink;
+
+    return *_sink;
+}
+
+bool DummySinkService::available() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::available() called, return true." << flush;
+
+    return true;
+}
+
+bool DummySinkService::cancelOperation()
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::cancelOperation() called" << flush;
+
+    _client.cancelTransfer();
+    return true;
+}
+
+void DummySinkService::errorOccurred(int code, const QString &text)
+{
+    qMailLog(DUMMYSINK) << "DummySinkService::errorOccurred(int code, const QString &text) called" << flush;
+
+    updateStatus(code, text, _client.account());
+    emit actionCompleted(false);
+}
+
+void DummySinkService::errorOccurred(QMailServiceAction::Status::ErrorCode code, const QString &text)
+{
+    updateStatus(code, text, _client.account());
+    emit actionCompleted(false);
+}
+
+void DummySinkService::updateStatus(const QString &text)
+{
+    updateStatus(QMailServiceAction::Status::ErrNoError, text, _client.account());
+}
+
+
+class DummySinkConfigurator : public QMailMessageServiceConfigurator
+{
+public:
+    DummySinkConfigurator();
+    ~DummySinkConfigurator();
+
+    virtual QString service() const;
+    virtual QString displayName() const;
+
+    virtual QMailMessageServiceEditor *createEditor(QMailMessageServiceFactory::ServiceType type);
+};
+
+DummySinkConfigurator::DummySinkConfigurator()
+{
+    qMailLog(DUMMYSINK) << "DummySinkConfigurator::DummySinkConfigurator() called" << flush;
+}
+
+DummySinkConfigurator::~DummySinkConfigurator()
+{
+    qMailLog(DUMMYSINK) << "DummySinkConfigurator::~DummySinkConfigurator() called" << flush;
+}
+
+QString DummySinkConfigurator::service() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkConfigurator::service() called" << flush;
+
+    return serviceKey;
+}
+
+QString DummySinkConfigurator::displayName() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkConfigurator::displayName() called" << flush;
+
+    return qApp->translate("QMailMessageService", "DummySink");
+}
+
+QMailMessageServiceEditor *DummySinkConfigurator::createEditor(QMailMessageServiceFactory::ServiceType type)
+{
+    qMailLog(DUMMYSINK) << "DummySinkConfigurator::DummySinkConfigurator::createEditor(QMailMessageServiceFactory::ServiceType type) called" << flush;
+
+    if (type == QMailMessageServiceFactory::Sink)
+        return new DummySinkSettings;
+
+    return 0;
+}
+
+Q_EXPORT_PLUGIN2(dummysink,DummySinkServicePlugin)
+
+DummySinkServicePlugin::DummySinkServicePlugin()
+    : QMailMessageServicePlugin()
+{
+    qMailLog(DUMMYSINK) << "DummySinkServicePlugin::DummySinkServicePlugin() called" << flush;
+}
+
+QString DummySinkServicePlugin::key() const
+{
+    qMailLog(DUMMYSINK) << "DummySinkServicePlugin::key() called" << flush;
+
+    return serviceKey;
+}
+
+bool DummySinkServicePlugin::supports(QMailMessageServiceFactory::ServiceType type) const
+{
+    qMailLog(DUMMYSINK) << "DummySinkServicePlugin::supports(QMailMessageServiceFactory::ServiceType type) called" << flush;
+
+    return (type == QMailMessageServiceFactory::Sink);
+}
+
+bool DummySinkServicePlugin::supports(QMailMessage::MessageType type) const
+{
+    qMailLog(DUMMYSINK) << "DummySinkServicePlugin::supports(QMailMessage::MessageType type) called" << flush;
+
+    return (type == QMailMessage::Email);
+}
+
+QMailMessageService *DummySinkServicePlugin::createService(const QMailAccountId &id)
+{
+    qMailLog(DUMMYSINK) << "DummySinkServicePlugin::createService(const QMailAccountId &id) called" << flush;
+
+    return new DummySinkService(id);
+}
+
+QMailMessageServiceConfigurator *DummySinkServicePlugin::createServiceConfigurator()
+{
+    qMailLog(DUMMYSINK) << "DummySinkServicePlugin::createServiceConfigurator() called" << flush;
+
+    return new DummySinkConfigurator();
+}
+
+
+#include "dummysinkservice.moc"
+
diff --git a/src/plugins/messageservices/dummysink/dummysinkservice.h b/src/plugins/messageservices/dummysink/dummysinkservice.h
new file mode 100644
index 0000000..d9f240f
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinkservice.h
@@ -0,0 +1,72 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMY_SINK_SERVICE_H
+#define DUMMY_SINK_SERVICE_H
+
+#include "dummysinkclient.h"
+#include <qmailmessageservice.h>
+#include <qmaillog.h>
+
+QLOG_ENABLE(DUMMYSINK)
+
+class DummySinkService : public QMailMessageService
+{
+    Q_OBJECT
+
+public:
+    using QMailMessageService::updateStatus;
+
+    DummySinkService(const QMailAccountId &accountId);
+    ~DummySinkService();
+
+    virtual QString service() const;
+    virtual QMailAccountId accountId() const;
+
+    virtual bool hasSink() const;
+    virtual QMailMessageSink &sink() const;
+
+    virtual bool available() const;
+
+public slots:
+    virtual bool cancelOperation();
+
+protected slots:
+    void errorOccurred(int code, const QString &text);
+    void errorOccurred(QMailServiceAction::Status::ErrorCode code, const QString &text);
+
+    void updateStatus(const QString& text);
+
+private:
+    class Sink;
+    friend class Sink;
+
+    DummySinkClient _client;
+    Sink *_sink;
+};
+
+
+class DummySinkServicePlugin : public QMailMessageServicePlugin
+{
+    Q_OBJECT
+
+public:
+    DummySinkServicePlugin();
+
+    virtual QString key() const;
+    virtual bool supports(QMailMessageServiceFactory::ServiceType type) const;
+    virtual bool supports(QMailMessage::MessageType type) const;
+
+    virtual QMailMessageService *createService(const QMailAccountId &id);
+    virtual QMailMessageServiceConfigurator *createServiceConfigurator();
+};
+
+
+#endif
diff --git a/src/plugins/messageservices/dummysink/dummysinksettings.cpp b/src/plugins/messageservices/dummysink/dummysinksettings.cpp
new file mode 100644
index 0000000..9a9b449
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinksettings.cpp
@@ -0,0 +1,298 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummysinksettings.h"
+#include "dummysinkconfiguration.h"
+#include <QGridLayout>
+#include <QLineEdit>
+#include <QTextEdit>
+#include <QValidator>
+#include <qmailaccount.h>
+#include <qmailaccountconfiguration.h>
+#include <qmailtransport.h>
+#include <QDialog>
+
+namespace {
+
+const QString serviceKey("dummysink");
+
+class SigEntry : public QDialog
+{
+    Q_OBJECT
+
+public:
+    SigEntry(QWidget *parent, const char* name, Qt::WFlags fl = 0);
+
+    void setEntry(QString sig);
+    QString entry() const;
+
+private:
+    QTextEdit *input;
+};
+
+SigEntry::SigEntry(QWidget *parent, const char *name, Qt::WFlags fl)
+    : QDialog(parent, fl)
+{
+    setObjectName(name);
+    setWindowTitle(tr("Signature"));
+
+    QGridLayout *grid = new QGridLayout(this);
+    input = new QTextEdit(this);
+    grid->addWidget(input, 0, 0);
+}
+
+void SigEntry::setEntry(QString sig)
+{
+    input->insertPlainText(sig);
+}
+
+QString SigEntry::entry() const
+{
+    return input->toPlainText();
+}
+
+
+class PortValidator : public QValidator
+{
+public:
+    PortValidator(QWidget *parent = 0, const char *name = 0);
+
+    QValidator::State validate(QString &str, int &) const;
+};
+
+PortValidator::PortValidator(QWidget *parent, const char *name)
+    : QValidator(parent)
+{
+    setObjectName(name);
+}
+
+QValidator::State PortValidator::validate(QString &str, int &) const
+{
+    // allow empty strings, as it's a bit awkward to edit otherwise
+    if ( str.isEmpty() )
+        return QValidator::Acceptable;
+
+    bool ok = false;
+    int i = str.toInt(&ok);
+    if ( !ok )
+        return QValidator::Invalid;
+
+    if ( i <= 0 || i >= 65536 )
+        return QValidator::Invalid;
+
+    return QValidator::Acceptable;
+}
+
+
+const DummySinkConfiguration::AuthType authenticationType[] = {
+    DummySinkConfiguration::Auth_NONE,
+#ifndef QT_NO_OPENSSL
+    DummySinkConfiguration::Auth_LOGIN,
+    DummySinkConfiguration::Auth_PLAIN,
+#endif
+    DummySinkConfiguration::Auth_INCOMING
+};
+
+#ifndef QT_NO_OPENSSL
+int authenticationIndex(int type)
+{
+    const int numTypes = sizeof(authenticationType)/sizeof(DummySinkConfiguration::AuthType);
+    for (int i = 0; i < numTypes; ++i)
+        if (type == authenticationType[i])
+            return i;
+
+    return 0;
+}
+#endif
+
+}
+
+
+DummySinkSettings::DummySinkSettings()
+    : QMailMessageServiceEditor(),
+      addressModified(false)
+{
+    setupUi(this);
+    setLayoutDirection(qApp->layoutDirection());
+
+    connect(setSignatureButton, SIGNAL(clicked()), this, SLOT(sigPressed()));
+    connect(authentication, SIGNAL(currentIndexChanged(int)), this, SLOT(authChanged(int)));
+    connect(emailInput, SIGNAL(textChanged(QString)), this, SLOT(emailModified()));
+
+    const QString uncapitalised("email noautocapitalization");
+
+    // These fields should not be autocapitalised
+
+    PortInput->setValidator(new PortValidator(this));
+
+    PasswordInput->setEchoMode(QLineEdit::PasswordEchoOnEdit);
+
+#ifdef QT_NO_OPENSSL
+    encryption->hide();
+    lblEncryption->hide();
+    authentication->hide();
+    lblAuthentication->hide();
+    dummyUsernameInput->hide();
+    lblDummyUsername->hide();
+    dummyPasswordInput->hide();
+    lblDummyPassword->hide();
+#else
+    PasswordInput->setEchoMode(QLineEdit::PasswordEchoOnEdit);
+#endif
+}
+
+void DummySinkSettings::sigPressed()
+{
+    if (sigCheckBox->isChecked()) {
+        QString sigText;
+        if (signature.isEmpty())
+            sigText = QLatin1String("~~\n") + nameInput->text();
+        else
+            sigText = signature;
+
+        SigEntry sigEntry(this, "sigEntry", static_cast<Qt::WFlags>(1));
+        sigEntry.setEntry(sigText);
+        if (sigEntry.exec() == QDialog::Accepted)
+            signature = sigEntry.entry();
+    }
+}
+
+void DummySinkSettings::emailModified()
+{
+    addressModified = true;
+}
+
+void DummySinkSettings::authChanged(int index)
+{
+#ifndef QT_NO_OPENSSL
+    DummySinkConfiguration::AuthType type = authenticationType[index];
+    bool enableCredentials = (type == DummySinkConfiguration::Auth_LOGIN || type == DummySinkConfiguration::Auth_PLAIN);
+
+    UsernameInput->setEnabled(enableCredentials);
+    lblUsername->setEnabled(enableCredentials);
+    PasswordInput->setEnabled(enableCredentials);
+    lblPassword->setEnabled(enableCredentials);
+
+    if (!enableCredentials) {
+        UsernameInput->clear();
+        PasswordInput->clear();
+    }
+#else
+    Q_UNUSED(index);
+#endif
+}
+
+void DummySinkSettings::displayConfiguration(const QMailAccount &account, const QMailAccountConfiguration &config)
+{
+#ifndef QT_NO_OPENSSL
+    // Any reason to re-enable this facility?
+    //authentication->setItemText(3, tr("Incoming");
+#endif
+
+    if (!config.services().contains(serviceKey)) {
+        // New account
+        emailInput->setText("");
+        ServerInput->setText("");
+        PortInput->setText("25");
+#ifndef QT_NO_OPENSSL
+        UsernameInput->setText("");
+        PasswordInput->setText("");
+        encryption->setCurrentIndex(0);
+        authentication->setCurrentIndex(0);
+        UsernameInput->setEnabled(false);
+        lblUsername->setEnabled(false);
+        PasswordInput->setEnabled(false);
+        lblPassword->setEnabled(false);
+#endif
+        signature = QString();
+    } else {
+        DummySinkConfiguration dummyConfig(config);
+
+        emailInput->setText(dummyConfig.emailAddress());
+        ServerInput->setText(dummyConfig.dummyServer());
+        PortInput->setText(QString::number(dummyConfig.dummyPort()));
+#ifndef QT_NO_OPENSSL
+        UsernameInput->setText(dummyConfig.dummyUsername());
+        PasswordInput->setText(dummyConfig.dummyPassword());
+        authentication->setCurrentIndex(authenticationIndex(dummyConfig.dummyAuthentication()));
+        encryption->setCurrentIndex(static_cast<int>(dummyConfig.dummyEncryption()));
+
+        DummySinkConfiguration::AuthType type = authenticationType[authentication->currentIndex()];
+        const bool enableCredentials(type == DummySinkConfiguration::Auth_LOGIN || type == DummySinkConfiguration::Auth_PLAIN);
+        UsernameInput->setEnabled(enableCredentials);
+        lblUsername->setEnabled(enableCredentials);
+        PasswordInput->setEnabled(enableCredentials);
+        lblPassword->setEnabled(enableCredentials);
+#endif
+
+        defaultMailCheckBox->setChecked(account.status() & QMailAccount::PreferredSender);
+        sigCheckBox->setChecked(account.status() & QMailAccount::AppendSignature);
+        signature = account.signature();
+    }
+}
+
+bool DummySinkSettings::updateAccount(QMailAccount *account, QMailAccountConfiguration *config)
+{
+    QString username(nameInput->text());
+    QString address(emailInput->text());
+
+    if (!username.isEmpty() || !address.isEmpty()) {
+        account->setFromAddress(QMailAddress(username, address)); 
+    }
+
+    bool result;
+    int port = PortInput->text().toInt(&result);
+    if ( (!result) ) {
+        // should only happen when the string is empty, since we use a validator.
+        port = 25;
+    }
+
+    if (!config->services().contains(serviceKey))
+        config->addServiceConfiguration(serviceKey);
+
+    DummySinkConfigurationEditor dummyConfig(config);
+
+    dummyConfig.setVersion(100);
+    dummyConfig.setType(QMailServiceConfiguration::Sink);
+
+    if ((!addressModified) && (address.isEmpty())) {
+        // Try to guess email address
+        QString server(dummyConfig.dummyServer());
+        if (server.count('.')) {
+            address = username + "@" + server.mid(server.indexOf('.') + 1, server.length());
+        } else if (server.count('.') == 1) {
+            address = username + "@" + server;
+        }
+    }
+    dummyConfig.setUserName(username);
+    dummyConfig.setEmailAddress(address);
+    dummyConfig.setDummySinkServer(ServerInput->text());
+    dummyConfig.setDummySinkPort(port);
+#ifndef QT_NO_OPENSSL
+    dummyConfig.setDummySinkUsername(UsernameInput->text());
+    dummyConfig.setDummySinkPassword(PasswordInput->text());
+    dummyConfig.setDummySinkAuthentication(authenticationType[authentication->currentIndex()]);
+    dummyConfig.setDummySinkEncryption(static_cast<QMailTransport::EncryptType>(encryption->currentIndex()));
+#endif
+
+    account->setStatus(QMailAccount::PreferredSender, defaultMailCheckBox->isChecked());
+    account->setStatus(QMailAccount::AppendSignature, sigCheckBox->isChecked());
+    account->setSignature(signature);
+
+    // Do we have a configuration we can use?
+    if (!dummyConfig.dummyServer().isEmpty() && !dummyConfig.emailAddress().isEmpty())
+        account->setStatus(QMailAccount::CanTransmit, true);
+
+    return true;
+}
+
+
+#include "dummysinksettings.moc"
+
diff --git a/src/plugins/messageservices/dummysink/dummysinksettings.h b/src/plugins/messageservices/dummysink/dummysinksettings.h
new file mode 100644
index 0000000..702103f
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinksettings.h
@@ -0,0 +1,42 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMY_SINK_SETTINGS_H
+#define DUMMY_SINK_SETTINGS_H
+
+#include "ui_dummysinksettings.h"
+#include <qmailmessageservice.h>
+
+class QMailAccount;
+class QMailAccountConfiguration;
+
+
+class DummySinkSettings : public QMailMessageServiceEditor, private Ui::DummySinkSettings
+{
+    Q_OBJECT
+
+public:
+    DummySinkSettings();
+
+    virtual void displayConfiguration(const QMailAccount &account, const QMailAccountConfiguration &config);
+    virtual bool updateAccount(QMailAccount *account, QMailAccountConfiguration *config);
+
+private slots:
+    void sigPressed();
+    void emailModified();
+    void authChanged(int index);
+
+private:
+    bool addressModified;
+    QString signature;
+};
+
+#endif
+
diff --git a/src/plugins/messageservices/dummysink/dummysinksettings.ui b/src/plugins/messageservices/dummysink/dummysinksettings.ui
new file mode 100644
index 0000000..292ee72
--- /dev/null
+++ b/src/plugins/messageservices/dummysink/dummysinksettings.ui
@@ -0,0 +1,357 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>DummySinkSettings</class>
+ <widget class="QWidget" name="DummySinkSettings">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>400</width>
+    <height>300</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>Form</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <property name="margin">
+    <number>0</number>
+   </property>
+   <item>
+    <widget class="QScrollArea" name="scrollArea">
+     <property name="focusPolicy">
+      <enum>Qt::NoFocus</enum>
+     </property>
+     <property name="frameShape">
+      <enum>QFrame::NoFrame</enum>
+     </property>
+     <property name="lineWidth">
+      <number>0</number>
+     </property>
+     <property name="horizontalScrollBarPolicy">
+      <enum>Qt::ScrollBarAlwaysOff</enum>
+     </property>
+     <property name="widgetResizable">
+      <bool>true</bool>
+     </property>
+     <widget class="QWidget" name="scrollAreaWidgetContents">
+      <property name="geometry">
+       <rect>
+        <x>0</x>
+        <y>0</y>
+        <width>382</width>
+        <height>330</height>
+       </rect>
+      </property>
+      <layout class="QGridLayout">
+       <item row="0" column="0">
+        <widget class="QLabel" name="nameLabel">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>From</string>
+         </property>
+         <property name="buddy">
+          <cstring>nameInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="0" column="1">
+        <widget class="QLineEdit" name="nameInput">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+        </widget>
+       </item>
+       <item row="1" column="0">
+        <widget class="QLabel" name="emailLabel">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Email</string>
+         </property>
+         <property name="buddy">
+          <cstring>emailInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="1" column="1">
+        <widget class="QLineEdit" name="emailInput">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+        </widget>
+       </item>
+       <item row="2" column="0">
+        <widget class="QLabel" name="serverLabel_2">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Server</string>
+         </property>
+         <property name="buddy">
+          <cstring>ServerInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="2" column="1">
+        <widget class="QLineEdit" name="ServerInput">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+        </widget>
+       </item>
+       <item row="3" column="0">
+        <widget class="QLabel" name="portLabel_2">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Port</string>
+         </property>
+         <property name="buddy">
+          <cstring>PortInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="3" column="1">
+        <widget class="QLineEdit" name="PortInput">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+        </widget>
+       </item>
+       <item row="4" column="0">
+        <widget class="QLabel" name="lblEncryption">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Encryption</string>
+         </property>
+         <property name="buddy">
+          <cstring>encryption</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="4" column="1">
+        <widget class="QComboBox" name="encryption">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <item>
+          <property name="text">
+           <string>None</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>SSL</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>TLS</string>
+          </property>
+         </item>
+        </widget>
+       </item>
+       <item row="5" column="0">
+        <widget class="QLabel" name="lblAuthentication">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Authentication</string>
+         </property>
+         <property name="buddy">
+          <cstring>authentication</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="5" column="1">
+        <widget class="QComboBox" name="authentication">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <item>
+          <property name="text">
+           <string>None</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>Login</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>Plain</string>
+          </property>
+         </item>
+        </widget>
+       </item>
+       <item row="6" column="0">
+        <widget class="QLabel" name="lblUsername">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Username</string>
+         </property>
+         <property name="buddy">
+          <cstring>UsernameInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="6" column="1">
+        <widget class="QLineEdit" name="UsernameInput">
+         <property name="enabled">
+          <bool>false</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+        </widget>
+       </item>
+       <item row="7" column="0">
+        <widget class="QLabel" name="lblPassword">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Password</string>
+         </property>
+         <property name="buddy">
+          <cstring>PasswordInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="7" column="1">
+        <widget class="QLineEdit" name="PasswordInput">
+         <property name="enabled">
+          <bool>false</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="echoMode">
+          <enum>QLineEdit::Password</enum>
+         </property>
+        </widget>
+       </item>
+       <item row="9" column="0">
+        <widget class="QCheckBox" name="sigCheckBox">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Signature</string>
+         </property>
+        </widget>
+       </item>
+       <item row="9" column="1">
+        <widget class="QToolButton" name="setSignatureButton">
+         <property name="enabled">
+          <bool>false</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Set...</string>
+         </property>
+        </widget>
+       </item>
+       <item row="10" column="0" colspan="2">
+        <widget class="QCheckBox" name="defaultMailCheckBox">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Default sending account</string>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </widget>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>nameInput</tabstop>
+  <tabstop>emailInput</tabstop>
+  <tabstop>ServerInput</tabstop>
+  <tabstop>PortInput</tabstop>
+  <tabstop>encryption</tabstop>
+  <tabstop>authentication</tabstop>
+  <tabstop>UsernameInput</tabstop>
+  <tabstop>PasswordInput</tabstop>
+  <tabstop>sigCheckBox</tabstop>
+  <tabstop>setSignatureButton</tabstop>
+  <tabstop>defaultMailCheckBox</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/src/plugins/messageservices/dummysource/dummyauthenticator.cpp b/src/plugins/messageservices/dummysource/dummyauthenticator.cpp
new file mode 100644
index 0000000..4e4fb28
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummyauthenticator.cpp
@@ -0,0 +1,57 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummyauthenticator.h"
+
+#include "dummyconfiguration.h"
+
+#include <qmailauthenticator.h>
+#include <qmailtransport.h>
+
+
+bool DummySourceAuthenticator::useEncryption(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
+{
+#ifdef QT_NO_OPENSSL
+    return false;
+#else
+    DummySourceConfiguration dummyCfg(svcCfg);
+    bool useTLS(dummyCfg.mailEncryption() == QMailTransport::Encrypt_TLS);
+
+    if (!capabilities.contains("STLS")) {
+        if (useTLS) {
+            qWarning() << "Server does not support TLS - continuing unencrypted";
+        }
+    } else {
+        if (useTLS) {
+            return true;
+        } else {
+            if (!capabilities.contains("USER")) {
+                qWarning() << "Server does not support unencrypted USER - using encryption";
+                return true;
+            }
+        }
+    }
+
+    return QMailAuthenticator::useEncryption(svcCfg, capabilities);
+#endif
+}
+
+QList<QByteArray> DummySourceAuthenticator::getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities)
+{
+    QList<QByteArray> result;
+
+    return result;
+}
+
+QByteArray DummySourceAuthenticator::getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge)
+{
+    return QMailAuthenticator::getResponse(svcCfg, challenge);
+}
+
diff --git a/src/plugins/messageservices/dummysource/dummyauthenticator.h b/src/plugins/messageservices/dummysource/dummyauthenticator.h
new file mode 100644
index 0000000..f3ff1f9
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummyauthenticator.h
@@ -0,0 +1,28 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMYAUTHENTICATOR_H
+#define DUMMYAUTHENTICATOR_H
+
+#include <qmailaccountconfiguration.h>
+
+#include <QByteArray>
+#include <QStringList>
+
+class DummySourceAuthenticator
+{
+public:
+    static bool useEncryption(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+    static QList<QByteArray> getAuthentication(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QStringList &capabilities);
+    static QByteArray getResponse(const QMailAccountConfiguration::ServiceConfiguration &svcCfg, const QByteArray &challenge);
+};
+
+#endif
+
diff --git a/src/plugins/messageservices/dummysource/dummyclient.cpp b/src/plugins/messageservices/dummysource/dummyclient.cpp
new file mode 100644
index 0000000..3cf74cd
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummyclient.cpp
@@ -0,0 +1,471 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummyclient.h"
+#include "dummyservice.h"
+#include "dummyauthenticator.h"
+#include "dummyconfiguration.h"
+
+#include <longstream_p.h>
+#include <longstring_p.h>
+#include <qmailstore.h>
+#include <qmailtransport.h>
+#include <qmaillog.h>
+
+#include <limits.h>
+
+DummySourceClient::DummySourceClient(QObject* parent)
+    : QObject(parent),
+      ConnectionActive(false),
+      transport(NULL),
+      timer(NULL)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::DummySourceClient(QObject* parent) called" << flush;
+
+    // If timer is not created, create for the first time.
+    int timerInterval = 7;
+    if(!timer)
+    {
+        // Create timer and set interval to timerInterval seconds.
+        timer = new QTimer(this);
+        timer->setInterval(timerInterval * 1000);
+
+        // Connect the slot to call when interval elapses.
+        connect(timer, SIGNAL(timeout()), SLOT(incomingData()));
+    }
+}
+
+DummySourceClient::~DummySourceClient()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::~DummySourceClient(QObject* parent) called" << flush;
+
+    // Close all connections and disable timer.
+    deactivateConnection();
+
+    // Free allocated memory.
+    delete timer;
+    delete transport;
+}
+
+QMailMessage::MessageType DummySourceClient::messageType() const
+{
+    return QMailMessage::Email;
+}
+
+void DummySourceClient::newConnection()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::newConnection() called" << flush;
+
+    // Check if a connection is already open.
+    if(ConnectionActive)
+    {
+        qMailLog(DUMMYSOURCE) << "Plugin instance already running." << flush;
+        operationFailed(QMailServiceAction::Status::ErrConnectionInUse, "Plugin instance already running");
+        return;
+    }
+
+    // Initliaze data members.
+    serverSize.clear();
+
+    // Re-load the configuration for this account
+    config = QMailAccountConfiguration(config.id());
+
+    DummySourceConfiguration dummyCfg(config);
+    if ( dummyCfg.mailServer().isEmpty() )
+    {
+        retrieveOperationCompleted();
+        return;
+    }
+
+    if (!transport)
+    {
+            // Set up the transport
+            transport = new QMailTransport("DUMMYSOURCE");
+
+            connect(transport, SIGNAL(updateStatus(QString)), this, SIGNAL(updateStatus(QString)));
+            connect(transport, SIGNAL(connected(QMailTransport::EncryptType)), this, SLOT(connected(QMailTransport::EncryptType)));
+            connect(transport, SIGNAL(errorOccurred(int,QString)), this, SLOT(transportError(int,QString)));
+            connect(transport, SIGNAL(readyRead()), this, SLOT(incomingData()));
+    }
+    emit updateStatus(tr("Connecting..."));
+
+    //  transport->open(dummyCfg.mailServer(), dummyCfg.mailPort(), static_cast<QMailTransport::EncryptType>(dummyCfg.mailEncryption()));
+    emit connected(QMailTransport::Encrypt_NONE);
+
+    // Acknowledge to application and keep adding mails in background.
+    //retrievalCompleted();
+}
+
+void DummySourceClient::setAccount(const QMailAccountId &id)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::setAccount() called" << flush;
+
+    if ((transport && transport->inUse()) && (id != config.id())) {
+        QString msg("Cannot open account; transport in use");
+        emit errorOccurred(QMailServiceAction::Status::ErrConnectionInUse, msg);
+        return;
+    }
+
+    config = QMailAccountConfiguration(id);
+}
+
+QMailAccountId DummySourceClient::account() const
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::account() called" << flush;
+
+    return config.id();
+}
+
+void DummySourceClient::setOperation(QMailRetrievalAction::RetrievalSpecification spec)
+{
+    Q_UNUSED(spec);
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::setOperation() called" << flush;
+}
+
+void DummySourceClient::setDeleteOperation()
+{
+}
+
+void DummySourceClient::setSelectedMails(const SelectionMap& data)
+{
+    Q_UNUSED(data);
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::setSelectedMails() called" << flush;
+}
+
+void DummySourceClient::connected(QMailTransport::EncryptType encryptType)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::connected() called" << flush;
+
+    DummySourceConfiguration dummyCfg(config);
+    if (dummyCfg.mailEncryption() == encryptType) {
+        qMailLog(DUMMYSOURCE) << "Connected" << flush;
+        emit updateStatus(tr("Connected"));
+    }
+
+    // Set connection is busy.
+    ConnectionActive = true;
+
+    // If timer not active, start timer.
+    if(timer && !timer->isActive())
+    {
+        timer->start();
+
+        // Update request status.
+        emit updateStatus(tr("Logging in"));
+    }
+}
+
+void DummySourceClient::transportError(int status, QString msg)
+{
+    operationFailed(status, msg);
+}
+
+void DummySourceClient::closeConnection()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::closeConnection() called" << flush;
+
+    if(transport && transport->connected())
+        transport->close();
+}
+
+void DummySourceClient::sendCommand(const char *data, int len)
+{
+    Q_UNUSED(data);
+    Q_UNUSED(len);
+}
+
+void DummySourceClient::sendCommand(const QString& cmd)
+{
+    Q_UNUSED(cmd);
+}
+
+void DummySourceClient::sendCommand(const QByteArray& cmd)
+{
+    Q_UNUSED(cmd);
+}
+
+QString DummySourceClient::readResponse()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::readResponse() called" << flush;
+
+    QString response = transport->readLine();
+
+    if (response.length() > 1) {
+        qMailLog(DUMMYSOURCE) << "RECV:" << qPrintable(response.left(response.length() - 2));
+    }
+
+    return response;
+}
+
+void DummySourceClient::incomingData()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::incomingData() called" << flush;
+
+    // Show update and progress status.
+    emit updateStatus(tr("Connecting..."));
+    emit progressChanged(100, 0);
+
+    // Call action to be taken.
+    nextAction();
+
+    #if 0
+    int MaxMsgs = 7;
+    static int mailCount = 1;
+
+    // Call action to be taken.
+    nextAction();
+
+    // Resets the service request expiry timer.
+    emit progressChanged(mailCount, MaxMsgs);
+
+    if(mailCount >= MaxMsgs)
+    {
+        qMailLog(DUMMYSOURCE) << " Sent " << MaxMsgs << "messages, now clearing timer." << flush;
+
+        mailCount = 1;
+        timer->stop();
+        emit updateStatus(tr("Logging out"));
+
+        retrieveOperationCompleted();
+
+        return;
+    }
+
+    mailCount++;
+#endif
+}
+
+void DummySourceClient::processResponse(const QString &response)
+{
+    Q_UNUSED(response);
+
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::processResponse() called" << flush;
+}
+
+void DummySourceClient::nextAction()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::nextAction() called" << flush;
+
+    // Show update and progress status.
+    emit progressChanged(100, 25);
+    emit updateStatus(tr("Retrieving new mail."));
+
+    // Create and add a new mail to store.
+    createMail();
+
+    // Show update and progress status.
+    emit updateStatus(tr("Message received"));
+    emit progressChanged(100, 100);    
+}
+
+int DummySourceClient::msgPosFromUidl(QString uidl)
+{
+    Q_UNUSED(uidl);
+    return 0;
+}
+
+int DummySourceClient::nextMsgServerPos()
+{
+    return 0;
+}
+
+// get the reported server size from stored list
+uint DummySourceClient::getSize(int pos)
+{
+    QMap<int, uint>::const_iterator it = serverSize.find(pos);
+    if (it != serverSize.end())
+        return it.value();
+
+    return -1;
+}
+
+void DummySourceClient::uidlIntegrityCheck()
+{
+}
+
+namespace {
+
+bool hasAttachments(const QMailMessagePartContainer &partContainer)
+{
+    for (uint i = 0; i < partContainer.partCount(); ++i) {
+        const QMailMessagePart &part(partContainer.partAt(i));
+
+        QMailMessageContentDisposition disposition(part.contentDisposition());
+        if (!disposition.isNull() && (disposition.type() == QMailMessageContentDisposition::Attachment)) {
+            return true;
+        } else if (part.multipartType() != QMailMessage::MultipartNone) {
+            if (hasAttachments(part))
+                return true;
+        }
+    }
+    return false;
+}
+
+}
+
+void DummySourceClient::createMail()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::createMail() called" << flush;
+
+    // Create mail message instance.
+    QMailMessage mail;
+
+    // Set basic mail parameters.
+    mail.setMessageType( QMailMessage::Email );
+    mail.setServerUid("DummyMsgUid");
+    mail.setStatus(QMailMessage::New, true);
+    mail.setStatus(QMailMessage::Incoming, true);
+    mail.setParentFolderId(QMailFolderId(QMailFolder::InboxFolder));
+    mail.setDate(QMailTimeStamp::currentDateTime());
+    mail.setReceivedDate(QMailTimeStamp::currentDateTime());
+    mail.setParentAccountId(config.id());
+
+    // Set mail recipient address.
+    QMailAddress To("Happu User", "HappyUser@Happy.com");
+    mail.setTo(To);
+
+    // Set mail sender address.
+    QMailAddress From("GrooveMail Dummy Spammer", "Spammer@groovemail.com");
+    mail.setFrom(From);
+
+    // Set mail subject text.
+    QString Subject("[");
+    Subject.append(QMailTimeStamp::currentDateTime().toString());
+    Subject.append("]");
+    Subject.append(" Greetings from our moden spam bot.");
+    mail.setSubject(Subject);
+
+    // Set mail mime header type.
+    mail.setMultipartType(QMailMessagePartContainer::MultipartMixed);
+
+    // Set mail content type and compose mail body text.
+    QMailMessageContentType Bodytype("text/plain; charset=UTF-8");
+    QString MsgTxt("This message has been generated by [");
+    MsgTxt.append(QMailTimeStamp::currentDateTime().toString());
+    MsgTxt.append("].");
+
+    // Add mail body text to first mime part and add to mail.
+    QMailMessagePart bodyPart;
+    QMailMessageBody MsgBody = QMailMessageBody::fromData(MsgTxt.toUtf8(), Bodytype, QMailMessageBody::EightBit);
+    bodyPart.setBody(MsgBody);
+    mail.appendPart(bodyPart);
+    qMailLog(DUMMYSOURCE) << " MsgBody = " << bodyPart.body().data() << flush;
+
+    // Now add a image attachment to mail.
+    QString fileName = "penguin.jpg";
+    QMailMessageContentDisposition disposition( QMailMessageContentDisposition::Attachment );
+    disposition.setFilename(fileName.toLatin1());
+
+    QMailMessageContentType attachmentType("image/jpg");
+
+    QMailMessagePart attachmentPart;
+    attachmentPart = QMailMessagePart::fromFile("/home/penguin.jpg", disposition, attachmentType, QMailMessageBody::Base64, QMailMessageBody::RequiresEncoding);
+    mail.appendPart(attachmentPart);
+    qMailLog(DUMMYSOURCE) << " attachmentPart = " << attachmentPart.body().data() << flush;
+
+    // Set mail contents availability parameters.
+    bool isComplete = 1;
+    mail.setStatus(QMailMessage::ContentAvailable, isComplete);
+    mail.setStatus(QMailMessage::PartialContentAvailable, isComplete);
+    mail.setContentSize(attachmentPart.body().length()+bodyPart.body().length());
+
+    // Calculate mail size.
+    mail.setSize(mail.contentSize());
+
+    // Classify mail content type for multipart existance based on contents.
+    classifier.classifyMessage(mail);
+
+    // Add mail message to store to simulate incoming mail.
+    QMailStore::instance()->addMessage(&mail);
+
+    if (isComplete && !mail.serverUid().isEmpty())
+    {
+        // We have now retrieved the entire message
+        messageProcessed(mail.serverUid());
+    }
+}
+
+void DummySourceClient::checkForNewMessages()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::checkForNewMessages() called" << flush;
+
+    // We can't have new messages without contacting the server
+    emit allMessagesReceived();
+}
+
+void DummySourceClient::cancelTransfer()
+{
+    operationFailed(QMailServiceAction::Status::ErrCancel, tr("Cancelled by user"));
+}
+
+void DummySourceClient::retrieveOperationCompleted()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::retrieveOperationCompleted() called" << flush;
+
+    // This retrieval may have been asynchronous
+    emit allMessagesReceived();
+
+    // Or it may have been requested by a waiting client
+    emit retrievalCompleted();
+
+    deactivateConnection();
+}
+
+void DummySourceClient::deactivateConnection()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceClient::deactivateConnection() called" << flush;
+
+    // Shutdown timer if active.
+    if(timer && timer->isActive())
+        timer->stop();
+
+    // Close connection.
+    if(transport && transport->connected())
+        transport->close();
+
+    // Set connection is free.
+    ConnectionActive = false;
+}
+
+void DummySourceClient::connectionInactive()
+{
+    deactivateConnection();
+}
+
+void DummySourceClient::messageProcessed(const QString &uid)
+{
+    emit messageActionCompleted(uid);
+}
+
+void DummySourceClient::operationFailed(int code, const QString &text)
+{
+    if (transport && transport->inUse()) {
+        transport->close();
+    }
+
+    deactivateConnection();
+
+    emit errorOccurred(code, text);
+}
+
+void DummySourceClient::operationFailed(QMailServiceAction::Status::ErrorCode code, const QString &text)
+{
+    QString msg;
+    if (code == QMailServiceAction::Status::ErrUnknownResponse) {
+        if (config.id().isValid()) {
+            DummySourceConfiguration dummyCfg(config);
+            msg = dummyCfg.mailServer() + ": ";
+        }
+    }
+    msg.append(text);
+
+    deactivateConnection();
+    emit errorOccurred(code, msg);
+}
diff --git a/src/plugins/messageservices/dummysource/dummyclient.h b/src/plugins/messageservices/dummysource/dummyclient.h
new file mode 100644
index 0000000..70c44e8
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummyclient.h
@@ -0,0 +1,115 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMY_SOURCE_CLIENT_H
+#define DUMMY_SOURCE_CLIENT_H
+
+#include <qstring.h>
+#include <qstringlist.h>
+#include <qobject.h>
+#include <qlist.h>
+#include <qtimer.h>
+#include <qmailaccountconfiguration.h>
+#include <qmailmessage.h>
+#include <qmailmessageclassifier.h>
+#include <qmailmessageserver.h>
+#include <qmailtransport.h>
+
+class LongStream;
+class QMailTransport;
+class QMailAccount;
+
+typedef QMap<QString, QMailMessageId> SelectionMap;
+
+class DummySourceClient : public QObject
+{
+    Q_OBJECT
+
+public:
+    DummySourceClient(QObject* parent);
+    ~DummySourceClient();
+
+    QMailMessage::MessageType messageType() const;
+
+    void setAccount(const QMailAccountId &accountId);
+    QMailAccountId account() const;
+
+    void newConnection();
+    void closeConnection();
+    void setOperation(QMailRetrievalAction::RetrievalSpecification spec);
+    void setDeleteOperation();
+    void setSelectedMails(const SelectionMap& data);
+    void checkForNewMessages();
+    void cancelTransfer();
+
+signals:
+    void errorOccurred(int, const QString &);
+    void errorOccurred(QMailServiceAction::Status::ErrorCode, const QString &);
+    void updateStatus(const QString &);
+
+    void messageActionCompleted(const QString &uid);
+
+    void progressChanged(uint, uint);
+    void retrievalCompleted();
+    void allMessagesReceived();
+
+protected slots:
+    void connected(QMailTransport::EncryptType encryptType);
+    void transportError(int, QString msg);
+
+    void connectionInactive();
+    void incomingData();
+
+private:
+    void deactivateConnection();
+    int nextMsgServerPos();
+    int msgPosFromUidl(QString uidl);
+    uint getSize(int pos);
+    void uidlIntegrityCheck();
+    void createMail();
+    void sendCommand(const char *data, int len = -1);
+    void sendCommand(const QString& cmd);
+    void sendCommand(const QByteArray& cmd);
+    QString readResponse();
+    void processResponse(const QString &response);
+    void nextAction();
+    void retrieveOperationCompleted();
+    void messageProcessed(const QString &uid);
+
+    void operationFailed(int code, const QString &text);
+    void operationFailed(QMailServiceAction::Status::ErrorCode code, const QString &text);
+
+    bool ConnectionActive;
+
+private:
+    enum TransferStatus
+    {
+        Init, CapabilityTest, Capabilities, 
+        StartTLS, TLS, Connected, Auth, 
+        RequestUids, Uidl, UidList,
+        RequestSizes, List, SizeList,
+        RequestMessage, Retr, MessageData,
+        DeleteMessage, Dele,
+        Done, Quit, Exit
+    };
+
+    QMailAccountConfiguration config;
+
+    QMap<int, uint> serverSize;
+
+    QMailTransport *transport;
+
+    QMailMessageClassifier classifier;
+
+    // Added for simulating mail retrieving.
+    QTimer *timer;
+};
+
+#endif
diff --git a/src/plugins/messageservices/dummysource/dummyconfiguration.cpp b/src/plugins/messageservices/dummysource/dummyconfiguration.cpp
new file mode 100644
index 0000000..625ddd0
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummyconfiguration.cpp
@@ -0,0 +1,133 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummyconfiguration.h"
+
+
+DummySourceConfiguration::DummySourceConfiguration(const QMailAccountConfiguration &config)
+    : QMailServiceConfiguration(config, "dummysource")
+{
+}
+
+DummySourceConfiguration::DummySourceConfiguration(const QMailAccountConfiguration::ServiceConfiguration &svcCfg)
+    : QMailServiceConfiguration(svcCfg)
+{
+}
+
+QString DummySourceConfiguration::mailUserName() const
+{
+    return value("username");
+}
+
+QString DummySourceConfiguration::mailPassword() const
+{
+    return decodeValue(value("password"));
+}
+
+QString DummySourceConfiguration::mailServer() const
+{
+    return value("server");
+}
+
+int DummySourceConfiguration::mailPort() const
+{
+    return value("port", "143").toInt();
+}
+
+int DummySourceConfiguration::mailEncryption() const
+{
+    return value("encryption", "0").toInt();
+}
+
+bool DummySourceConfiguration::canDeleteMail() const
+{
+    return (value("canDelete", "0").toInt() != 0);
+}
+
+bool DummySourceConfiguration::isAutoDownload() const
+{
+    return (value("autoDownload", "0").toInt() != 0);
+}
+
+int DummySourceConfiguration::maxMailSize() const
+{
+    return value("maxSize", "102400").toInt();
+}
+
+int DummySourceConfiguration::checkInterval() const
+{
+    return value("checkInterval", "-1").toInt();
+}
+
+bool DummySourceConfiguration::intervalCheckRoamingEnabled() const
+{
+    return (value("intervalCheckRoamingEnabled", "0").toInt() != 0);
+}
+
+
+DummySourceConfigurationEditor::DummySourceConfigurationEditor(QMailAccountConfiguration *config)
+    : DummySourceConfiguration(*config)
+{
+}
+
+void DummySourceConfigurationEditor::setMailUserName(const QString &str)
+{
+    setValue("username", str);
+}
+
+void DummySourceConfigurationEditor::setMailPassword(const QString &str)
+{
+    setValue("password", encodeValue(str));
+}
+
+void DummySourceConfigurationEditor::setMailServer(const QString &str)
+{
+    setValue("server", str);
+}
+
+void DummySourceConfigurationEditor::setMailPort(int i)
+{
+    setValue("port", QString::number(i));
+}
+
+#ifndef QT_NO_OPENSSL
+
+void DummySourceConfigurationEditor::setMailEncryption(int t)
+{
+    setValue("encryption", QString::number(t));
+}
+
+#endif
+
+void DummySourceConfigurationEditor::setDeleteMail(bool b)
+{
+    setValue("canDelete", QString::number(b ? 1 : 0));
+}
+
+void DummySourceConfigurationEditor::setAutoDownload(bool b)
+{
+    setValue("autoDownload", QString::number(b ? 1 : 0));
+}
+
+void DummySourceConfigurationEditor::setMaxMailSize(int i)
+{
+    setValue("maxSize", QString::number(i));
+}
+
+void DummySourceConfigurationEditor::setCheckInterval(int i)
+{
+    setValue("checkInterval", QString::number(i));
+}
+
+void DummySourceConfigurationEditor::setIntervalCheckRoamingEnabled(bool b)
+{
+    setValue("intervalCheckRoamingEnabled", QString::number(b ? 1 : 0));
+}
+
diff --git a/src/plugins/messageservices/dummysource/dummyconfiguration.h b/src/plugins/messageservices/dummysource/dummyconfiguration.h
new file mode 100644
index 0000000..a75466c
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummyconfiguration.h
@@ -0,0 +1,70 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMYCONFIGURATION_H
+#define DUMMYCONFIGURATION_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt Extended API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <qmailserviceconfiguration.h>
+
+class QTOPIAMAIL_EXPORT DummySourceConfiguration : public QMailServiceConfiguration
+{
+public:
+    explicit DummySourceConfiguration(const QMailAccountConfiguration &config);
+    explicit DummySourceConfiguration(const QMailAccountConfiguration::ServiceConfiguration &svcCfg);
+
+    QString mailUserName() const;
+    QString mailPassword() const;
+    QString mailServer() const;
+    int mailPort() const;
+    int mailEncryption() const;
+
+    bool canDeleteMail() const;
+
+    bool isAutoDownload() const;
+    int maxMailSize() const;
+
+    int checkInterval() const;
+    bool intervalCheckRoamingEnabled() const;
+};
+
+class QTOPIAMAIL_EXPORT DummySourceConfigurationEditor : public DummySourceConfiguration
+{
+public:
+    explicit DummySourceConfigurationEditor(QMailAccountConfiguration *config);
+
+    void setMailUserName(const QString &str);
+    void setMailPassword(const QString &str);
+    void setMailServer(const QString &str);
+    void setMailPort(int i);
+#ifndef QT_NO_OPENSSL
+    void setMailEncryption(int t);
+#endif
+
+    void setDeleteMail(bool b);
+
+    void setAutoDownload(bool autodl);
+    void setMaxMailSize(int i);
+
+    void setCheckInterval(int i);
+    void setIntervalCheckRoamingEnabled(bool enabled);
+};
+
+#endif
diff --git a/src/plugins/messageservices/dummysource/dummyservice.cpp b/src/plugins/messageservices/dummysource/dummyservice.cpp
new file mode 100644
index 0000000..57a0bae
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummyservice.cpp
@@ -0,0 +1,455 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummyservice.h"
+#include "dummyconfiguration.h"
+#include "dummysettings.h"
+#include <QTimer>
+#include <QtPlugin>
+
+#include <qmaillog.h>
+
+namespace { const QString serviceKey("dummysource"); }
+
+class DummySourceService::Source : public QMailMessageSource
+{
+    Q_OBJECT
+
+public:
+    Source(DummySourceService *service)
+        : QMailMessageSource(service),
+          _service(service),
+          _deleting(false),
+          _unavailable(false),
+          _mailCheckQueued(false),
+          _queuedMailCheckInProgress(false)
+    {
+        connect(&_service->_client, SIGNAL(allMessagesReceived()), this, SIGNAL(newMessagesAvailable()));
+        connect(&_service->_client, SIGNAL(messageActionCompleted(QString)), this, SLOT(messageActionCompleted(QString)));
+        connect(&_service->_client, SIGNAL(retrievalCompleted()), this, SLOT(retrievalCompleted()));
+        connect(&_intervalTimer, SIGNAL(timeout()), this, SLOT(queueMailCheck()));
+
+        qMailLog(DUMMYSOURCE) << "DummySourceService::Source called";
+    }
+
+    void setIntervalTimer(int interval)
+    {
+        _intervalTimer.stop();
+        if (interval > 0)
+            _intervalTimer.start(interval*1000*60); // interval minutes
+    }
+
+    virtual QMailStore::MessageRemovalOption messageRemovalOption() const { return QMailStore::CreateRemovalRecord; }
+
+public slots:
+    virtual bool retrieveFolderList(const QMailAccountId &accountId, const QMailFolderId &folderId, bool descending);
+    virtual bool retrieveMessageList(const QMailAccountId &accountId, const QMailFolderId &folderId, uint minimum, const QMailMessageSortKey &sort);
+
+    virtual bool retrieveMessages(const QMailMessageIdList &messageIds, QMailRetrievalAction::RetrievalSpecification spec);
+
+    virtual bool retrieveAll(const QMailAccountId &accountId);
+    virtual bool exportUpdates(const QMailAccountId &accountId);
+
+    virtual bool synchronize(const QMailAccountId &accountId);
+
+    virtual bool deleteMessages(const QMailMessageIdList &ids);
+
+    void messageActionCompleted(const QString &uid);
+    void retrievalCompleted();
+    void retrievalTerminated();
+    void queueMailCheck();
+
+private:
+    DummySourceService *_service;
+    bool _deleting;
+    bool _unavailable;
+    bool _mailCheckQueued;
+    bool _queuedMailCheckInProgress;
+    QTimer _intervalTimer;
+};
+
+bool DummySourceService::Source::retrieveFolderList(const QMailAccountId &accountId, const QMailFolderId &folderId, bool descending)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::retrieveFolderList() called";
+
+    if (!accountId.isValid()) {
+        _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
+        return false;
+    }
+
+    if (folderId.isValid()) {
+        // Folders don't make sense for POP
+        _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
+        return false;
+    }
+
+    // Just report success
+    QTimer::singleShot(0, this, SLOT(retrievalCompleted()));
+    return true;
+
+    Q_UNUSED(descending)
+}
+
+bool DummySourceService::Source::retrieveMessageList(const QMailAccountId &accountId, const QMailFolderId &folderId, uint minimum, const QMailMessageSortKey &sort)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::retrieveMessageList() called";
+
+    if (!accountId.isValid()) {
+        _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
+        return false;
+    }
+
+    if (folderId.isValid()) {
+        // Folders don't make sense for POP
+        _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
+        return false;
+    }
+
+    _service->_client.setOperation(QMailRetrievalAction::MetaData);
+    _service->_client.newConnection();
+    _unavailable = true;
+    return true;
+
+    Q_UNUSED(minimum)
+    Q_UNUSED(sort)
+}
+
+bool DummySourceService::Source::retrieveMessages(const QMailMessageIdList &messageIds, QMailRetrievalAction::RetrievalSpecification spec)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::retrieveMessages() called";
+
+    if (messageIds.isEmpty()) {
+        _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No messages to retrieve"));
+        return false;
+    }
+
+    if (spec == QMailRetrievalAction::Flags) {
+        // Just report success
+        QTimer::singleShot(0, this, SLOT(retrievalCompleted()));
+        return true;
+    }
+
+    SelectionMap selectionMap;
+    foreach (const QMailMessageId& id, messageIds) {
+        QMailMessageMetaData message(id);
+        selectionMap.insert(message.serverUid(), id);
+    }
+
+    _service->_client.setOperation(spec);
+    _service->_client.setSelectedMails(selectionMap);
+    _service->_client.newConnection();
+    _unavailable = true;
+    return true;
+}
+
+bool DummySourceService::Source::retrieveAll(const QMailAccountId &accountId)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::retrieveAll() called";
+
+    if (!accountId.isValid()) {
+        _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
+        return false;
+    }
+
+    _service->_client.setOperation(QMailRetrievalAction::MetaData);
+    _service->_client.newConnection();
+    _unavailable = true;
+    return true;
+}
+
+bool DummySourceService::Source::exportUpdates(const QMailAccountId &accountId)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::exportUpdates() called";
+
+    if (!accountId.isValid()) {
+        _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No account specified"));
+        return false;
+    }
+
+    // Just report success
+    QTimer::singleShot(0, this, SLOT(retrievalCompleted()));
+    return true;
+}
+
+bool DummySourceService::Source::synchronize(const QMailAccountId &accountId)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::synchronize() called";
+
+    return retrieveAll(accountId);
+}
+
+bool DummySourceService::Source::deleteMessages(const QMailMessageIdList &messageIds)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::deleteMessages() called";
+
+    if (messageIds.isEmpty()) {
+        _service->errorOccurred(QMailServiceAction::Status::ErrInvalidData, tr("No messages to delete"));
+        return false;
+    }
+
+    QMailAccountConfiguration accountCfg(_service->accountId());
+   DummySourceConfiguration dummyCfg(accountCfg);
+    if (dummyCfg.canDeleteMail()) {
+        // Delete the messages from the server
+        SelectionMap selectionMap;
+        foreach (const QMailMessageId& id, messageIds) {
+            QMailMessageMetaData message(id);
+            selectionMap.insert(message.serverUid(), id);
+        }
+
+        _deleting = true;
+        _service->_client.setDeleteOperation();
+        _service->_client.setSelectedMails(selectionMap);
+        _service->_client.newConnection();
+        _unavailable = true;
+        return true;
+    }
+
+    // Just delete the local copies
+    return QMailMessageSource::deleteMessages(messageIds);
+}
+
+void DummySourceService::Source::messageActionCompleted(const QString &uid)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::messageActionCompleted() called";
+
+    if (_deleting) {
+        QMailMessageMetaData metaData(uid, _service->accountId());
+        if (metaData.id().isValid()) {
+            QMailMessageIdList messageIds;
+            messageIds.append(metaData.id());
+
+            emit messagesDeleted(messageIds);
+        }
+    }
+}
+
+void DummySourceService::Source::retrievalCompleted()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::retrievalCompleted() called";
+
+    _unavailable = false;
+
+    if (_queuedMailCheckInProgress) {
+        _queuedMailCheckInProgress = false;
+        emit _service->availabilityChanged(true);
+    }
+
+    emit _service->activityChanged(QMailServiceAction::Successful);
+    emit _service->actionCompleted(true);
+
+    _deleting = false;
+
+    if (_mailCheckQueued) {
+        queueMailCheck();
+    }
+}
+
+void DummySourceService::Source::queueMailCheck()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::queueMailCheck() called";
+
+    if (_unavailable) {
+        _mailCheckQueued = true;
+        return;
+    }
+
+    _mailCheckQueued = false;
+    _queuedMailCheckInProgress = true;
+
+    emit _service->availabilityChanged(false);
+    synchronize(_service->accountId());
+}
+
+void DummySourceService::Source::retrievalTerminated()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::Source::retrievalTerminated() called";
+
+    _unavailable = false;
+    if (_queuedMailCheckInProgress) {
+        _queuedMailCheckInProgress = false;
+        emit _service->availabilityChanged(true);
+    }
+
+    // Just give up if an error occurs
+    _mailCheckQueued = false;
+}
+
+DummySourceService::DummySourceService(const QMailAccountId &accountId)
+    : QMailMessageService(),
+      _client(this),
+      _source(new Source(this))
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::DummySourceService() called";
+
+    connect(&_client, SIGNAL(progressChanged(uint, uint)), this, SIGNAL(progressChanged(uint, uint)));
+
+    connect(&_client, SIGNAL(errorOccurred(int, QString)), this, SLOT(errorOccurred(int, QString)));
+    connect(&_client, SIGNAL(errorOccurred(QMailServiceAction::Status::ErrorCode, QString)), this, SLOT(errorOccurred(QMailServiceAction::Status::ErrorCode, QString)));
+    connect(&_client, SIGNAL(updateStatus(QString)), this, SLOT(updateStatus(QString)));
+
+    _client.setAccount(accountId);
+    QMailAccountConfiguration accountCfg(accountId);
+    DummySourceConfiguration dummyCfg(accountCfg);
+    _source->setIntervalTimer(dummyCfg.checkInterval());
+
+    // Run the service daemon.
+   _source->synchronize(accountId);
+}
+
+DummySourceService::~DummySourceService()
+{
+    delete _source;
+}
+
+QString DummySourceService::service() const
+{
+    return serviceKey;
+}
+
+QMailAccountId DummySourceService::accountId() const
+{
+    return _client.account();
+}
+
+bool DummySourceService::hasSource() const
+{
+    return true;
+}
+
+QMailMessageSource &DummySourceService::source() const
+{
+    return *_source;
+}
+
+bool DummySourceService::available() const
+{
+    return true;
+}
+
+bool DummySourceService::cancelOperation()
+{
+    _client.cancelTransfer();
+    _client.closeConnection();
+    _source->retrievalTerminated();
+    return true;
+}
+
+void DummySourceService::errorOccurred(int code, const QString &text)
+{
+    updateStatus(code, text, _client.account());
+    _source->retrievalTerminated();
+    emit actionCompleted(false);
+}
+
+void DummySourceService::errorOccurred(QMailServiceAction::Status::ErrorCode code, const QString &text)
+{
+    updateStatus(code, text, _client.account());
+    _source->retrievalTerminated();
+    emit actionCompleted(false);
+}
+
+void DummySourceService::updateStatus(const QString &text)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceService::updateStatus() called";
+
+    updateStatus(QMailServiceAction::Status::ErrNoError, text, _client.account());
+}
+
+
+class DummySourceServiceConfigurator : public QMailMessageServiceConfigurator
+{
+public:
+    DummySourceServiceConfigurator();
+    ~DummySourceServiceConfigurator();
+
+    virtual QString service() const;
+    virtual QString displayName() const;
+
+    virtual QMailMessageServiceEditor *createEditor(QMailMessageServiceFactory::ServiceType type);
+};
+
+DummySourceServiceConfigurator::DummySourceServiceConfigurator()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceServiceConfigurator::DummySourceServiceConfigurator() called";
+}
+
+DummySourceServiceConfigurator::~DummySourceServiceConfigurator()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceServiceConfigurator::~DummySourceServiceConfigurator() called";
+}
+
+QString DummySourceServiceConfigurator::service() const
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceServiceConfigurator::service() called";
+    return serviceKey;
+}
+
+QString DummySourceServiceConfigurator::displayName() const
+{
+    qMailLog(DUMMYSOURCE) << "************* DummySourceServiceConfigurator::displayName() called";
+    return qApp->translate("QMailMessageService", "DUMMYSOURCE");
+}
+
+QMailMessageServiceEditor *DummySourceServiceConfigurator::createEditor(QMailMessageServiceFactory::ServiceType type)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceServiceConfigurator::createEditor(QMailMessageServiceFactory::ServiceType type) called";
+
+    if (type == QMailMessageServiceFactory::Source)
+        return new DummySourceSettings;
+
+    return 0;
+}
+
+Q_EXPORT_PLUGIN2(dummysource,DummySourceServicePlugin)
+
+DummySourceServicePlugin::DummySourceServicePlugin()
+    : QMailMessageServicePlugin()
+{
+        qMailLog(DUMMYSOURCE) << "DummySourceServicePlugin::DummySourceServicePlugin() called";
+}
+
+QString DummySourceServicePlugin::key() const
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceServicePlugin::key() called";
+
+    return serviceKey;
+}
+
+bool DummySourceServicePlugin::supports(QMailMessageServiceFactory::ServiceType type) const
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceServicePlugin::supports(QMailMessageServiceFactory::ServiceType type) called";
+
+    return (type == QMailMessageServiceFactory::Source);
+}
+
+bool DummySourceServicePlugin::supports(QMailMessage::MessageType type) const
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceServicePlugin::supports(QMailMessage::MessageType type) called";
+
+    return (type == QMailMessage::Email);
+}
+
+QMailMessageService *DummySourceServicePlugin::createService(const QMailAccountId &id)
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceServicePlugin::createService() called";
+
+    return new DummySourceService(id);
+}
+
+QMailMessageServiceConfigurator *DummySourceServicePlugin::createServiceConfigurator()
+{
+    qMailLog(DUMMYSOURCE) << "DummySourceServicePlugin::createServiceConfigurator() called";
+    return new DummySourceServiceConfigurator();
+}
+
+
+#include "dummyservice.moc"
+
diff --git a/src/plugins/messageservices/dummysource/dummyservice.h b/src/plugins/messageservices/dummysource/dummyservice.h
new file mode 100644
index 0000000..f8e685e
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummyservice.h
@@ -0,0 +1,72 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMYSERVICE_H
+#define DUMMYSERVICE_H
+
+#include "dummyclient.h"
+#include <qmailmessageservice.h>
+#include <qmaillog.h>
+
+QLOG_ENABLE(DUMMYSOURCE)
+
+class DummySourceService : public QMailMessageService
+{
+    Q_OBJECT
+
+public:
+    using QMailMessageService::updateStatus;
+
+    DummySourceService(const QMailAccountId &accountId);
+    ~DummySourceService();
+
+    virtual QString service() const;
+    virtual QMailAccountId accountId() const;
+
+    virtual bool hasSource() const;
+    virtual QMailMessageSource &source() const;
+
+    virtual bool available() const;
+
+public slots:
+    virtual bool cancelOperation();
+
+protected slots:
+    void errorOccurred(int code, const QString &text);
+    void errorOccurred(QMailServiceAction::Status::ErrorCode code, const QString &text);
+
+    void updateStatus(const QString& text);
+
+private:
+    class Source;
+    friend class Source;
+
+    DummySourceClient _client;
+    Source *_source;
+};
+
+
+class DummySourceServicePlugin : public QMailMessageServicePlugin
+{
+    Q_OBJECT
+
+public:
+    DummySourceServicePlugin();
+
+    virtual QString key() const;
+    virtual bool supports(QMailMessageServiceFactory::ServiceType type) const;
+    virtual bool supports(QMailMessage::MessageType type) const;
+
+    virtual QMailMessageService *createService(const QMailAccountId &id);
+    virtual QMailMessageServiceConfigurator *createServiceConfigurator();
+};
+
+
+#endif
diff --git a/src/plugins/messageservices/dummysource/dummysettings.cpp b/src/plugins/messageservices/dummysource/dummysettings.cpp
new file mode 100644
index 0000000..90e80a5
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummysettings.cpp
@@ -0,0 +1,157 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#include "dummysettings.h"
+#include "dummyconfiguration.h"
+#include <QLineEdit>
+#include <QMessageBox>
+#include <qmailaccount.h>
+#include <qmailaccountconfiguration.h>
+#include <qmailtransport.h>
+
+namespace {
+
+const QString serviceKey("dummysource");
+
+class PortValidator : public QValidator
+{
+public:
+    PortValidator(QWidget *parent = 0, const char *name = 0);
+
+    QValidator::State validate(QString &str, int &) const;
+};
+
+PortValidator::PortValidator(QWidget *parent, const char *name)
+    : QValidator(parent) 
+{
+    setObjectName(name);
+}
+
+QValidator::State PortValidator::validate(QString &str, int &) const
+{
+    // allow empty strings, as it's a bit awkward to edit otherwise
+    if ( str.isEmpty() )
+        return QValidator::Acceptable;
+
+    bool ok = false;
+    int i = str.toInt(&ok);
+    if ( !ok )
+        return QValidator::Invalid;
+
+    if ( i <= 0 || i >= 65536 )
+        return QValidator::Invalid;
+
+    return QValidator::Acceptable;
+}
+
+}
+
+
+DummySourceSettings::DummySourceSettings()
+    : QMailMessageServiceEditor(),
+      warningEmitted(false)
+{
+    setupUi(this);
+    setLayoutDirection(qApp->layoutDirection());
+
+    connect(intervalCheckBox, SIGNAL(stateChanged(int)), this, SLOT(intervalCheckChanged(int)));
+
+    const QString uncapitalised("email noautocapitalization");
+
+    // These fields should not be autocapitalised
+
+    mailPortInput->setValidator(new PortValidator(this));
+    mailPasswInput->setEchoMode(QLineEdit::PasswordEchoOnEdit);
+
+#ifdef QT_NO_OPENSSL
+    encryptionIncoming->hide();
+    lblEncryptionIncoming->hide();
+#endif
+
+}
+
+void DummySourceSettings::intervalCheckChanged(int enabled)
+{
+    intervalPeriod->setEnabled(enabled);
+    roamingCheckBox->setEnabled(enabled);
+}
+
+void DummySourceSettings::displayConfiguration(const QMailAccount &, const QMailAccountConfiguration &config)
+{
+    if (!config.services().contains(serviceKey)) {
+        // New account
+        mailUserInput->setText("");
+        mailPasswInput->setText("");
+        mailServerInput->setText("");
+        mailPortInput->setText("110");
+#ifndef QT_NO_OPENSSL
+        encryptionIncoming->setCurrentIndex(0);
+#endif
+        intervalCheckBox->setChecked(false);
+        roamingCheckBox->setChecked(false);
+    } else {
+        DummySourceConfiguration dummyConfig(config);
+
+        mailUserInput->setText(dummyConfig.mailUserName());
+        mailPasswInput->setText(dummyConfig.mailPassword());
+        mailServerInput->setText(dummyConfig.mailServer());
+        mailPortInput->setText(QString::number(dummyConfig.mailPort()));
+#ifndef QT_NO_OPENSSL
+        encryptionIncoming->setCurrentIndex(static_cast<int>(dummyConfig.mailEncryption()));
+#endif
+        deleteCheckBox->setChecked(dummyConfig.canDeleteMail());
+        maxSize->setValue(dummyConfig.maxMailSize());
+        thresholdCheckBox->setChecked(dummyConfig.maxMailSize() != -1);
+        intervalCheckBox->setChecked(dummyConfig.checkInterval() > 0);
+        intervalPeriod->setValue(qAbs(dummyConfig.checkInterval() ));
+        roamingCheckBox->setChecked(!dummyConfig.intervalCheckRoamingEnabled());
+    }
+
+    intervalPeriod->setEnabled(false);
+    roamingCheckBox->setEnabled(intervalCheckBox->isChecked());
+}
+
+bool DummySourceSettings::updateAccount(QMailAccount *account, QMailAccountConfiguration *config)
+{
+    bool result;
+    int port = mailPortInput->text().toInt(&result);
+    if ( (!result) ) {
+        // should only happen when the string is empty, since we use a validator.
+        port = -1;
+    }
+
+    if (!config->services().contains(serviceKey))
+        config->addServiceConfiguration(serviceKey);
+
+    DummySourceConfigurationEditor dummyConfig(config);
+
+    dummyConfig.setVersion(100 );
+    dummyConfig.setType(QMailServiceConfiguration::Source );
+
+    dummyConfig.setMailUserName(mailUserInput->text());
+    dummyConfig.setMailPassword(mailPasswInput->text());
+    dummyConfig.setMailServer(mailServerInput->text());
+    dummyConfig.setMailPort(port == -1 ? 110 : port);
+#ifndef QT_NO_OPENSSL
+    dummyConfig.setMailEncryption(static_cast<QMailTransport::EncryptType>(encryptionIncoming->currentIndex()));
+#endif
+    dummyConfig.setDeleteMail(deleteCheckBox->isChecked());
+    dummyConfig.setMaxMailSize(thresholdCheckBox->isChecked() ? maxSize->value() : -1);
+    dummyConfig.setAutoDownload(false );
+    dummyConfig.setCheckInterval(intervalPeriod->value() * (intervalCheckBox->isChecked() ? 1 : -1));
+    dummyConfig.setIntervalCheckRoamingEnabled(!roamingCheckBox->isChecked());
+
+    // Do we have a configuration we can use?
+    if (!dummyConfig.mailServer().isEmpty() && !dummyConfig.mailUserName().isEmpty())
+        account->setStatus(QMailAccount::CanRetrieve, true);
+
+    return true;
+}
+
diff --git a/src/plugins/messageservices/dummysource/dummysettings.h b/src/plugins/messageservices/dummysource/dummysettings.h
new file mode 100644
index 0000000..a02608e
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummysettings.h
@@ -0,0 +1,36 @@
+/****************************************************************************
+**
+** This file is part of the $PACKAGE_NAME$.
+**
+** Copyright (C) $THISYEAR$ $COMPANY_NAME$.
+**
+** $QT_EXTENDED_DUAL_LICENSE$
+**
+****************************************************************************/
+
+#ifndef DUMMYSETTINGS_H
+#define DUMMYSETTINGS_H
+
+#include "ui_dummysettings.h"
+#include <qmailmessageservice.h>
+
+class DummySourceSettings : public QMailMessageServiceEditor, private Ui::DummySourceSettings
+{
+    Q_OBJECT
+
+public:
+    DummySourceSettings();
+
+    void displayConfiguration(const QMailAccount &account, const QMailAccountConfiguration &config);
+    bool updateAccount(QMailAccount *account, QMailAccountConfiguration *config);
+
+private slots:
+    void pushCheckChanged(int enabled);
+    void intervalCheckChanged(int enabled);
+
+private:
+    bool warningEmitted;
+};
+
+#endif
+
diff --git a/src/plugins/messageservices/dummysource/dummysettings.ui b/src/plugins/messageservices/dummysource/dummysettings.ui
new file mode 100644
index 0000000..4bbcf6b
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummysettings.ui
@@ -0,0 +1,351 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>DummySourceSettings</class>
+ <widget class="QWidget" name="DummySourceSettings">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>365</width>
+    <height>256</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>Form</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <property name="margin">
+    <number>0</number>
+   </property>
+   <item>
+    <widget class="QScrollArea" name="scrollArea_2">
+     <property name="focusPolicy">
+      <enum>Qt::NoFocus</enum>
+     </property>
+     <property name="frameShape">
+      <enum>QFrame::NoFrame</enum>
+     </property>
+     <property name="lineWidth">
+      <number>0</number>
+     </property>
+     <property name="horizontalScrollBarPolicy">
+      <enum>Qt::ScrollBarAlwaysOff</enum>
+     </property>
+     <property name="widgetResizable">
+      <bool>true</bool>
+     </property>
+     <widget class="QWidget" name="scrollAreaWidgetContents_2">
+      <property name="geometry">
+       <rect>
+        <x>0</x>
+        <y>0</y>
+        <width>347</width>
+        <height>299</height>
+       </rect>
+      </property>
+      <layout class="QGridLayout">
+       <item row="0" column="0">
+        <widget class="QLabel" name="usernameLabel">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Username</string>
+         </property>
+         <property name="buddy">
+          <cstring>mailUserInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="0" column="1">
+        <widget class="QLineEdit" name="mailUserInput">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+        </widget>
+       </item>
+       <item row="1" column="0">
+        <widget class="QLabel" name="passwordLabel">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Password</string>
+         </property>
+         <property name="buddy">
+          <cstring>mailPasswInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="1" column="1">
+        <widget class="QLineEdit" name="mailPasswInput">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="echoMode">
+          <enum>QLineEdit::Password</enum>
+         </property>
+        </widget>
+       </item>
+       <item row="2" column="0">
+        <widget class="QLabel" name="serverLabel">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Server</string>
+         </property>
+         <property name="buddy">
+          <cstring>mailServerInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="2" column="1">
+        <widget class="QLineEdit" name="mailServerInput">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+        </widget>
+       </item>
+       <item row="3" column="0">
+        <widget class="QLabel" name="portLabel">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Port</string>
+         </property>
+         <property name="buddy">
+          <cstring>mailPortInput</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="3" column="1">
+        <widget class="QLineEdit" name="mailPortInput">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+        </widget>
+       </item>
+       <item row="4" column="0">
+        <widget class="QLabel" name="lblEncryptionIncoming">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Encryption</string>
+         </property>
+         <property name="buddy">
+          <cstring>encryptionIncoming</cstring>
+         </property>
+        </widget>
+       </item>
+       <item row="4" column="1">
+        <widget class="QComboBox" name="encryptionIncoming">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <item>
+          <property name="text">
+           <string>None</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>SSL</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>TLS</string>
+          </property>
+         </item>
+        </widget>
+       </item>
+       <item row="5" column="0" colspan="2">
+        <widget class="QCheckBox" name="deleteCheckBox">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="text">
+          <string>Remove deleted mail from server</string>
+         </property>
+         <property name="checked">
+          <bool>true</bool>
+         </property>
+        </widget>
+       </item>
+       <item row="6" column="0">
+        <widget class="QCheckBox" name="thresholdCheckBox">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="minimumSize">
+          <size>
+           <width>0</width>
+           <height>0</height>
+          </size>
+         </property>
+         <property name="text">
+          <string>Skip larger</string>
+         </property>
+         <property name="checked">
+          <bool>true</bool>
+         </property>
+        </widget>
+       </item>
+       <item row="7" column="0">
+        <widget class="QCheckBox" name="intervalCheckBox">
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="minimumSize">
+          <size>
+           <width>0</width>
+           <height>0</height>
+          </size>
+         </property>
+         <property name="text">
+          <string>Interval</string>
+         </property>
+        </widget>
+       </item>
+       <item row="8" column="1">
+        <widget class="QCheckBox" name="roamingCheckBox">
+         <property name="enabled">
+          <bool>false</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="minimumSize">
+          <size>
+           <width>0</width>
+           <height>0</height>
+          </size>
+         </property>
+         <property name="text">
+          <string>Disable when Roaming</string>
+         </property>
+        </widget>
+       </item>
+       <item row="7" column="1">
+        <widget class="QSpinBox" name="intervalPeriod">
+         <property name="enabled">
+          <bool>false</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="suffix">
+          <string comment="short for minutes">min</string>
+         </property>
+         <property name="minimum">
+          <number>10</number>
+         </property>
+         <property name="maximum">
+          <number>1440</number>
+         </property>
+         <property name="singleStep">
+          <number>10</number>
+         </property>
+         <property name="value">
+          <number>60</number>
+         </property>
+        </widget>
+       </item>
+       <item row="6" column="1">
+        <widget class="QSpinBox" name="maxSize">
+         <property name="enabled">
+          <bool>true</bool>
+         </property>
+         <property name="sizePolicy">
+          <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="suffix">
+          <string>K</string>
+         </property>
+         <property name="minimum">
+          <number>5</number>
+         </property>
+         <property name="maximum">
+          <number>5000</number>
+         </property>
+         <property name="singleStep">
+          <number>5</number>
+         </property>
+         <property name="value">
+          <number>20</number>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </widget>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>mailUserInput</tabstop>
+  <tabstop>mailPasswInput</tabstop>
+  <tabstop>mailServerInput</tabstop>
+  <tabstop>mailPortInput</tabstop>
+  <tabstop>encryptionIncoming</tabstop>
+  <tabstop>deleteCheckBox</tabstop>
+  <tabstop>thresholdCheckBox</tabstop>
+  <tabstop>maxSize</tabstop>
+  <tabstop>intervalCheckBox</tabstop>
+  <tabstop>intervalPeriod</tabstop>
+  <tabstop>roamingCheckBox</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/src/plugins/messageservices/dummysource/dummysource.pro b/src/plugins/messageservices/dummysource/dummysource.pro
new file mode 100644
index 0000000..747a057
--- /dev/null
+++ b/src/plugins/messageservices/dummysource/dummysource.pro
@@ -0,0 +1,31 @@
+TEMPLATE = lib 
+
+TARGET = dummysource
+
+target.path = $$QMF_INSTALL_ROOT/plugins/messageservices
+INSTALLS += target
+
+QT += network
+
+DEPENDPATH += .
+
+INCLUDEPATH += . ../../../libraries/qtopiamail \
+               ../../../libraries/messageserver \
+               ../../../libraries/qtopiamail/support
+
+LIBS += -L../../../libraries/qtopiamail -lqtopiamail \
+        -L../../../libraries/messageserver -lmessageserver
+
+HEADERS += dummyclient.h \
+           dummyconfiguration.h \
+           dummyservice.h \
+           dummysettings.h \
+           dummyauthenticator.h
+
+SOURCES += dummyclient.cpp \
+           dummyconfiguration.cpp \
+           dummyservice.cpp \
+           dummysettings.cpp \
+           dummyauthenticator.cpp
+
+FORMS += dummysettings.ui
diff --git a/src/settings/messagingaccounts/messagingaccounts.pro b/src/settings/messagingaccounts/messagingaccounts.pro
index 318aaf5..d62644e 100644
--- a/src/settings/messagingaccounts/messagingaccounts.pro
+++ b/src/settings/messagingaccounts/messagingaccounts.pro
@@ -7,11 +7,19 @@ INSTALLS += target
 DEPENDPATH += .
 
 INCLUDEPATH += . ../../libraries/qtopiamail \
-../../libraries/qtopiamail/support \
-../../libraries/messageserver
+                 ../../libraries/qtopiamail/support \
+                 ../../libraries/messageserver
 
-LIBS += -L../../libraries/qtopiamail -lqtopiamail \
--L../../libraries/messageserver -lmessageserver
+LIBS += -L../../libraries/qtopiamail    -lqtopiamail \
+        -L../../libraries/messageserver -lmessageserver
+
+sparql {
+
+LIBS += -L../../libraries/sparql -lsparql
+
+QMAKE_LFLAGS += -Wl,-rpath,../../libraries/sparql
+
+}
 
 HEADERS += accountsettings.h \
            editaccount.h \
diff --git a/src/tools/messageserver/etc/Xsession/51messageserver b/src/tools/messageserver/etc/Xsession/51messageserver
new file mode 100755
index 0000000..cf1c939
--- /dev/null
+++ b/src/tools/messageserver/etc/Xsession/51messageserver
@@ -0,0 +1,7 @@
+#!/bin/sh
+#
+# Start messageserver as soon as it was installed
+#
+set -e
+
+/etc/init.d/messageserver start
diff --git a/src/tools/messageserver/etc/messageserver b/src/tools/messageserver/etc/messageserver
new file mode 100755
index 0000000..e9ccb1a
--- /dev/null
+++ b/src/tools/messageserver/etc/messageserver
@@ -0,0 +1,86 @@
+#!/bin/sh
+### BEGIN INIT INFO
+# Provides:          messageserver
+# Required-Start:    Xsession
+# Required-Stop:
+# Should-Start:      
+# Should-Stop:
+# Default-Start:     0
+# Default-Stop:
+# Short-Description: Starts QMF message server
+# Description:
+### END INIT INFO
+
+DAEMON=/usr/bin/messageserver
+NAME=messageserver
+DESC="QMF Message Server"
+RESPAWN="-c 3 -T 180 -f"
+
+set -e
+
+clean_pid() {
+    if [ -f /var/tmp/messageserver-instance.lock ]; then
+        rm /var/tmp/messageserver-instance.lock
+    fi
+
+    if [ -f /var/tmp/qcop-server-0 ]; then
+        rm /var/tmp/qcop-server-0
+    fi
+
+    if [ -f /tmp/qcop-server-0 ]; then
+        rm /tmp/qcop-server-0
+    fi
+
+    if [ -z $DISPLAY ]; then
+        export DISPLAY=0:0
+    fi
+}
+
+# abort if no executable exists
+test -x $DAEMON || exit 0
+
+# When inside scratchbox we are not really root nor do we have 'user' user
+if [ ! -f /targets/links/scratchbox.config ]; then
+  USER=user
+  HOME=/home/$USER
+  if [ `id -u` = 0 ]; then
+    CHUID="--chuid $USER"
+    NICE="--nice=19"
+  fi
+fi
+
+# Setup X display if it is not defined yet
+if [ -z $DISPLAY ]; then
+    export DISPLAY=0:0
+fi
+
+# Start/stop or restart messageserver daemon.
+case "$1" in
+  start)
+    printf "Starting $DESC: $NAME"
+    clean_pid
+    dsmetool $NICE -U $USER $RESPAWN $DAEMON
+    printf ".\n"
+    ;;
+  stop)
+    printf "Stopping: $DESC: $NAME"
+    dsmetool -k $DAEMON
+    printf ".\n"
+    ;;
+  restart|force-reload)
+    printf "Restarting $DESC: $NAME"
+    dsmetool -k $DAEMON
+    sleep 1
+    clean_pid
+    dsmetool $NICE -U $USER $RESPAWN $DAEMON
+    printf ".\n"
+    ;;
+  *)
+    N=/etc/init.d/$NAME
+    echo "Usage: $N {start|stop|restart|force-reload}" >&2
+    exit 1
+    ;;
+esac
+
+exit 0
+
* Unmerged path src/tools/messageserver/messageserver.pro
diff --git a/tools/sparql-import/main.cpp b/tools/sparql-import/main.cpp
new file mode 100644
index 0000000..4fcdd02
--- /dev/null
+++ b/tools/sparql-import/main.cpp
@@ -0,0 +1,82 @@
+#include <QCoreApplication>
+
+#include "sparqluri.h"
+#include "sparqlquery.h"
+#include "sparqlresult.h"
+#include "sparqldatabase.h"
+#include "sparqlmailstore.h"
+
+#include <qmailstore.h>
+
+/**
+ * \brief Export database from the SQLite to SPARQ.
+ *
+ * This utility allows you to export your existing SQL
+ * mailstore to the SPARQL database.
+ */
+int main(int argc, char* argv[])
+{
+    QCoreApplication app(argc, argv);
+
+    SparqlDatabase database;
+    SparqlMailStore sparqlStore;
+
+    QMailStore* sqlStore = QMailStore::instance();
+
+    QMailAccountIdList accountIdList = sqlStore->queryAccounts();
+
+    foreach (QMailAccountId accountId, accountIdList)
+    {
+        QMailAccount account(accountId);
+
+        sparqlStore.addAccount(&account);
+
+        QMailFolderKey folderKey = QMailFolderKey::parentAccountId(accountId);
+
+        QMailFolderIdList folderIdList = sqlStore->queryFolders(folderKey);
+
+        foreach (QMailFolderId folderId, folderIdList)
+        {
+            QMailFolder folder(folderId);
+
+            sparqlStore.addFolder(&folder);
+
+            QMailMessageKey messageKey = QMailMessageKey::parentFolderId(folderId);
+
+            QMailMessageIdList messageIdList = sqlStore->queryMessages(messageKey);
+
+            foreach (QMailMessageId messageId, messageIdList)
+            {
+                QMailMessage message(messageId);
+
+                sparqlStore.addMessage(&message);
+            }
+        }
+    }
+
+    // Add all folders without any accounts
+    QMailFolderKey folderKey = QMailFolderKey::parentAccountId(QMailAccountId());
+    QMailFolderIdList folderIdList = sqlStore->queryFolders(folderKey);
+
+    foreach (QMailFolderId folderId, folderIdList)
+    {
+        QMailFolder folder(folderId);
+        
+        sparqlStore.addFolder(&folder);
+
+        QMailMessageKey messageKey = QMailMessageKey::parentFolderId(folderId);
+
+        QMailMessageIdList messageIdList = sqlStore->queryMessages(messageKey);
+
+        foreach (QMailMessageId messageId, messageIdList)
+        {
+            QMailMessage message(messageId);
+
+            sparqlStore.addMessage(&message);
+        }
+    }
+
+    return 0;
+}
+
+
diff --git a/tools/sparql-import/sparql-import.pro b/tools/sparql-import/sparql-import.pro
new file mode 100644
index 0000000..3429430
--- /dev/null
+++ b/tools/sparql-import/sparql-import.pro
@@ -0,0 +1,23 @@
+TEMPLATE = app
+
+TARGET = sparql-import
+
+QT += dbus
+
+DEPENDPATH += .
+
+INCLUDEPATH += . \
+    ../../src/libraries/qtopiamail \
+    ../../src/libraries/qtopiamail/support \
+    ../../src/libraries/sparql
+
+LIBS += -L../../src/libraries/qtopiamail -L../../src/libraries/sparql -lqtopiamail -lsparql
+
+QMAKE_LFLAGS += -Wl,-rpath,../../src/libraries/qtopiamail -Wl,-rpath,../../src/libraries/sparql
+
+# Input
+HEADERS += sparqlmailstore.h
+SOURCES += main.cpp sparqlmailstore.cpp
+
+target.path += $$QMF_INSTALL_ROOT/tests
+INSTALLS += target
diff --git a/tools/sparql-import/sparqlmailstore.cpp b/tools/sparql-import/sparqlmailstore.cpp
new file mode 100644
index 0000000..cfa78b7
--- /dev/null
+++ b/tools/sparql-import/sparqlmailstore.cpp
@@ -0,0 +1,1404 @@
+#include "sparqlmailstore.h"
+
+#include "sparqluri.h"
+#include "sparqlquery.h"
+#include "sparqlresult.h"
+
+
+#include <QDebug>
+
+namespace {
+
+QString escape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(escapee, QString(escaper) + escapee);
+}
+
+QString contentUri(const QString &scheme, const QString &identifier)
+{
+    if (scheme.isEmpty())
+        return QString();
+
+    // Formulate a URI from the content scheme and identifier
+    return escape(scheme, ':') + ':' + escape(identifier, ':');
+}
+
+QString contentUri(const QMailMessageMetaData &message)
+{
+    return contentUri(message.contentScheme(), message.contentIdentifier());
+}
+
+QString unescape(const QString &original, const QChar &escapee, const QChar &escaper = '\\')
+{
+    QString result(original);
+    return result.replace(QString(escaper) + escapee, escapee);
+}
+
+QPair<QString, QString> uriElements(const QString &uri)
+{
+    int index = uri.indexOf(':');
+    while ((index != -1) && (uri.at(index - 1) == '\\'))
+        index = uri.indexOf(':', index + 1);
+
+    return qMakePair(unescape(uri.mid(0, index), ':'), unescape(uri.mid(index + 1), ':'));
+}
+
+using namespace QMailKey;
+
+const char *WellKnownUris[] = {
+    "qmf://groove.harmattan.com/email#",
+    "qmf://groove.nokia.com/folder#",
+    "qmf://groove.nokia.com/accounts#" };
+
+template <int INDEX>
+class WellKnownUri : public SparqlUri
+{
+public:
+    WellKnownUri() : SparqlUri(WellKnownUris[INDEX]) {}
+    WellKnownUri(quint64 id) : SparqlUri(WellKnownUris[INDEX], id) {}
+};
+
+typedef WellKnownUri<0> MailMessageUri;
+typedef WellKnownUri<1> MailFolderUri;
+typedef WellKnownUri<2> MailAccountUri;
+
+QString combineOperatorString(QMailKey::Combiner op)
+{
+    switch (op)
+    {
+    case And:
+        return " && ";
+        break;
+
+    case Or:
+        return " || ";
+        break;
+
+    case None:
+        break;
+    }
+
+    return QString();
+}
+
+template <class Comparator>
+QString operatorString(Comparator op, int argsNumber = 1);
+
+QString operatorStringPattern(int argNumber, const QString& op, const QString& comp)
+{
+    QStringList pattern;
+    for (int i = 0; i<argNumber; i++)
+        pattern << "(%1 " + op + " %" + QString::number(i+2) + ")";
+
+    if (argNumber > 1)
+        return "(" + pattern.join(comp) + ")";
+    else
+        return pattern.join(comp);
+}
+
+template <>
+QString operatorString<QMailKey::Comparator>(QMailKey::Comparator op, int argsNumber)
+{
+    switch (op)
+    {
+    case Equal:
+        //  "(%1 = \"%2\")" : "(%1 = \"%2\") || (%1 = \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "=", "") : operatorStringPattern(argsNumber, "=", " || "));
+        break;
+
+    case NotEqual:
+        // "(%1 != \"%2\")" : "(%1 != \"%2\") && (%1 != \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "!=", "") : operatorStringPattern(argsNumber, "!=", " && "));
+        break;
+
+    case LessThan:
+        return "(%1 < %2)";
+        break;
+
+    case LessThanEqual:
+        return "(%1 <= %2)";
+        break;
+
+    case GreaterThan:
+        return "(%1 > %2)";
+        break;
+
+    case GreaterThanEqual:
+        return "(%1 >= %2)";
+        break;
+
+    case Includes:
+    case Present:
+        // "(%1 & \"%2\")" : "(%1 = \"%2\") || (%1 = \"%3\")"
+        return (argsNumber == 1 ? operatorStringPattern(argsNumber, "&", "") : operatorStringPattern(argsNumber, "=", " || "));
+        break;
+
+    case Excludes:
+    case Absent:
+        // "!(%1 & \"%2\")" : "(%1 != \"%2\") && (%1 != \"%3\")"
+        return (argsNumber == 1 ? "(!" + operatorStringPattern(argsNumber, "&", "") + ")": operatorStringPattern(argsNumber, "!=", " && "));
+        break;
+    }
+
+    return QString();
+}
+
+template <class Property>
+QString propertyNameString(Property property);
+
+template <>
+QString propertyNameString<QMailMessageKey::Property>(QMailMessageKey::Property property)
+{
+    switch (property)
+    {
+        case QMailMessageKey::Id:
+            return "?id";
+
+        case QMailMessageKey::Type:
+            return "?type";
+
+        case QMailMessageKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailMessageKey::Sender:
+            return "?sender";
+
+        case QMailMessageKey::Recipients:
+            return "?recipients";
+
+        case QMailMessageKey::Subject:
+            return "?subject";
+
+        case QMailMessageKey::TimeStamp:
+            return "?timestamp";
+
+        case QMailMessageKey::Status:
+            return "?status";
+
+        case QMailMessageKey::Conversation:
+            return "?conversation";
+
+        case QMailMessageKey::ReceptionTimeStamp:
+            return "?receptionTimeStamp";
+
+        case QMailMessageKey::ServerUid:
+            return "?serverUid";
+
+        case QMailMessageKey::Size:
+            return "?size";
+
+        case QMailMessageKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailMessageKey::AncestorFolderIds:
+            return "?ancestorFolderIds";
+
+        case QMailMessageKey::ContentType:
+            return "?contentType";
+
+        case QMailMessageKey::PreviousParentFolderId:
+            return "?previousParentFolderId";
+
+        case QMailMessageKey::ContentScheme:
+            return "?contentScheme";
+
+        case QMailMessageKey::ContentIdentifier:
+            return "?contentIdentifier";
+
+        case QMailMessageKey::InResponseTo:
+            return "?inResponseTo";
+
+        case QMailMessageKey::ResponseType:
+            return "?responseType";
+
+        case QMailMessageKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailFolderKey::Property>(QMailFolderKey::Property property)
+{
+    switch (property)
+    {
+        case QMailFolderKey::Id:
+            return "?id";
+
+        case QMailFolderKey::Path:
+            return "?path";
+
+        case QMailFolderKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailFolderKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailFolderKey::DisplayName:
+            return "?displayName";
+
+        case QMailFolderKey::Status:
+            return "?status";
+
+        case QMailFolderKey::AncestorFolderIds:
+            return "?ancestorFolderIds";
+
+        case QMailFolderKey::ServerCount:
+            return "?serverCount";
+
+        case QMailFolderKey::ServerUnreadCount:
+            return "?serverUnreadCount";
+
+        case QMailFolderKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailAccountKey::Property>(QMailAccountKey::Property property)
+{
+    switch (property)
+    {
+        case QMailAccountKey::Id:
+            return "?id";
+
+        case QMailAccountKey::Name:
+            return "?name";
+
+        case QMailAccountKey::MessageType:
+            return "?messageType";
+
+        case QMailAccountKey::FromAddress:
+            return "?fromAddress";
+
+        case QMailAccountKey::Status:
+            return "?status";
+
+        case QMailAccountKey::Custom:
+            return "?custom";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailMessageSortKey::Property>(QMailMessageSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailMessageSortKey::Id:
+            return "?id";
+
+        case QMailMessageSortKey::Type:
+            return "?type";
+
+        case QMailMessageSortKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailMessageSortKey::Sender:
+            return "?sender";
+
+        case QMailMessageSortKey::Recipients:
+            return "?recipients";
+
+        case QMailMessageSortKey::Subject:
+            return "?subject";
+
+        case QMailMessageSortKey::TimeStamp:
+            return "?timestamp";
+
+        case QMailMessageSortKey::Status:
+            return "?status";
+
+        case QMailMessageSortKey::ReceptionTimeStamp:
+            return "?receptionTimeStamp";
+
+        case QMailMessageSortKey::ServerUid:
+            return "?serverUid";
+
+        case QMailMessageSortKey::Size:
+            return "?size";
+
+        case QMailMessageSortKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailMessageSortKey::ContentType:
+            return "?contentType";
+
+        case QMailMessageSortKey::PreviousParentFolderId:
+            return "?previousParentFolderId";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailFolderSortKey::Property>(QMailFolderSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailFolderSortKey::Id:
+            return "?id";
+
+        case QMailFolderSortKey::Path:
+            return "?path";
+
+        case QMailFolderSortKey::ParentFolderId:
+            return "?parentFolderId";
+
+        case QMailFolderSortKey::ParentAccountId:
+            return "?parentAccountId";
+
+        case QMailFolderSortKey::DisplayName:
+            return "?displayName";
+
+        case QMailFolderSortKey::Status:
+            return "?status";
+
+        case QMailFolderSortKey::ServerCount:
+            return "?serverCount";
+
+        case QMailFolderSortKey::ServerUnreadCount:
+            return "?serverUnreadCount";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString propertyNameString<QMailAccountSortKey::Property>(QMailAccountSortKey::Property property)
+{
+    switch (property)
+    {
+        case QMailAccountSortKey::Id:
+            return "?id";
+
+        case QMailAccountSortKey::Name:
+            return "?name";
+
+        case QMailAccountSortKey::MessageType:
+            return "?messageType";
+
+        case QMailAccountSortKey::Status:
+            return "?status";
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class Property>
+QString sparqlPropertyStatmentString(const QString& uri, Property property);
+
+template <>
+QString sparqlPropertyStatmentString<QMailMessageKey::Property>(const QString& uri, QMailMessageKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailMessageKey::Id:
+            return QString();
+
+        case QMailMessageKey::Type:
+            return QString();
+
+        case QMailMessageKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Sender:
+            return QString("%1 nmo:sender [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Recipients:
+            return QString("%1 nmo:recipient [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Subject:
+            return QString("%1 nmo:messageSubject %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::TimeStamp:
+            return QString("%1 nmo:sentDate %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Conversation:
+            return QString();
+
+        case QMailMessageKey::ReceptionTimeStamp:
+            return QString();
+
+        case QMailMessageKey::ServerUid:
+            return QString("%1 nmo:messageId %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::Size:
+            return QString("%1 nie:contentSize %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::AncestorFolderIds:
+            return QString();
+
+        case QMailMessageKey::ContentType:
+            return QString();
+
+        case QMailMessageKey::PreviousParentFolderId:
+            return QString();
+
+        case QMailMessageKey::ContentScheme:
+            return QString();
+
+        case QMailMessageKey::ContentIdentifier:
+            return QString("%1 nie:isStoredAs [ rdf:type nie:DataObject ; nie:dataSource %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::InResponseTo:
+            return QString("%1 nmo:inReplyTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageKey::ResponseType:
+            return QString();
+
+        case QMailMessageKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailFolderKey::Property>(const QString& uri, QMailFolderKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailFolderKey::Id:
+            return "id";
+
+        case QMailFolderKey::Path:
+            return QString("%1 nmo:folderName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::DisplayName:
+            return QString("%1 nmo:folderDisplayName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::AncestorFolderIds:
+            return QString();
+
+        case QMailFolderKey::ServerCount:
+            return QString("%1 nmo:serverCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::ServerUnreadCount:
+            return QString("%1 nmo:serverUnreadCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailAccountKey::Property>(const QString& uri, QMailAccountKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailAccountKey::Id:
+            return QString();
+
+        case QMailAccountKey::Name:
+            return QString("%1 nmo:accountName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::MessageType:
+            return QString();
+
+        case QMailAccountKey::FromAddress:
+            return QString("%1 nmo:fromAddress [ rdf:type nco:EmailAddress ; nco:emailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountKey::Custom:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailMessageSortKey::Property>(const QString& uri, QMailMessageSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailMessageSortKey::Id:
+            return QString();
+
+        case QMailMessageSortKey::Type:
+            return QString();
+
+        case QMailMessageSortKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Sender:
+            return QString("%1 nmo:sender [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Recipients:
+            return QString("%1 nmo:recipient [ rdf:type nco:Contact ; nco:hasEmailAddress %2 ] .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Subject:
+            return QString("%1 nmo:messageSubject %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::TimeStamp:
+            return QString("%1 nmo:sentDate %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ReceptionTimeStamp:
+            return QString();
+
+        case QMailMessageSortKey::ServerUid:
+            return QString("%1 nmo:messageId %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::Size:
+            return QString("%1 nie:contentSize %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailMessageSortKey::ContentType:
+            return QString();
+
+        case QMailMessageSortKey::PreviousParentFolderId:
+            return QString();
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailFolderSortKey::Property>(const QString& uri, QMailFolderSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailFolderSortKey::Id:
+            return "id";
+
+        case QMailFolderSortKey::Path:
+            return QString("%1 nmo:folderName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ParentFolderId:
+            return QString("%1 nie:isLogicalPartOf %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ParentAccountId:
+            return QString("%1 nie:relatedTo %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::DisplayName:
+            return QString("%1 nmo:folderDisplayName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ServerCount:
+            return QString("%1 nmo:serverCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailFolderSortKey::ServerUnreadCount:
+            return QString("%1 nmo:serverUnreadCount %2 .").arg(uri).arg(propertyNameString(property));
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <>
+QString sparqlPropertyStatmentString<QMailAccountSortKey::Property>(const QString& uri, QMailAccountSortKey::Property property)
+{
+    /*
+     * TBD: Complete this function with all properties description.
+     */
+    switch (property)
+    {
+        case QMailAccountSortKey::Id:
+            return QString();
+
+        case QMailAccountSortKey::Name:
+            return QString("%1 nmo:accountName %2 .").arg(uri).arg(propertyNameString(property));
+
+        case QMailAccountSortKey::MessageType:
+            return QString();
+
+        case QMailAccountSortKey::Status:
+            return QString("%1 nmo:status %2 .").arg(uri).arg(propertyNameString(property));
+
+        default:
+            Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class Key, class SortKey>
+QString keyStatment(const QString& uri, const Key& key, const SortKey& sort = SortKey())
+{
+    typedef typename Key::ArgumentType     ArgumentType;
+    typedef typename SortKey::ArgumentType SortArgumentType;
+
+    QStringList arguments;
+    foreach (SortArgumentType argument, sort.arguments())
+    {
+        QString statement = sparqlPropertyStatmentString(uri, argument.first);
+        if (!arguments.contains(statement))
+            arguments << statement;
+    }
+
+    foreach (ArgumentType argument, key.arguments())
+    {
+        QString statement = sparqlPropertyStatmentString(uri, argument.property);
+        if (!arguments.contains(statement))
+            arguments << statement;
+    }
+
+    foreach (const Key& subkey, key.subKeys())
+        arguments << keyStatment(uri, subkey, SortKey());
+
+    return arguments.join("\n");
+}
+
+QString argumentValue(const QVariant& value)
+{
+    if (qVariantCanConvert<QMailAccountId>(value))
+        return MailAccountUri(qVariantValue<QMailAccountId>(value).toULongLong());
+    else if (qVariantCanConvert<QMailFolderId>(value))
+        return MailFolderUri(qVariantValue<QMailFolderId>(value).toULongLong());
+    else if (qVariantCanConvert<QMailMessageId>(value))
+        return MailMessageUri(qVariantValue<QMailMessageId>(value).toULongLong());
+    else if (qVariantCanConvert<QString>(value))
+        return qVariantValue<QString>(value);
+    else if (qVariantCanConvert<int>(value))
+        return QString::number(qVariantValue<int>(value));
+    else {
+        Q_ASSERT(false);
+    }
+    return QString();
+}
+
+template <class ArgumentType>
+QString keyArgument(const ArgumentType& argument)
+{
+    typedef typename ArgumentType::Property Property;
+    typedef typename ArgumentType::Comparator Comparator;
+
+    QString pattern = operatorString(argument.op, argument.valueList.count());
+    pattern = pattern.arg(propertyNameString(argument.property));
+
+    foreach (QVariant value, argument.valueList)
+        pattern = pattern.arg(argumentValue(value));
+
+    return pattern;
+}
+
+template <class Key>
+QString keyFilter(const Key& key)
+{
+    typedef typename Key::ArgumentType ArgumentType;
+
+    QStringList arguments;
+    foreach (ArgumentType argument, key.arguments())
+        arguments << keyArgument<ArgumentType>(argument);
+
+    foreach (const Key& subkey, key.subKeys())
+        arguments << keyFilter<Key>(subkey);
+
+    QString filter = arguments.size() > 1 ? QString(key.isNegated() ? "!(%1)" : "(%1)") :
+                                            QString(key.isNegated() ? "!(%1)" : "%1");
+    return filter.arg(arguments.join(combineOperatorString(key.combiner())));
+}
+
+template <class SortKey>
+QString sortKey(const SortKey& sortKey)
+{
+    typedef typename SortKey::ArgumentType ArgumentType;
+
+    QString orderCondition;
+    foreach (ArgumentType argument, sortKey.arguments())
+        if (argument.second == Qt::AscendingOrder)
+            orderCondition += QString(" ASC(%1)").arg(propertyNameString(argument.first));
+        else
+            orderCondition += QString(" DESC(%1)").arg(propertyNameString(argument.first));
+
+    if (!orderCondition.isEmpty())
+        return QString("ORDER BY %1").arg(orderCondition);
+
+    return QString();
+}
+
+QString keyQuery(const QMailMessageKey& key, const QMailMessageSortKey& sort = QMailMessageSortKey())
+{
+    QString query("SELECT ?mail \n"
+                  "WHERE { \n"
+                  "?mail rdf:type nmo:Email . \n"
+                  "%1"
+                  "%2"
+                  "} %3\n");
+
+    QString statement = keyStatment("?mail", key, sort);
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter).arg(sortKey(sort));
+}
+
+QString keyQuery(const QMailFolderKey& key, const QMailFolderSortKey& sort = QMailFolderSortKey())
+{
+    QString query("SELECT ?folder \n"
+                  "WHERE { \n"
+                  "?folder rdf:type nmo:MailFolder . \n"
+                  "%1"
+                  "%2"
+                  "} %3\n");
+
+    QString statement = keyStatment("?folder", key, sort);
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter).arg(sortKey(sort));
+}
+
+QString keyQuery(const QMailAccountKey& key, const QMailAccountSortKey& sort = QMailAccountSortKey())
+{
+    QString query("SELECT ?account \n"
+                  "WHERE { \n"
+                  "?account rdf:type nmo:Mailbox . \n"
+                  "%1"
+                  "%2"
+                  "} %3\n");
+
+    QString statement = keyStatment("?account", key, sort);
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter).arg(sortKey(sort));
+}
+
+QString keyCount(const QMailMessageKey& key)
+{
+    QString query("SELECT COUNT(?mail) AS count \n"
+                  "WHERE { \n"
+                  "?mail rdf:type nmo:Email . \n"
+                  "%1"
+                  "%2"
+                  "}\n");
+
+    QString statement = keyStatment("?mail", key, QMailAccountSortKey());
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter);
+}
+
+QString keyCount(const QMailFolderKey& key)
+{
+    QString query("SELECT COUNT(?folder) AS count \n"
+                  "WHERE { \n"
+                  "?folder rdf:type nmo:MailFolder . \n"
+                  "%1"
+                  "%2"
+                  "}\n");
+
+    QString statement = keyStatment("?folder", key, QMailAccountSortKey());
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter);
+}
+
+QString keyCount(const QMailAccountKey& key)
+{
+    QString query("SELECT COUNT(?account) AS count \n"
+                  "WHERE { \n"
+                  "?account rdf:type nmo:Mailbox . \n"
+                  "%1"
+                  "%2"
+                  "}\n");
+
+    QString statement = keyStatment("?account", key, QMailAccountSortKey());
+    if (!statement.isEmpty())
+        statement = QString("%1 \n").arg(statement);
+
+    QString filter;
+    if (!key.isEmpty())
+        filter = QString("FILTER %1 \n").arg(keyFilter(key));
+
+    return query.arg(statement).arg(filter);
+}
+
+template <class Key>
+void debugKey(const Key& key)
+{
+    typedef typename Key::ArgumentType ArgumentType;
+
+    qDebug() << "Key Combiner:" << key.combiner();
+    qDebug() << "Key Is empty:" << key.isEmpty();
+    qDebug() << "Key Non Matching:" << key.isNonMatching();
+    qDebug() << "Key Is Negated:" << key.isNegated();
+
+    foreach (ArgumentType argument, key.arguments())
+    {
+        qDebug() << "Argument Property:" << argument.property;
+        qDebug() << "Argument Comparator:" << argument.op;
+        foreach (QVariant value, argument.valueList)
+            qDebug() << "Argument Value List:" << value;
+    }
+
+    foreach (const Key& subkey, key.subKeys())
+        debugKey(subkey);
+}
+
+QString nmoRecipients(const QList<QMailAddress>& recipients)
+{
+    QString result;
+    foreach (const QMailAddress& address, recipients)
+    {
+        QString triplet(QString(
+    "        nmo:recipient [\n"
+    "            rdf:type nco:Contact ;\n"
+    "            nco:fullname \"%1\" ; \n"
+    "            nco:hasEmailAddress <mailto:%2> ] ;\n")
+                .arg(address.name())
+                .arg(address.address()));
+        result.append(triplet);
+    }
+    return result;
+}
+
+template <class T>
+T IdFromUri(const QString& uri)
+{
+    int pos = uri.indexOf('#');
+    if (pos >= 0)
+    {
+        bool ok = false;
+        quint64 postfix = uri.right(uri.length() - pos-1).toULongLong(&ok);
+
+        if (ok)
+            return T(postfix);
+    }
+
+    return T();
+}
+
+} // End of namespace
+
+void SparqlMailStore::addMessage(QMailMessageMetaData* metaData)
+{
+    MailMessageUri messageUri(metaData->id().toULongLong());
+    MailFolderUri  parentFolderUri(metaData->parentFolderId().toULongLong());
+    MailAccountUri parentAccountUri(metaData->parentAccountId().toULongLong());
+
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT {\n"
+    "%1 rdf:type nmo:Email ;\n"
+    "   nie:isLogicalPartOf %2 ;\n"
+    "   nmo:sender [\n"
+    "   rdf:type nco:Contact ;\n"
+    "       nco:fullname \"%3\" ; \n"
+    "       nco:hasEmailAddress <mailto:%4> ] ;\n"
+    + nmoRecipients(metaData->to()) +
+    "   nmo:messageSubject \"%5\" ;\n"
+    "   nmo:sentDate \"%6\"^^xsd:dateTime ;\n"
+    "   nmo:status \"%7\"^^xsd:integer ;\n"
+    "   nie:relatedTo %8 ;\n"
+    "   nie:isStoredAs [\n"
+    "       rdf:type nie:DataObject ;\n"
+    "       nie:dataSource <%9> ] ;\n"
+    "   nmo:messageId \"%10\" ;\n"
+    "   nie:contentSize \"%11\"^^xsd:integer ;\n"
+    "   nie:mimeType \"%12\" ;\n"
+    "   nmo:inReplyTo \"%13\" ;\n"
+    "   nmo:messageHeader [\n"
+    "       rdf:type nmo:MessageHeader ;\n"
+    "       nmo:headerName \"responseType\" ;\n"
+    "       nmo:headerValue \"%14\" ] ;\n"
+    "   nmo:receivedDate \"%15\"^^xsd:dateTime .\n"
+    "}").arg(messageUri.uri())
+        .arg(parentFolderUri.uri())
+        .arg(metaData->from().name())
+        .arg(metaData->from().address())
+        .arg(metaData->subject())
+        .arg(QMailTimeStamp(metaData->date()).toLocalTime().toString())
+        .arg(static_cast<int>(metaData->status()))
+        .arg(parentAccountUri.uri())
+        .arg(::contentUri(*metaData))
+        .arg(metaData->serverUid())
+        .arg(metaData->size())
+        .arg(static_cast<int>(metaData->content()))
+        .arg(metaData->inResponseTo().toULongLong())
+        .arg(metaData->responseType())
+        .arg(QMailTimeStamp(metaData->receivedDate()).toLocalTime().toString()));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return;
+    }
+
+    qDebug() << "Query succeeded";
+    metaData->setId(QMailMessageId(messageUri.id()));
+}
+
+void SparqlMailStore::addFolder(QMailFolder* folder)
+{
+    MailFolderUri folderUri(folder->id().toULongLong());
+    MailFolderUri parentFolderUri(folder->parentFolderId().toULongLong());
+    MailAccountUri parentAccountUri(folder->parentAccountId().toULongLong());
+
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "%1 rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName \"%2\" ; \n"
+    "   nie:isLogicalPartOf %3 ; \n"
+    "   nie:relatedTo %4 ; \n"
+    "   nmo:folderDisplayName \"%5\" ; \n"
+    "   nmo:status \"%6\"^^xsd:integer ; \n"
+    "   nmo:serverCount \"%7\"^^xsd:integer ; \n"
+    "   nmo:serverUnreadCount \"%8\"^^xsd:integet . \n"
+    "}").arg(folderUri.uri())
+        .arg(folder->path())
+        .arg(parentFolderUri.uri())
+        .arg(parentAccountUri.uri())
+        .arg(folder->displayName())
+        .arg(folder->status())
+        .arg(folder->serverCount())
+        .arg(folder->serverUnreadCount()));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return;
+    }
+
+    qDebug() << "Query succeeded";
+    folder->setId(QMailFolderId(folderUri.id()));
+
+    // TBD: Update folder links also
+}
+
+void SparqlMailStore::addAccount(QMailAccount* account)
+{
+    MailAccountUri accountUri(account->id().toULongLong());
+    SparqlQuery query(SparqlQuery::UpdateQuery);
+    query.prepare(QString(
+    "INSERT { \n"
+    "%1 rdf:type nmo:Mailbox ; \n"
+    "   nmo:accountName \"%2\" ; \n"
+    "   nmo:status \"%3\"^^xsd:integer ; \n"
+    "   nmo:signature \"%4\" ; \n"
+    "   nmo:fromAddress [ \n"
+    "       rdf:type nco:EmailAddress ; \n"
+    "       nco:emailAddress \"%5\" ] . \n"
+    "}").arg(accountUri.uri())
+        .arg(account->name())
+        .arg(account->status())
+        .arg(account->signature())
+        .arg(account->fromAddress().toString(true)));
+
+    // TBD: Add custom fields later
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return;
+    }
+
+    qDebug() << "Query succeeded";
+    account->setId(QMailAccountId(accountUri.id()));
+}
+
+QMailAccount SparqlMailStore::account(const QMailAccountId& id) const
+{
+    QMailAccount account;
+
+    MailMessageUri messageUri(id.toULongLong());
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?name ?signature ?fromAddress \n"
+    "WHERE { \n"
+    "%1 rdf:type nmo:Mailbox ; \n"
+    "   nmo:accountName ?name ; \n"
+    "   nmo:status ?status ; \n"
+    "   nmo:signature ?signature ; \n"
+    "   nmo:fromAddress [ \n"
+    "       rdf:type nco:EmailAddress ; \n"
+    "       nco:emailAddress ?fromAddress ] . \n"
+    "}").arg(messageUri.uri()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return account;
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    QStringList list = result.fetchRow();
+
+    account.setId(id);
+    account.setName(list.at(0));
+  account.setStatus(list.at(1).toULongLong());
+    account.setSignature(list.at(1));
+    account.setFromAddress(QMailAddress(list.at(2)));
+
+    return account;
+}
+
+QMailFolder SparqlMailStore::folder(const QMailFolderId& id) const
+{
+    MailFolderUri folderUri(id.toULongLong());
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?name ?parentFolder ?parentAccount ?displayName \n"
+    "WHERE { \n"
+    "%1 rdf:type nmo:MailFolder ; \n"
+    "   nmo:folderName ?name ; \n"
+    "   nie:isLogicalPartOf ?parentFolder ; \n"
+    "   nie:relatedTo ?parentAccount ; \n"
+    "   nmo:folderDisplayName ?displayName ; \n"
+    "   nmo:status ?status ; \n"
+    "   nmo:serverCount ?serverCount ; \n"
+    "   nmo:serverUnreadCount ?serverUnreadCount . \n"
+    "}").arg(folderUri.uri()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return QMailFolder();
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    QStringList list = result.fetchRow();
+
+    QMailFolder folder(list.at(0), IdFromUri<QMailFolderId>(list.at(1)), IdFromUri<QMailAccountId>(list.at(2)));
+    folder.setId(id);
+    folder.setDisplayName(list.at(3));
+    folder.setStatus(list.at(4).toULongLong());
+    folder.setServerCount(list.at(5).toUInt());
+    folder.setServerUnreadCount(list.at(6).toUInt());
+
+    return folder;
+}
+
+QMailMessage SparqlMailStore::message(const QMailMessageId& id) const
+{
+    MailMessageUri messageUri(id.toULongLong());
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(QString(
+    "SELECT ?fullName ?mailAddress \n"
+    "WHERE { \n"
+    "%1 rdf:type nmo:Email ; \n"
+    "   nmo:recipient [ \n"
+    "       rdf:type nco:Contact ; \n"
+    "       nco:fullname ?fullName ; \n"
+    "       nco:hasEmailAddress ?mailAddress ] \n"
+    "}").arg(messageUri.uri()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return QMailMessage();
+    }
+
+    SparqlResult result = query.result();
+
+    QList<QMailAddress> recipients;
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        recipients.push_back(QMailAddress(row.at(0), row.at(1)));
+    }
+
+    query.prepare(QString(
+    "SELECT ?folderId ?senderFullName ?senderEmailAddress ?messageSubject ?sentDate ?status ?accountId ?dataSource ?uid ?contentSize ?mimeType ?inReplyTo ?headerValue ?receivedDate \n"
+    "WHERE { \n"
+    "%1 rdf:type nmo:Email ;\n"
+    "   nie:isLogicalPartOf ?folderId ;\n"
+    "   nmo:sender [\n"
+    "       rdf:type nco:Contact ;\n"
+    "       nco:fullname ?senderFullName ; \n"
+    "       nco:hasEmailAddress ?senderEmailAddress ] ;\n"
+    "   nmo:messageSubject ?messageSubject ;\n"
+    "   nmo:sentDate ?sentDate ;\n"
+    "   nmo:status ?status ;\n"
+    "   nie:relatedTo ?accountId ;\n"
+    "   nie:isStoredAs [\n"
+    "       rdf:type nie:DataObject ;\n"
+    "       nie:dataSource ?dataSource ] ;\n"
+    "   nmo:messageId ?uid ;\n"
+    "   nie:contentSize ?contentSize ;\n"
+    "   nie:mimeType ?mimeType ;\n"
+    "   nmo:inReplyTo ?inReplyTo ;\n"
+    "       nmo:messageHeader [\n"
+    "       rdf:type nmo:MessageHeader ;\n"
+    "       nmo:headerName \"responseType\" ;\n"
+    "       nmo:headerValue ?headerValue ] ;\n"
+    "   nmo:receivedDate ?receivedDate .\n"
+    "}").arg(messageUri.uri()));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return QMailMessage();
+    }
+
+    result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    QStringList list = result.fetchRow();
+
+    QMailMessage message;
+    message.setId(id);
+    message.setParentFolderId(IdFromUri<QMailFolderId>(list.at(0)));
+    message.setFrom(QMailAddress(list.at(1), list.at(2)));
+    message.setSubject(list.at(3));
+    message.setDate(QMailTimeStamp(list.at(4)));
+    message.setStatus(list.at(5).toULongLong());
+    message.setParentAccountId(IdFromUri<QMailAccountId>(list.at(6)));
+    message.setServerUid(list.at(10));
+    message.setSize(list.at(9).toUInt());
+    message.setContent((QMailMessageMetaDataFwd::ContentType)list.at(10).toInt());
+    message.setInResponseTo(QMailMessageId(IdFromUri<QMailMessageId>(list.at(11))));
+    message.setResponseType((QMailMessageMetaDataFwd::ResponseType)list.at(12).toInt());
+    message.setReceivedDate(QMailTimeStamp(list.at(13)));
+
+    message.setTo(recipients);
+
+    return message;
+}
+
+int SparqlMailStore::countAccounts(const QMailAccountKey& key) const
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyCount(key));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return 0;
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    return result.fetchRow().first().toInt();
+}
+
+int SparqlMailStore::countFolders(const QMailFolderKey& key) const
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyCount(key));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return 0;
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    return result.fetchRow().first().toInt();
+}
+
+int SparqlMailStore::countMessages(const QMailMessageKey& key) const
+{
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyCount(key));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return 0;
+    }
+
+    SparqlResult result = query.result();
+
+    Q_ASSERT(!result.end());
+
+    return result.fetchRow().first().toInt();
+}
+
+QMailAccountIdList SparqlMailStore::queryAccounts(const QMailAccountKey &key, const QMailAccountSortKey &sortKey) const
+{
+    QMailAccountIdList accountIdList;
+
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyQuery(key, sortKey));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return accountIdList;
+    }
+
+    SparqlResult result = query.result();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        accountIdList << IdFromUri<QMailAccountId>(row.first());
+    }
+
+    return accountIdList;
+}
+
+QMailFolderIdList SparqlMailStore::queryFolders(const QMailFolderKey &key, const QMailFolderSortKey &sortKey) const
+{
+    QMailFolderIdList folderIdList;
+
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyQuery(key, sortKey));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return folderIdList;
+    }
+
+    SparqlResult result = query.result();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        folderIdList << IdFromUri<QMailFolderId>(row.first());
+    }
+
+    return folderIdList;
+}
+
+QMailMessageIdList SparqlMailStore::queryMessages(const QMailMessageKey &key, const QMailMessageSortKey &sortKey) const
+{
+    QMailMessageIdList messageIdList;
+
+    SparqlQuery query(SparqlQuery::SearchQuery);
+    query.prepare(keyQuery(key, sortKey));
+
+    if (!query.exec())
+    {
+        qDebug() << "Query failed:" << query.error();
+        return messageIdList;
+    }
+
+    SparqlResult result = query.result();
+
+    while (!result.end())
+    {
+        QStringList row = result.fetchRow();
+        messageIdList << IdFromUri<QMailMessageId>(row.first());
+    }
+
+    return messageIdList;
+}
+
+void SparqlMailStore::updateMessage(const QMailMessageMetaData& metedata)
+{
+    Q_UNUSED(metedata);
+}
+
+void SparqlMailStore::updateFolder(const QMailFolder& folder)
+{
+    Q_UNUSED(folder);
+}
+
+void SparqlMailStore::updateAccount(const QMailAccount& account)
+{
+    Q_UNUSED(account);
+}
+
+void SparqlMailStore::removeMessage(const QMailMessageMetaData& metadata)
+{
+    Q_UNUSED(metadata);
+}
+
+void SparqlMailStore::removeFolder(const QMailFolder& folder)
+{
+    Q_UNUSED(folder);
+}
+
+void SparqlMailStore::removeAccount(const QMailAccount& account)
+{
+    Q_UNUSED(account);
+}
diff --git a/tools/sparql-import/sparqlmailstore.h b/tools/sparql-import/sparqlmailstore.h
new file mode 100644
index 0000000..9bcd838
--- /dev/null
+++ b/tools/sparql-import/sparqlmailstore.h
@@ -0,0 +1,42 @@
+#ifndef MAILSTORE_H
+#define MAILSTORE_H
+
+#include <qmailmessage.h>
+#include <qmailfolder.h>
+#include <qmailaccount.h>
+#include <qmailaccountkey.h>
+#include <qmailfolderkey.h>
+#include <qmailmessagekey.h>
+#include <qmailaccountsortkey.h>
+#include <qmailfoldersortkey.h>
+#include <qmailmessagesortkey.h>
+
+class SparqlMailStore
+{
+public:
+    void addMessage(QMailMessageMetaData* metaData);
+    void addFolder(QMailFolder* folder);
+    void addAccount(QMailAccount* account);
+
+    QMailAccount account(const QMailAccountId& id) const;
+    QMailFolder folder(const QMailFolderId& id) const;
+    QMailMessage message(const QMailMessageId& id) const;
+
+    int countAccounts(const QMailAccountKey& key = QMailAccountKey()) const;
+    int countFolders(const QMailFolderKey& key = QMailFolderKey()) const;
+    int countMessages(const QMailMessageKey& key = QMailMessageKey()) const;
+
+    QMailAccountIdList queryAccounts(const QMailAccountKey &key = QMailAccountKey(), const QMailAccountSortKey &sortKey = QMailAccountSortKey()) const;
+    QMailFolderIdList queryFolders(const QMailFolderKey &key = QMailFolderKey(), const QMailFolderSortKey &sortKey = QMailFolderSortKey()) const;
+    QMailMessageIdList queryMessages(const QMailMessageKey &key = QMailMessageKey(), const QMailMessageSortKey &sortKey = QMailMessageSortKey()) const;
+
+    void updateMessage(const QMailMessageMetaData& meteData);
+    void updateFolder(const QMailFolder& folder);
+    void updateAccount(const QMailAccount& account);
+
+    void removeMessage(const QMailMessageMetaData& metaData);
+    void removeFolder(const QMailFolder& folder);
+    void removeAccount(const QMailAccount& account);
+};
+
+#endif // MAILSTORE_H
